

getfrom che-4.7.0.sh
======================

# See: https://sipb.mit.edu/doc/safe-shell/
set -e
set -u
init_logging
//
init_logging() {
  BLUE='\033[1;34m'
  GREEN='\033[0;32m'
  RED='\033[0;31m'
  NC='\033[0m'
}

check_docker
//
check_docker() {
  if ! docker ps > /dev/null 2>&1; then
    output=$(docker ps)
    error_exit "Error - Docker not installed properly: \n${output}"
  fi

  # Prep script by getting default image
  if [ "$(docker images -q alpine 2> /dev/null)" = "" ]; then
    info "ECLIPSE CHE: PULLING IMAGE alpine:latest"
    docker pull alpine > /dev/null 2>&1
  fi
}




init_global_variables
//
init_global_variables() {

  # Name used in INFO statements
  DEFAULT_CHE_PRODUCT_NAME="ECLIPSE CHE"

  # Name used in CLI statements
  DEFAULT_CHE_MINI_PRODUCT_NAME="che"

  DEFAULT_CHE_LAUNCHER_IMAGE_NAME="codenvy/che-launcher"
  DEFAULT_CHE_SERVER_IMAGE_NAME="codenvy/che-server"
  DEFAULT_CHE_DIR_IMAGE_NAME="codenvy/che-dir"
  DEFAULT_CHE_MOUNT_IMAGE_NAME="codenvy/che-mount"
  DEFAULT_CHE_ACTION_IMAGE_NAME="codenvy/che-action"
  DEFAULT_CHE_TEST_IMAGE_NAME="codenvy/che-test"
  DEFAULT_CHE_DEV_IMAGE_NAME="codenvy/che-dev"
  DEFAULT_CHE_SERVER_CONTAINER_NAME="che-server"
  DEFAULT_CHE_VERSION="latest"
  DEFAULT_CHE_CLI_ACTION="help"
  DEFAULT_IS_INTERACTIVE="true"

  CHE_PRODUCT_NAME=${CHE_PRODUCT_NAME:-${DEFAULT_CHE_PRODUCT_NAME}}
  CHE_MINI_PRODUCT_NAME=${CHE_MINI_PRODUCT_NAME:-${DEFAULT_CHE_MINI_PRODUCT_NAME}}
  CHE_LAUNCHER_IMAGE_NAME=${CHE_LAUNCHER_IMAGE_NAME:-${DEFAULT_CHE_LAUNCHER_IMAGE_NAME}}
  CHE_SERVER_IMAGE_NAME=${CHE_SERVER_IMAGE_NAME:-${DEFAULT_CHE_SERVER_IMAGE_NAME}}
  CHE_DIR_IMAGE_NAME=${CHE_DIR_IMAGE_NAME:-${DEFAULT_CHE_DIR_IMAGE_NAME}}
  CHE_MOUNT_IMAGE_NAME=${CHE_MOUNT_IMAGE_NAME:-${DEFAULT_CHE_MOUNT_IMAGE_NAME}}
  CHE_ACTION_IMAGE_NAME=${CHE_ACTION_IMAGE_NAME:-${DEFAULT_CHE_ACTION_IMAGE_NAME}}
  CHE_TEST_IMAGE_NAME=${CHE_TEST_IMAGE_NAME:-${DEFAULT_CHE_TEST_IMAGE_NAME}}
  CHE_DEV_IMAGE_NAME=${CHE_DEV_IMAGE_NAME:-${DEFAULT_CHE_DEV_IMAGE_NAME}}
  CHE_SERVER_CONTAINER_NAME=${CHE_SERVER_CONTAINER_NAME:-${DEFAULT_CHE_SERVER_CONTAINER_NAME}}
  CHE_VERSION=${CHE_VERSION:-${DEFAULT_CHE_VERSION}}
  CHE_CLI_ACTION=${CHE_CLI_ACTION:-${DEFAULT_CHE_CLI_ACTION}}
  IS_INTERACTIVE=${IS_INTERACTIVE:-${DEFAULT_IS_INTERACTIVE}}

  GLOBAL_NAME_MAP=$(docker info | grep "Name:" | cut -d" " -f2)
  GLOBAL_HOST_ARCH=$(docker version --format {{.Client}} | cut -d" " -f5)
  GLOBAL_UNAME=$(docker run --rm alpine sh -c "uname -r")
  GLOBAL_GET_DOCKER_HOST_IP=$(get_docker_host_ip)

  USAGE="
Usage: ${CHE_MINI_PRODUCT_NAME} [COMMAND]
           start                              Starts ${CHE_MINI_PRODUCT_NAME} server
           stop                               Stops ${CHE_MINI_PRODUCT_NAME} server
           restart                            Restart ${CHE_MINI_PRODUCT_NAME} server
           update                             Pulls specific version, respecting CHE_VERSION
           profile add <name>                 Add a profile to ~/.che/ 
           profile set <name>                 Set this profile as the default for ${CHE_MINI_PRODUCT_NAME} CLI
           profile unset                      Removes the default profile - leaves it unset
           profile rm <name>                  Remove this profile from ~/.che/
           profile update <name>              Update profile in ~/.che/
           profile info <name>                Print the profile configuration
           profile list                       List available profiles
           mount <local-path> <ws-ssh-port>   Synchronize workspace to a local directory
           dir init                           Initialize directory with ${CHE_MINI_PRODUCT_NAME} configuration
           dir up                             Create workspace from source in current directory
           dir down                           Stop workspace running in current directory
           dir status                         Display status of ${CHE_MINI_PRODUCT_NAME} in current directory
           action <action-name> [--help]      Start action on ${CHE_MINI_PRODUCT_NAME} instance
           compile <mvn-command>              SDK - Builds Che source code or modules
           test <test-name> [--help]          Start test on ${CHE_MINI_PRODUCT_NAME} instance
           info [ --all                       Run all debugging tests
                  --server                    Run ${CHE_MINI_PRODUCT_NAME} launcher and server debugging tests
                  --networking                Test connectivity between ${CHE_MINI_PRODUCT_NAME} sub-systems
                  --cli                       Print CLI (this program) debugging info
                  --create [<url>]            Test creating a workspace and project in ${CHE_MINI_PRODUCT_NAME}
                           [<user>] 
                           [<pass>] ]
"
}


parse_command_line "$@"
//

parse_command_line () {
  if [ $# -eq 0 ]; then 
    CHE_CLI_ACTION="help"
  else
    case $1 in
      start|stop|restart|update|info|profile|action|dir|mount|compile|test|help|-h|--help)
        CHE_CLI_ACTION=$1
      ;;
      *)
        # unknown option
        error_exit "You passed an unknown command line option."
      ;;
    esac
  fi
}


if is_boot2docker; then
//
is_boot2docker() {
  if echo "$GLOBAL_UNAME" | grep -q "boot2docker"; then
    return 0
  else
    return 1
  fi
}


  debug ""
  debug "!!! Boot2docker detected - save workspaces only in %userprofile% !!!"
  debug ""
fi

case ${CHE_CLI_ACTION} in
  start|stop|restart)
    load_profile
	//
	load_profile() {
  if has_default_profile; then
  //
  has_default_profile() {
  if [ -f ~/.che/profiles/.profile ]; then
    return 0
  else 
    return 1
  fi 
}

    source ~/.che/profiles/.profile

    if [ ! -f ~/.che/profiles/"${CHE_PROFILE}" ]; then
      error ""
      error "${CHE_MINI_PRODUCT_NAME} CLI profile set in ~/.che/profiles/.profile to '${CHE_PROFILE}' but ~/.che/profiles/${CHE_PROFILE} does not exist."
      error ""
      return
    fi

    source ~/.che//profiles/"${CHE_PROFILE}"
  fi
}

    execute_che_launcher
	//
	execute_che_launcher() {
  check_current_image_and_update_if_not_found ${CHE_LAUNCHER_IMAGE_NAME}
  //
  check_current_image_and_update_if_not_found() {

  CURRENT_IMAGE=$(docker images -q "$1":"${CHE_VERSION}")

  if [ "${CURRENT_IMAGE}" == "" ]; then
    update_che_image $1
  fi
}
  //
  docker_run_with_che_properties "${CHE_LAUNCHER_IMAGE_NAME}":"${CHE_VERSION}" "${CHE_CLI_ACTION}" || true
  //
  docker_run_with_che_properties() {
  if [ ! -z ${CHE_CONF_FOLDER+x} ]; then

    # Configuration directory set by user - this has precedence.
    docker_run_with_interactive -e "CHE_CONF_FOLDER=${CHE_CONF_FOLDER}" "$@"
	//
	docker_run_with_interactive() {
  if has_interactive; then
  //
  has_interactive() {
  if [ "${IS_INTERACTIVE}" = "true" ]; then
    return 0
  else
    return 1
  fi
}
    docker_run_with_env_file -it "$@"
	//
	docker_run_with_env_file() {
  if has_che_env_variables; then
  //
  has_che_env_variables() {
  PROPERTIES=$(env | grep CHE_)

  if [ "$PROPERTIES" = "" ]; then
    return 1
  else 
    return 0
  fi 
}
    get_list_of_che_system_environment_variables
	//
	get_list_of_che_system_environment_variables() {
  # See: http://stackoverflow.com/questions/4128235/what-is-the-exact-meaning-of-ifs-n
  IFS=$'\n'
  DOCKER_ENV="tmp"

  touch "tmp"
  
  if has_default_profile; then
  //
  has_default_profile() {
  if [ -f ~/.che/profiles/.profile ]; then
    return 0
  else 
    return 1
  fi 
}
    cat ~/.che/profiles/${CHE_PROFILE} >> $DOCKER_ENV
  else
    CHE_VARIABLES=$(env | grep CHE_)

    if [ ! -z ${CHE_VARIABLES+x} ]; then
      env | grep CHE_ >> $DOCKER_ENV
    fi

    # Add in known proxy variables
    if [ ! -z ${http_proxy+x} ]; then
      echo "http_proxy=${http_proxy}" >> $DOCKER_ENV
    fi

    if [ ! -z ${https_proxy+x} ]; then
      echo "https_proxy=${https_proxy}" >> $DOCKER_ENV
    fi

    if [ ! -z ${no_proxy+x} ]; then
      echo "no_proxy=${no_proxy}" >> $DOCKER_ENV
    fi
  fi
}

    docker_run --env-file="tmp" "$@"
	//
	docker_run() {
  docker_exec run --rm -v /var/run/docker.sock:/var/run/docker.sock "$@"
  //
  docker_exec() {
  if is_boot2docker || is_docker_for_windows; then
  //
  is_boot2docker() {
  if echo "$GLOBAL_UNAME" | grep -q "boot2docker"; then
    return 0
  else
    return 1
  fi
}
//
is_docker_for_windows() {
  if is_moby_vm && has_docker_for_windows_client; then
  //
  is_moby_vm() {
  if echo "$GLOBAL_NAME_MAP" | grep -q "moby"; then
    return 0
  else
    return 1
  fi
}
//
has_docker_for_windows_client(){
  if [ "${GLOBAL_HOST_ARCH}" = "windows" ]; then
    return 0
  else
    return 1
  fi
}
    return 0
  else
    return 1
  fi
}



    MSYS_NO_PATHCONV=1 docker.exe "$@"
  else
    "$(which docker)" "$@"
  fi
}
}

    rm -rf "tmp" > /dev/null
  else
    docker_run "$@"
  fi
}
  else
    docker_run_with_env_file -t "$@"
  fi
}

  else 
    if has_che_properties; then
	//
	has_che_properties() {
  PROPERTIES=$(env | grep CHE_PROPERTY_)

  if [ "$PROPERTIES" = "" ]; then
    return 1
  else 
    return 0
  fi 
}
      # No user configuration directory, but CHE_PROPERTY_ values set
      generate_temporary_che_properties_file
	  //
	  generate_temporary_che_properties_file() {
  if has_che_properties; then
    test -d ~/.che/conf || mkdir -p ~/.che/conf
    touch ~/.che/conf/che.properties

    # Get list of properties
    PROPERTIES_ARRAY=($(env | grep CHE_PROPERTY_))
    for PROPERTY in "${PROPERTIES_ARRAY[@]}"
    do
      # CHE_PROPERTY_NAME=value ==> NAME=value
      PROPERTY_WITHOUT_PREFIX=${PROPERTY#CHE_PROPERTY_}

      # NAME=value ==> separate name / value into different variables
      PROPERTY_NAME=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f1 -d=)
      PROPERTY_VALUE=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f2 -d=)
     
      # Replace "_" in names to periods

      # Replace "_" in names to periods
      CONVERTED_PROPERTY_NAME=$(echo "$PROPERTY_NAME" | tr _ .)

      # Replace ".." in names to "_"
      SUPER_CONVERTED_PROPERTY_NAME="${CONVERTED_PROPERTY_NAME//../_}"

      echo "$SUPER_CONVERTED_PROPERTY_NAME=$PROPERTY_VALUE" >> ~/.che/conf/che.properties
    done
  fi
}

      docker_run_with_interactive -e "CHE_CONF_FOLDER=$(get_mount_path ~/.che/conf)" "$@"
	  //
	  docker_run_with_interactive() {
  if has_interactive; then
    docker_run_with_env_file -it "$@"
  else
    docker_run_with_env_file -t "$@"
  fi
}
      rm -rf ~/.che/conf/che.properties > /dev/null
    else
      docker_run_with_interactive "$@"
    fi
  fi
}
}
//
get_mount_path() {
  FULL_PATH=$(get_full_path "${1}")
  //
  get_full_path() {
  # "/some/path" => /some/path
  OUTPUT_PATH=${1//\"}

  # create full directory path
  echo "$(cd "$(dirname "${OUTPUT_PATH}")"; pwd)/$(basename "$1")"
}



  POSIX_PATH=$(convert_windows_to_posix "${FULL_PATH}")
  //
  convert_windows_to_posix() {
  echo "/"$(echo "$1" | sed 's/\\/\//g' | sed 's/://')
}

  CLEAN_PATH=$(get_clean_path "${POSIX_PATH}")
  //get_clean_path() {
  INPUT_PATH=$1
  # \some\path => /some/path
  OUTPUT_PATH=$(echo ${INPUT_PATH} | tr '\\' '/')
  # /somepath/ => /somepath
  OUTPUT_PATH=${OUTPUT_PATH%/}
  # /some//path => /some/path
  OUTPUT_PATH=$(echo ${OUTPUT_PATH} | tr -s '/')
  # "/some/path" => /some/path
  OUTPUT_PATH=${OUTPUT_PATH//\"}
  echo ${OUTPUT_PATH}
}

  echo $CLEAN_PATH
}


  ;;
  profile)
    execute_profile "$@"
	//
	execute_profile(){

  if [ ! $# -ge 2 ]; then 
    error ""
    error "${CHE_MINI_PRODUCT_NAME} profile: Wrong number of arguments."
    error ""
    return
  fi

  case ${2} in
    add|rm|set|info|update)
    if [ ! $# -eq 3 ]; then 
      error ""
      error "${CHE_MINI_PRODUCT_NAME} profile: Wrong number of arguments."
      error ""
      return
    fi
    ;;
    unset|list)
    if [ ! $# -eq 2 ]; then 
      error ""
      error "${CHE_MINI_PRODUCT_NAME} profile: Wrong number of arguments."
      error ""
      return
    fi
    ;;
  esac

  case ${2} in
    add)
      if [ -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} already exists. Nothing to do. Exiting."
        error ""
        return
      fi

      test -d ~/.che/profiles || mkdir -p ~/.che/profiles
      touch ~/.che/profiles/"${3}"

      echo "CHE_PRODUCT_NAME=$CHE_PRODUCT_NAME" > ~/.che/profiles/"${3}"
      echo "CHE_MINI_PRODUCT_NAME=$CHE_MINI_PRODUCT_NAME" > ~/.che/profiles/"${3}"
      echo "CHE_LAUNCHER_IMAGE_NAME=$CHE_LAUNCHER_IMAGE_NAME" > ~/.che/profiles/"${3}"
      echo "CHE_SERVER_IMAGE_NAME=$CHE_SERVER_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_DIR_IMAGE_NAME=$CHE_DIR_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_MOUNT_IMAGE_NAME=$CHE_MOUNT_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_TEST_IMAGE_NAME=$CHE_TEST_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_SERVER_CONTAINER_NAME=$CHE_SERVER_CONTAINER_NAME" >> ~/.che/profiles/"${3}"

      # Add all other variables to the profile
      env | grep CHE_ >> ~/.che/profiles/"${3}" || true

      # Remove duplicates, if any
      cat ~/.che/profiles/"${3}" | sort | uniq > ~/.che/profiles/tmp
      mv -f ~/.che/profiles/tmp ~/.che/profiles/"${3}"


      info ""
      info "Added new ${CHE_MINI_PRODUCT_NAME} CLI profile ~/.che/profiles/${3}."
      info ""
    ;;
    update)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} does not exist. Nothing to update. Exiting."
        error ""
        return
      fi

      execute_profile profile rm "${3}"
      execute_profile profile add "${3}"
    ;;
    rm)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} does not exist. Nothing to do. Exiting."
        error ""
        return
      fi

      rm ~/.che/profiles/"${3}" > /dev/null

      info ""
      info "Removed ${CHE_MINI_PRODUCT_NAME} CLI profile ~/.che/profiles/${3}."
      info ""
    ;;
    info)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} does not exist. Nothing to do. Exiting."
        error ""
        return
      fi
 

      debug "---------------------------------------"
      debug "---------   CLI PROFILE INFO   --------"
      debug "---------------------------------------"
      debug ""
      debug "Profile ~/.che/profiles/${3} contains:"
      while IFS= read line
      do
        # display $line or do somthing with $line
        debug "$line"
      done <~/.che/profiles/"${3}"
    ;;
    set)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/${3} does not exist. Nothing to do. Exiting."
        error ""
        return
      fi
      
      echo "CHE_PROFILE=${3}" > ~/.che/profiles/.profile

      info ""
      info "Set active ${CHE_MINI_PRODUCT_NAME} CLI profile to ~/.che/profiles/${3}."
      info ""
    ;;
    unset)
      if [ ! -f ~/.che/profiles/.profile ]; then
        error ""
        error "Default profile not set. Nothing to do. Exiting."
        error ""
        return
      fi
      
      rm -rf ~/.che/profiles/.profile

      info ""
      info "Unset the default ${CHE_MINI_PRODUCT_NAME} CLI profile. No profile currently set."
      info ""
    ;;
    list)
      if [ -d ~/.che ]; then
        info "Available ${CHE_MINI_PRODUCT_NAME} CLI profiles:"
		//
		info() {
  printf  "${GREEN}INFO:${NC} %s\n" "${1}"
}
        ls ~/.che/profiles
      else
        info "No ${CHE_MINI_PRODUCT_NAME} CLI profiles currently set."
      fi

      if has_default_profile; then
        info "Default profile set to:"
        get_default_profile
      else
        info "Default profile currently unset."
      fi
    ;;
  esac
}

  ;;
  dir)
    # remove "dir" arg by shifting it
    shift
    load_profile
	//
	load_profile() {
  if has_default_profile; then

    source ~/.che/profiles/.profile

    if [ ! -f ~/.che/profiles/"${CHE_PROFILE}" ]; then
      error ""
      error "${CHE_MINI_PRODUCT_NAME} CLI profile set in ~/.che/profiles/.profile to '${CHE_PROFILE}' but ~/.che/profiles/${CHE_PROFILE} does not exist."
      error ""
      return
    fi

    source ~/.che//profiles/"${CHE_PROFILE}"
  fi
}

    execute_che_dir "$@"
	//
	execute_che_dir() {
  check_current_image_and_update_if_not_found ${CHE_DIR_IMAGE_NAME}
  //
  check_current_image_and_update_if_not_found() {

  CURRENT_IMAGE=$(docker images -q "$1":"${CHE_VERSION}")

  if [ "${CURRENT_IMAGE}" == "" ]; then
    update_che_image $1
	//
	update_che_image() {
  if [ -z "${CHE_VERSION}" ]; then
    CHE_VERSION=${DEFAULT_CHE_VERSION}
  fi

  info "${CHE_PRODUCT_NAME}: Pulling image $1:${CHE_VERSION}"
  docker pull $1:${CHE_VERSION}
  echo ""
}

  fi
}

  CURRENT_DIRECTORY=$(get_mount_path "${PWD}")
  //
  get_mount_path() {
  FULL_PATH=$(get_full_path "${1}")

  POSIX_PATH=$(convert_windows_to_posix "${FULL_PATH}")

  CLEAN_PATH=$(get_clean_path "${POSIX_PATH}")
  echo $CLEAN_PATH
}

  docker_run_with_che_properties -v "$CURRENT_DIRECTORY":"$CURRENT_DIRECTORY" "${CHE_DIR_IMAGE_NAME}":"${CHE_VERSION}" "${CURRENT_DIRECTORY}" "$@"
  //
  docker_run_with_che_properties() {
  if [ ! -z ${CHE_CONF_FOLDER+x} ]; then

    # Configuration directory set by user - this has precedence.
    docker_run_with_interactive -e "CHE_CONF_FOLDER=${CHE_CONF_FOLDER}" "$@"
  else 
    if has_che_properties; then
      # No user configuration directory, but CHE_PROPERTY_ values set
      generate_temporary_che_properties_file
	  //
	  generate_temporary_che_properties_file() {
  if has_che_properties; then
    test -d ~/.che/conf || mkdir -p ~/.che/conf
    touch ~/.che/conf/che.properties

    # Get list of properties
    PROPERTIES_ARRAY=($(env | grep CHE_PROPERTY_))
    for PROPERTY in "${PROPERTIES_ARRAY[@]}"
    do
      # CHE_PROPERTY_NAME=value ==> NAME=value
      PROPERTY_WITHOUT_PREFIX=${PROPERTY#CHE_PROPERTY_}

      # NAME=value ==> separate name / value into different variables
      PROPERTY_NAME=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f1 -d=)
      PROPERTY_VALUE=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f2 -d=)
     
      # Replace "_" in names to periods

      # Replace "_" in names to periods
      CONVERTED_PROPERTY_NAME=$(echo "$PROPERTY_NAME" | tr _ .)

      # Replace ".." in names to "_"
      SUPER_CONVERTED_PROPERTY_NAME="${CONVERTED_PROPERTY_NAME//../_}"

      echo "$SUPER_CONVERTED_PROPERTY_NAME=$PROPERTY_VALUE" >> ~/.che/conf/che.properties
    done
  fi
}
	  
      docker_run_with_interactive -e "CHE_CONF_FOLDER=$(get_mount_path ~/.che/conf)" "$@"
      rm -rf ~/.che/conf/che.properties > /dev/null
    else
      docker_run_with_interactive "$@"
    fi
  fi
}

}

  ;;
  action)
    # remove "action" arg by shifting it
    shift
    load_profile
    execute_che_action "$@"
	//
	execute_che_action() {
  check_current_image_and_update_if_not_found ${CHE_ACTION_IMAGE_NAME}
  docker_run_with_che_properties "${CHE_ACTION_IMAGE_NAME}":"${CHE_VERSION}" "$@"
}


  ;;
  update)
    load_profile
    update_che_image ${CHE_LAUNCHER_IMAGE_NAME}
	//
	update_che_image() {
  if [ -z "${CHE_VERSION}" ]; then
    CHE_VERSION=${DEFAULT_CHE_VERSION}
  fi

  info "${CHE_PRODUCT_NAME}: Pulling image $1:${CHE_VERSION}"
  docker pull $1:${CHE_VERSION}
  echo ""
}
    update_che_image ${CHE_MOUNT_IMAGE_NAME}
    update_che_image ${CHE_DIR_IMAGE_NAME}
    update_che_image ${CHE_ACTION_IMAGE_NAME}
    update_che_image ${CHE_TEST_IMAGE_NAME}
    update_che_image ${CHE_DEV_IMAGE_NAME}

    # Delegate updating che-server to the launcher
    execute_che_launcher
	//
	execute_che_launcher() {
  check_current_image_and_update_if_not_found ${CHE_LAUNCHER_IMAGE_NAME}
  docker_run_with_che_properties "${CHE_LAUNCHER_IMAGE_NAME}":"${CHE_VERSION}" "${CHE_CLI_ACTION}" || true
}

  ;;
  mount)
    load_profile
    execute_che_mount "$@"
	//
	execute_che_mount() {
  if [ ! $# -eq 3 ]; then 
    error "${CHE_MINI_PRODUCT_NAME} mount: Wrong number of arguments provided."
    return
  fi

  MOUNT_PATH=$(get_mount_path "${2}")

  if [ ! -e "${MOUNT_PATH}" ]; then
    error "${CHE_MINI_PRODUCT_NAME} mount: Path provided does not exist."
    return
  fi

  if [ ! -d "${MOUNT_PATH}" ]; then
    error "${CHE_MINI_PRODUCT_NAME} mount: Path provided is not a valid directory."
    return
  fi

  docker_run_with_che_properties --cap-add SYS_ADMIN \
              --device /dev/fuse \
              -v "${MOUNT_PATH}":/mnthost \
              "${CHE_MOUNT_IMAGE_NAME}":"${CHE_VERSION}" "${GLOBAL_GET_DOCKER_HOST_IP}" $3
}
  ;;
  compile)
    # remove "compile" arg by shifting it
    shift
    load_profile
    execute_che_compile "$@"
	//
	execute_che_compile() {
  if [ $# -eq 0 ]; then 
    error "${CHE_MINI_PRODUCT_NAME} compile: Missing argument - pass compilation command as paramters."
    return
  fi

  check_current_image_and_update_if_not_found ${CHE_DEV_IMAGE_NAME}
  CURRENT_DIRECTORY=$(get_mount_path "${PWD}")
  docker_run_with_che_properties -v "$CURRENT_DIRECTORY":/home/user/che-build \
                                 -v "$(get_mount_path ~/.m2):/home/user/.m2" \
                                 -w /home/user/che-build \
                                 "${CHE_DEV_IMAGE_NAME}":"${CHE_VERSION}" "$@"
}
  ;;
  test)
    # remove "test" arg by shifting it
    shift
    load_profile
    execute_che_test "$@"
	//
	execute_che_test() {
  check_current_image_and_update_if_not_found ${CHE_TEST_IMAGE_NAME}
  docker_run_with_che_properties "${CHE_TEST_IMAGE_NAME}":"${CHE_VERSION}" "$@"
}

  ;;
  info)
    load_profile
    execute_che_info "$@"
	//
	execute_che_info() {
  if [ $# -eq 1 ]; then
    TESTS="--server"
  else
    TESTS=$2
  fi
  
  case $TESTS in
    --all|-all)
      print_che_cli_debug
	  //
	  print_che_cli_debug() {
  debug "---------------------------------------"
  //
  debug() {
  printf  "${BLUE}DEBUG:${NC} %s\n" "${1}"
}
  debug "---------    CLI DEBUG INFO    --------"
  debug "---------------------------------------"
  debug ""
  debug "---------  PLATFORM INFO  -------------"
  debug "CLI DEFAULT PROFILE       = $(has_default_profile && echo $(get_default_profile) || echo "not set")"
  debug "DOCKER_INSTALL_TYPE       = $(get_docker_install_type)"
  debug "DOCKER_HOST_IP            = ${GLOBAL_GET_DOCKER_HOST_IP}"
  debug "IS_DOCKER_FOR_WINDOWS     = $(is_docker_for_windows && echo "YES" || echo "NO")"
  debug "IS_DOCKER_FOR_MAC         = $(is_docker_for_mac && echo "YES" || echo "NO")"
  debug "IS_BOOT2DOCKER            = $(is_boot2docker && echo "YES" || echo "NO")"
  debug "IS_NATIVE                 = $(is_native && echo "YES" || echo "NO")"
  debug "HAS_DOCKER_FOR_WINDOWS_IP = $(has_docker_for_windows_ip && echo "YES" || echo "NO")"
  debug "IS_MOBY_VM                = $(is_moby_vm && echo "YES" || echo "NO")"
  debug "HAS_CHE_ENV_VARIABLES     = $(has_che_env_variables && echo "YES" || echo "NO")"
  debug "HAS_TEMP_CHE_PROPERTIES   = $(has_che_properties && echo "YES" || echo "NO")"
  debug "HAS_INTERACTIVE           = $(has_interactive && echo "YES" || echo "NO")"
  debug ""
}

      execute_che_launcher
      run_connectivity_tests
	  //
	  run_connectivity_tests() {
  debug ""
  debug "---------------------------------------"
  debug "--------   CONNECTIVITY TEST   --------"
  debug "---------------------------------------"
  # Start a fake workspace agent
  docker_exec run -d -p 12345:80 --name fakeagent alpine httpd -f -p 80 -h /etc/ > /dev/null

  AGENT_INTERNAL_IP=$(docker inspect --format='{{.NetworkSettings.IPAddress}}' fakeagent)
  AGENT_INTERNAL_PORT=80
  AGENT_EXTERNAL_IP=$GLOBAL_GET_DOCKER_HOST_IP
  AGENT_EXTERNAL_PORT=12345


  ### TEST 1: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I $(get_che_hostname):${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (Hostname)   : Connection succeeded"
  else
      debug "Browser             => Workspace Agent (Hostname)   : Connection failed"
  fi

  ### TEST 1a: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Browser             => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 2: Simulate Che server ==> workspace agent (external IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")
  
  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 3: Simulate Che server ==> workspace agent (internal IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (Internal IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (Internal IP): Connection failed"
  fi

  docker rm -f fakeagent > /dev/null
}

      execute_che_test post-flight-check "$@"
    ;;
    --cli|-cli)
      print_che_cli_debug
	  //
	  print_che_cli_debug() {
  debug "---------------------------------------"
  debug "---------    CLI DEBUG INFO    --------"
  debug "---------------------------------------"
  debug ""
  debug "---------  PLATFORM INFO  -------------"
  debug "CLI DEFAULT PROFILE       = $(has_default_profile && echo $(get_default_profile) || echo "not set")"
  debug "DOCKER_INSTALL_TYPE       = $(get_docker_install_type)"
  debug "DOCKER_HOST_IP            = ${GLOBAL_GET_DOCKER_HOST_IP}"
  debug "IS_DOCKER_FOR_WINDOWS     = $(is_docker_for_windows && echo "YES" || echo "NO")"
  debug "IS_DOCKER_FOR_MAC         = $(is_docker_for_mac && echo "YES" || echo "NO")"
  debug "IS_BOOT2DOCKER            = $(is_boot2docker && echo "YES" || echo "NO")"
  debug "IS_NATIVE                 = $(is_native && echo "YES" || echo "NO")"
  debug "HAS_DOCKER_FOR_WINDOWS_IP = $(has_docker_for_windows_ip && echo "YES" || echo "NO")"
  debug "IS_MOBY_VM                = $(is_moby_vm && echo "YES" || echo "NO")"
  debug "HAS_CHE_ENV_VARIABLES     = $(has_che_env_variables && echo "YES" || echo "NO")"
  debug "HAS_TEMP_CHE_PROPERTIES   = $(has_che_properties && echo "YES" || echo "NO")"
  debug "HAS_INTERACTIVE           = $(has_interactive && echo "YES" || echo "NO")"
  debug ""
}

    ;;
    --networking|-networking)
      run_connectivity_tests
	  //
	  run_connectivity_tests() {
  debug ""
  debug "---------------------------------------"
  debug "--------   CONNECTIVITY TEST   --------"
  debug "---------------------------------------"
  # Start a fake workspace agent
  docker_exec run -d -p 12345:80 --name fakeagent alpine httpd -f -p 80 -h /etc/ > /dev/null

  AGENT_INTERNAL_IP=$(docker inspect --format='{{.NetworkSettings.IPAddress}}' fakeagent)
  AGENT_INTERNAL_PORT=80
  AGENT_EXTERNAL_IP=$GLOBAL_GET_DOCKER_HOST_IP
  AGENT_EXTERNAL_PORT=12345


  ### TEST 1: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I $(get_che_hostname):${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (Hostname)   : Connection succeeded"
  else
      debug "Browser             => Workspace Agent (Hostname)   : Connection failed"
  fi

  ### TEST 1a: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Browser             => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 2: Simulate Che server ==> workspace agent (external IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")
  
  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 3: Simulate Che server ==> workspace agent (internal IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (Internal IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (Internal IP): Connection failed"
  fi

  docker rm -f fakeagent > /dev/null
}


    ;;
    --server|-server)
      print_che_cli_debug
      execute_che_launcher
    ;;
    --create|-create)
      execute_che_test "$@"
    ;;
    *)
      debug "Unknown debug flag passed: $2. Exiting."
    ;;
  esac
}
	
  ;;
  help)
    usage
	//
	usage () {
  printf "%s" "${USAGE}"
  //
  
  USAGE="
Usage: ${CHE_MINI_PRODUCT_NAME} [COMMAND]
           start                              Starts ${CHE_MINI_PRODUCT_NAME} server
           stop                               Stops ${CHE_MINI_PRODUCT_NAME} server
           restart                            Restart ${CHE_MINI_PRODUCT_NAME} server
           update                             Pulls specific version, respecting CHE_VERSION
           profile add <name>                 Add a profile to ~/.che/ 
           profile set <name>                 Set this profile as the default for ${CHE_MINI_PRODUCT_NAME} CLI
           profile unset                      Removes the default profile - leaves it unset
           profile rm <name>                  Remove this profile from ~/.che/
           profile update <name>              Update profile in ~/.che/
           profile info <name>                Print the profile configuration
           profile list                       List available profiles
           mount <local-path> <ws-ssh-port>   Synchronize workspace to a local directory
           dir init                           Initialize directory with ${CHE_MINI_PRODUCT_NAME} configuration
           dir up                             Create workspace from source in current directory
           dir down                           Stop workspace running in current directory
           dir status                         Display status of ${CHE_MINI_PRODUCT_NAME} in current directory
           action <action-name> [--help]      Start action on ${CHE_MINI_PRODUCT_NAME} instance
           compile <mvn-command>              SDK - Builds Che source code or modules
           test <test-name> [--help]          Start test on ${CHE_MINI_PRODUCT_NAME} instance
           info [ --all                       Run all debugging tests
                  --server                    Run ${CHE_MINI_PRODUCT_NAME} launcher and server debugging tests
                  --networking                Test connectivity between ${CHE_MINI_PRODUCT_NAME} sub-systems
                  --cli                       Print CLI (this program) debugging info
                  --create [<url>]            Test creating a workspace and project in ${CHE_MINI_PRODUCT_NAME}
                           [<user>] 
                           [<pass>] ]
"
}
}
  ;;
esac



=======================
endof che-4.7.0.sh


getfrom README.md_4.7.0
====================
# Eclipse Che - Eclipse Next-Generation IDE
[![Join the chat at https://gitter.im/eclipse/che](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/eclipse/che?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
[![Eclipse License](http://img.shields.io/badge/license-Eclipse-brightgreen.svg)](https://github.com/codenvy/che/blob/master/LICENSE)
[![Build Status](https://ci.codenvycorp.com/buildStatus/icon?job=che-ci-master)](https://ci.codenvycorp.com/job/che-ci-master)

https://www.eclipse.org/che/. Next-generation Eclipse platform, developer workspace server and cloud IDE. Che defines workspaces that include their dependencies including embedded containerized runtimes, Web IDE, and project code. This makes workspaces distributed, collaborative, and portable to run anywhere on a desktop or a server ... [Read More](https://www.eclipse.org/che/features/)

![Eclipse Che](https://www.eclipse.org/che/images/banner@2x.png "Eclipse Che")

### Getting Started
You can run Che in the public cloud, a private cloud, or install it on any OS. Che has been tested on Ubuntu, Linux, MacOS and Windows. The [step by step guide](http://eclipse.org/che/getting-started/) will get you going.

The `che` repository is where we do development and there are many ways you can participate, for example:

- [Submit bugs and feature requests](http://github.com/eclipse/che/issues) and help us verify them
- Review [source code changes](http://github.com/eclipse/che/pulls)
- [Review the docs](https://eclipse-che.readme.io/docs/) and make improvements for anything from typos to new content

### Customizing
There are many ways to customize Che out-of-the-box including [stacks, templates, commands, IDE extensions, server-side extensions plugins, assemblies, RESTful APIs, and editors](https://github.com/eclipse/che/blob/master/CUSTOMIZING.md). 

### Contributing
If you are interested in fixing issues and contributing directly to the code base, please see [How to Contribute](https://github.com/eclipse/che/wiki/How-To-Contribute). It covers:
- [Submitting bugs](https://github.com/eclipse/che/wiki/Submitting-Bugs-and-Suggestions)
- [Development workflow](https://github.com/eclipse/che/wiki/Development-Workflow)
- [Coding guidelines](https://github.com/eclipse/che/wiki/Coding-Guidelines)
- [Contributor license agreement](https://github.com/eclipse/che/wiki/Contributor-License-Agreement)

### Feedback
* **Support:** You can ask questions, report bugs, and request features using [GitHub issues](http://github.com/eclipse/che/issues).
* **Roadmap:** We maintain [the roadmap](https://github.com/eclipse/che/wiki/Roadmap) on the wiki. 
* **Weekly Meetings:** Join us on [a hangout](https://github.com/eclipse/che/wiki/Weekly-Planning-Meetings). 

### License
Che is open sourced under the Eclipse Public License 1.0.

=====================
endof README.md_4.7.0



getfrom CUSTOMIZING.md_4.7.0
==============
Eclipse Che is a platform for creating distributed developer tooling. There are numerous ways to extend, modify, and customize Eclipse Che. This document itemizes all of the resources available for customizing Che. We have documentation pages, tutorials, and specifications.

#### Stacks
A stack is the configuration of a runtime that can be used to power a workspace. Users choose the stack that powers a workspace within the user dashboard. Stacks have a recipe that defines how the container should be created and also meta data that defines the tags associated with the stack. 
* [Add Your Stacks to Che](https://eclipse-che.readme.io/docs/stacks#custom-stacks-for-che)
* [Stack Data Model](https://eclipse-che.readme.io/docs/stack)
* [Che Included Stacks](https://eclipse-che.readme.io/docs/stacks#section-ready-to-go-stacks)
* [Add Your Stack to Default Che Assembly](https://eclipse-che.readme.io/v4.0/docs/stacks#adding-stacks-to-the-che-default-assembly)
* * TODO: Update this link to point to wiki page that can be updated by community

#### Recipes
A recipe defines the runtime of a workspace environment.  Workspaces can have multiple environments, each with their own runtime.  Che supports different kinds of runtimes, but the default is Docker letting us make use of [Dockerfiles](https://docs.docker.com/engine/reference/builder/) as recipes. 
* [Recipes](https://eclipse-che.readme.io/docs/recipes)
* [Writing Custom Recipes](https://eclipse-che.readme.io/v4.3/docs/recipes#section-authoring-custom-recipes)
* [Che Included Recipes](https://github.com/codenvy/dockerfiles)

#### Templates
A template is a packaged set of sample code that is launched in the workspace when a user creates a new project. Users can select from a template while using the user dashboard. Templates have both sample code and a default set of commands associated with them. Templates are loaded based upon the type of stack selected. You can add your own templates to the default Che distribution.
* [Templates](https://eclipse-che.readme.io/docs/templates)
* [Add Templates](https://eclipse-che.readme.io/docs/templates#register-new-project-templates)
* [Template Data Model](https://eclipse-che.readme.io/docs/template)
* [Add Your Template to Default Che Assembly](https://eclipse-che.readme.io/docs/templates#section-add-your-template-to-default-che-assembly)

#### Commands
A command is a process that is injected into your workspace. It's outputs are streamed into the console. Commands have type and you can create, save, update and delete commands from within the IDE. You can create templates that have sample projects with default commands that are pre-populated in the IDE. Commands can reference macros that intelligently navigate the project tree or current selections.
* [Commands](https://eclipse-che.readme.io/docs/commands)
* [Macros](https://eclipse-che.readme.io/docs/commands#macros)
* [Command Data Model](https://eclipse-che.readme.io/docs/command)

#### Extension Development
An extension is a set of code and resources that are packaged into a plugin that alter the behavior of the system. Extensions can be IDE extensions, workspace extensions (they are injected into the workspace agent running within each workspace), or Che extensions (injected into the Che server). Extensions are authored in Java and maven, and then packaged into JAR / ZIP files for deployment into Eclipse Che.
* [Extension Intro](https://dash.readme.io/project/eclipse-che/docs/introduction-1)
* [Developing Extensions](https://eclipse-che.readme.io/docs/create-and-build-extensions)
* [JSON Extension Tutorial](https://eclipse-che.readme.io/docs/introduction-1#section-the-json-example)
* [Authoring Extensions in Che](https://eclipse-che.readme.io/docs/setup-che-workspace#author-extension-using-the-che-ide)
* [Authoring Extensions in Eclipse](https://eclipse-che.readme.io/docs/setup-che-workspace#author-extension-using-the-eclipse-ide)
* [Authoring Extensions in IntelliJ](https://eclipse-che.readme.io/docs/setup-che-workspace#author-extensions-using-intellij-ide)
* [Dependency Injection](https://eclipse-che.readme.io/docs/dependency-injection-basics)
* [Extensions Packaged With Che](https://github.com/eclipse/che/tree/master/plugins)
* [Extension SDK JavaDoc](https://eclipse-che.readme.io/docs/java-class-reference)

#### IDE Extensions
IDE extensions are compiled into JavaScript with other extensions to create a single, JavaScript application. You can package many extensions together into a single JavaScript application. The JavaScript application is cross-browser optimized. You can debug extensions and perform execution traces from within the browser of extension code. IDE extensions can invoke REST services that are running within the Che server or within a workspace. Che provides default workspace REST APIs or you can provide your own with workspace extensions.
* [Invoking Workspace REST APIs](https://eclipse-che.readme.io/docs/calling-workspace-apis)
* [Editors](https://eclipse-che.readme.io/docs/code-editors)
* [Project Type](https://eclipse-che.readme.io/docs/project-types)
* [Actions](https://eclipse-che.readme.io/docs/actions)
* [Services](https://eclipse-che.readme.io/docs/serverworkspace-access)
* [Parts](https://eclipse-che.readme.io/docs/parts)
* [Commands](https://github.com/benoitf/ide-plugin-demo)
* [Events](https://eclipse-che.readme.io/docs/events)
* * TODO: Panels 
* * TODO: Popups
* * TODO: Wizards

#### Server-Side Extensions
Server-side extensions are libraries that are deployed into the workspace agent when the workspace is activated. Che deploys some standard server-side extensions that expose the Workspace REST API to the outside world. You can author extensions that modify or extend this API with your own services. New workspace APIs are exposed as JAX-RS services and you use dependency injection to define the API interfaces.
* * TODO: JAX-RS Conventions
* * TODO: Adding Custom Services into Workspace Agent

#### Workspace REST API
IDE extensions have access to a default set of workspace APIs that are deployed within each workspace. These APIs are available through a Swagger configuration. 
* [Swagger](https://eclipse-che.readme.io/docs/rest-api)
* [Authentication](https://eclipse-che.readme.io/docs/authentication)
* [Workspaces](https://eclipse-che.readme.io/docs/create-workspaces-and-projects)
* [Projects](https://eclipse-che.readme.io/docs/api-projects)
* [Project Types](https://eclipse-che.readme.io/docs/custom-project-types)
* [File Access](https://eclipse-che.readme.io/docs/edit-build-and-run)
* [Events](https://eclipse-che.readme.io/docs/events)

#### Plug-Ins and Assemblies
A plugin is a set of extensions (both IDE and workspace extensions) along with their collective reosurces that are packaged into a single deployable unit, usually as a JAR or ZIP file. An assembly is a set of plug-ins combined with the Eclipse Che core that is assembled into a re-distributable set of binaries. A new assembly can fundamentally alter the Che branding. Che can create assemblies packaged as a desktop IDE or as a new Che server.
* [Plugin Development](https://eclipse-che.readme.io/docs/plug-ins)
* [Drag and Drop](https://eclipse-che.readme.io/docs/developing-plugins) - Not yet updated for 4.x
* [Assemblies](https://eclipse-che.readme.io/docs/assemblies)

==============
endof CUSTOMIZING.md_4.7.0



getfrom Dockerfile_4.7.0
=====================
# Copyright (c) 2012-2016 Codenvy, S.A., Red Hat, Inc
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#   Mario Loriedo
#   Codenvy S.A
#
# To build it, run in the repository root:
#  `docker build -t codenvy/che-server .`
#
# To run it:
#  docker run --net=host \
#             --name che \
#             -v /var/run/docker.sock:/var/run/docker.sock \
#             -v /home/user/che/lib:/home/user/che/lib-copy \
#             -v /home/user/che/workspaces:/home/user/che/workspaces \
#             -v /home/user/che/storage:/home/user/che/storage \
#             codenvy/che-server
#           
FROM alpine:3.4

ENV LANG=C.UTF-8 \
    JAVA_HOME=/usr/lib/jvm/default-jvm/jre \
    PATH=${PATH}:${JAVA_HOME}/bin \
    CHE_HOME=/home/user/che \
    DOCKER_VERSION=1.6.0 \
    DOCKER_BUCKET=get.docker.com

RUN echo "http://dl-4.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories && \
    apk upgrade --update && \
    apk add --update ca-certificates curl openssl openjdk8 sudo bash && \
    curl -sSL "https://${DOCKER_BUCKET}/builds/Linux/x86_64/docker-${DOCKER_VERSION}" -o /usr/bin/docker && \
    chmod +x /usr/bin/docker && \
    addgroup -S user -g 1000 && \
    adduser -S user -h /home/user -s /bin/bash -G root -u 1000 -D && \
    addgroup -S docker -g 101 && \
    adduser user docker && \
    adduser user user && \
    adduser user users && \
    addgroup -g 50 -S docker4mac && \
    adduser user docker4mac && \
    echo "%root ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers && \
    rm -rf /tmp/* /var/cache/apk/*

EXPOSE 8000 8080

USER user

ADD assembly/assembly-main/target/eclipse-che-*/eclipse-che-* /home/user/che/

ENV CHE_HOME /home/user/che

ENTRYPOINT [ "/home/user/che/bin/che.sh", "-c" ]

CMD [ "run" ]
==================
endof Dockerfile_4.7.0




getfrom NUMBERING.md_4.7.0
================
### Schema
```
a.b.c-d
  a = major
  b = feature
  c = bug fix
  d = development, numbered as `<rc>d`
```

### Release
```
a.b.0 - initial
a.b.c - bug fixing
```

## EXAMPLE
### Before Stable Release
```
4.0.0-rc1-SNAPSHOT - This is a build
4.0.0-rc1          - This is a release  
4.0.0-rc2-SNAPSHOT - This is a build
4.0.0-rc2          - This is a release
```

### Ship
```
4.0.0 
```

### Branch For Fixes
```
4.0.x
```

### Version For Fixes On Ship Release
```
4.0.1
4.0.2
```


=============
endof NUMBERING.md_4.7.0




getfrom Vagrantfile_4.7.0
====================
# Copyright (c) 2012-2016 Codenvy, S.A.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#   Codenvy, S.A. - initial API and implementation

# Set to "<proto>://<user>:<pass>@<host>:<port>"
$http_proxy    = ENV['HTTP_PROXY'] || ""
$https_proxy   = ENV['HTTPS_PROXY'] || ""
$no_proxy      = ENV['NO_PROXY'] || "localhost,127.0.0.1"
$che_version   = ENV['CHE_VERSION'] || "nightly"
$ip            = ENV['CHE_IP'] || "192.168.28.100"
$hostPort      = (ENV['CHE_PORT'] || 8080).to_i
$containerPort = (ENV['CHE_CONTAINER_PORT'] || ($hostPort == -1 ? 8080 : $hostPort)).to_i
$user_data     = ENV['CHE_DATA'] || "."
$vm_name       = ENV['CHE_VM_NAME'] || "eclipse-che-vm"
$provisionProgress = ENV['PROVISION_PROGRESS'] || "basic"

Vagrant.configure(2) do |config|
  puts ("ECLIPSE CHE: VAGRANT INSTALLER")
  puts ("ECLIPSE CHE: REQUIRED: VIRTUALBOX 5.x")
  puts ("ECLIPSE CHE: REQUIRED: VAGRANT 1.8.x")
  puts ("")
  if ($http_proxy.to_s != '' || $https_proxy.to_s != '') && !Vagrant.has_plugin?("vagrant-proxyconf")
    puts ("You configured a proxy, but Vagrant's proxy plugin not detected.")
    puts ("Install the plugin with: vagrant plugin install vagrant-proxyconf")
    Process.kill 9, Process.pid
  end

  if Vagrant.has_plugin?("vagrant-proxyconf")
    config.proxy.http = $http_proxy
    config.proxy.https = $https_proxy
    config.proxy.no_proxy = $no_proxy
  end

  config.vm.box = "boxcutter/centos72-docker"
  config.vm.box_download_insecure = true
  config.ssh.insert_key = false
  if $ip.to_s.downcase == "dhcp"
    config.vm.network :private_network, type: "dhcp"
  else
    config.vm.network :private_network, ip: $ip
  end
  if $hostPort != -1
    config.vm.network "forwarded_port", guest: $containerPort, host: $hostPort
  end
  config.vm.synced_folder $user_data, "/home/user/che"
  config.vm.define "che" do |che|
  end

  config.vm.provider "virtualbox" do |vb|
    vb.memory = "4096"
    vb.name = $vm_name
  end

  $script = <<-'SHELL'
    HTTP_PROXY=$1
    HTTPS_PROXY=$2
    NO_PROXY=$3
    CHE_VERSION=$4
    IP=$5
    PORT=$6
    PROVISION_PROGRESS=$7

    if [ "${IP,,}" = "dhcp" ]; then
       echo "----------------------------------------"
       echo "ECLIPSE CHE: CHECKING DYNAMIC IP ADDRESS"
       echo "----------------------------------------"
       DEV=$(grep -l "VAGRANT-BEGIN" /etc/sysconfig/network-scripts/ifcfg-*|xargs grep "DEVICE="|sort|tail -1|cut -d "=" -f 2)
       if [ -z "${DEV}" ]; then
          >&2 echo "Unable to find DHCP network device"
          exit 1
       fi
       IP=$(ip addr show dev ${DEV} | sed -r -e '/inet [0-9]/!d;s/^[[:space:]]*inet ([^[:space:]/]+).*$/\1/')
       if [ -z "${IP}" ]; then
          >&2 echo "Unable to find DHCP network ip"
          exit 1
       fi
       echo "IP: ${IP}"
       echo
    fi

    if [ -n "$HTTP_PROXY" ] || [ -n "$HTTPS_PROXY" ]; then
      echo "-------------------------------------"
      echo "."
      echo "ECLIPSE CHE: CONFIGURING SYSTEM PROXY"
      echo "."
      echo "-------------------------------------"
      echo 'export HTTP_PROXY="'$HTTP_PROXY'"' >> /home/vagrant/.bashrc
      echo 'export HTTPS_PROXY="'$HTTPS_PROXY'"' >> /home/vagrant/.bashrc
      source /home/vagrant/.bashrc

      # Configuring the Che properties file - mounted into Che container when it starts
      echo 'http.proxy="'$HTTP_PROXY'"' >> /home/user/che/conf/che.properties
      echo 'https.proxy="'$HTTPS_PROXY'"' >> /home/user/che/conf/che.properties

      echo "HTTP PROXY set to: $HTTP_PROXY"
      echo "HTTPS PROXY set to: $HTTPS_PROXY"
    fi

    function perform
    {
      local progress=$1
      local command=$2
      shift 2

      local pid=""

      case "$progress" in
        extended)
          # simulate tty environment to get full output of progress bars and percentages
          printf "set timeout -1\nspawn %s\nexpect eof" "$command $*" | expect -f -
          ;;
        basic|*)
          $command "$@" &>/dev/null &
          pid=$!
          while kill -0 "$pid" >/dev/null 2>&1; do
            printf "#"
            sleep 10
          done
          wait $pid # return pid's exit code
          ;;
      esac
    }

    echo "------------------------------------"
    echo "ECLIPSE CHE: UPGRADING DOCKER ENGINE"
    echo "------------------------------------"
    if [ "$PROVISION_PROGRESS" = "extended" ]; then
       # we sacrifice a few seconds of additional install time for much better progress afterwards
       perform basic yum -y install expect
    fi
    perform $PROVISION_PROGRESS sudo yum -y update docker-engine

    echo $(docker --version)

    # Add the 'vagrant' user to the 'docker' group
    usermod -aG docker vagrant &>/dev/null

    # We need write access to this file to enable Che container to create other containers
    sudo chmod 777 /var/run/docker.sock &>/dev/null

    # Setup the overlay storage driver to eliminate errors
    #sudo sed -i '/ExecStart=\/usr\/bin\/dockerd/c\ExecStart=\/usr\/bin\/dockerd --storage-driver=overlay' /lib/systemd/system/docker.service

    # Configure Docker daemon with the proxy
    if [ -n "$HTTP_PROXY" ] || [ -n "$HTTPS_PROXY" ]; then
        mkdir /etc/systemd/system/docker.service.d
    fi
    if [ -n "$HTTP_PROXY" ]; then
        printf "[Service]\nEnvironment=\"HTTP_PROXY=${HTTP_PROXY}\"" > /etc/systemd/system/docker.service.d/http-proxy.conf
        printf ""
    fi
    if [ -n "$HTTPS_PROXY" ]; then
        printf "[Service]\nEnvironment=\"HTTPS_PROXY=${HTTPS_PROXY}\"" > /etc/systemd/system/docker.service.d/https-proxy.conf
    fi
    if [ -n "$HTTP_PROXY" ] || [ -n "$HTTPS_PROXY" ]; then
        printf "[Service]\nEnvironment=\"NO_PROXY=${NO_PROXY}\"" > /etc/systemd/system/docker.service.d/no-proxy.conf
    fi

    systemctl daemon-reload
    systemctl restart docker

    echo "--------------------------------------------------"
    echo "ECLIPSE CHE: DOWNLOADING ECLIPSE CHE DOCKER IMAGES"
    echo "--------------------------------------------------"
#    perform $PROVISION_PROGRESS docker pull codenvy/che-launcher:${CHE_VERSION}
#    perform $PROVISION_PROGRESS docker pull codenvy/che-server:${CHE_VERSION}
    docker pull alpine:latest
    docker pull codenvy/che-launcher:${CHE_VERSION}
    docker pull codenvy/che-server:${CHE_VERSION}

    curl -sL https://raw.githubusercontent.com/eclipse/che/master/che.sh | tr -d '\15\32' > /home/vagrant/che.sh
    chmod +x /home/vagrant/che.sh
    
    echo "export CHE_PORT=${PORT}" >> /etc/profile.d/vars.sh
    echo "export CHE_VERSION=${CHE_VERSION}" >> /etc/profile.d/vars.sh
    echo "export CHE_HOST_IP=172.17.0.1" >> /etc/profile.d/vars.sh
    echo "export CHE_HOSTNAME=${IP}" >> /etc/profile.d/vars.sh

  SHELL

  config.vm.provision "shell" do |s|
    s.inline = $script
    s.args = [$http_proxy, $https_proxy, $no_proxy, $che_version, $ip, $containerPort, $provisionProgress]
  end

  $script2 = <<-'SHELL'
    IP=$1
    PORT=$2
    MAPPED_PORT=$3

    echo "--------------------------------"
    echo "ECLIPSE CHE: BOOTING ECLIPSE CHE"
    echo "--------------------------------"

    docker run --rm -t -v /var/run/docker.sock:/var/run/docker.sock \
               -e "CHE_PORT=${CHE_PORT}" \
               -e "CHE_RESTART_POLICY=always" \
               -e "CHE_HOST_IP=${CHE_HOST_IP}" \
               -e "CHE_HOSTNAME=${CHE_HOSTNAME}" \
               codenvy/che-launcher:${CHE_VERSION} start


    if [ "${IP,,}" = "dhcp" ]; then
       DEV=$(grep -l "VAGRANT-BEGIN" /etc/sysconfig/network-scripts/ifcfg-*|xargs grep "DEVICE="|sort|tail -1|cut -d "=" -f 2)
       IP=$(ip addr show dev ${DEV} | sed -r -e '/inet [0-9]/!d;s/^[[:space:]]*inet ([^[:space:]/]+).*$/\1/')
    fi

    rm -f /home/user/che/.che_url
    rm -f /home/user/che/.che_host_port
    CHE_URL="http://${IP}:${PORT}"

    echo "${CHE_URL}" > /home/user/che/.che_url
    echo "${MAPPED_PORT}" > /home/user/che/.che_host_port
    echo ""
    echo "ECLIPSE CHE READY AT: ${CHE_URL}"

  SHELL

  config.vm.provision "shell", run: "always" do |s|
    s.inline = $script2
    s.args = [$ip, $containerPort, $hostPort]
  end

end

=====================
endof Vagrantfile_4.7.0



getfrom CODE_OF_CONDUCT.md_4.7.0
====================
# Contributor Code of Conduct

As contributors and maintainers of this project, and in the interest of
fostering an open and welcoming community, we pledge to respect all people who
contribute through reporting issues, posting feature requests, updating
documentation, submitting pull requests or patches, and other activities.

We are committed to making participation in this project a harassment-free
experience for everyone, regardless of level of experience, gender, gender
identity and expression, sexual orientation, disability, personal appearance,
body size, race, ethnicity, age, religion, or nationality.

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery
* Personal attacks
* Trolling or insulting/derogatory comments
* Public or private harassment
* Publishing other's private information, such as physical or electronic
  addresses, without explicit permission
* Other unethical or unprofessional conduct

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

By adopting this Code of Conduct, project maintainers commit themselves to
fairly and consistently applying these principles to every aspect of managing
this project. Project maintainers who do not follow or enforce the Code of
Conduct may be permanently removed from the project team.

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community.

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting a project maintainer at info@codenvy.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. Maintainers are
obligated to maintain confidentiality with regard to the reporter of an
incident.


This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 1.3.0, available at
[http://contributor-covenant.org/version/1/3/0/][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/3/0/
=====================
endof CODE_OF_CONDUCT.md_4.7.0


getfrom CONTRIBUTING.md_4.7.0
================
Contributing to Eclipse Che
=====================

Before Submitting an Issue
--------------------------
Check that [our issue database](https://github.com/eclipse/che/issues)
doesn't already include that problem or suggestion before submitting an issue.
If you find a match, you can use the "subscribe" button to get notified on
updates. Do *not* leave random "+1" or "I have this too" comments, as they
only clutter the discussion, and don't help resolving it. However, if you
have ways to reproduce the issue or have additional information that may help
resolving the issue, please leave a comment.

Writing Good Bug Reports and Feature Requests
---------------------------------------------
Please file a single issue per problem and feature request. Do not file combo issues.

The more information you can provide, the more likley someone will be successful reproducing the issue and finding a fix. Therefore:
* Provide reproducibule steps, what the result of the steps was, and what you would have expected.
* A detailed description of the behavior that you expect.
* Animated GIFs are a tremendous help.
* Version information of Eclipse Che and Docker.
* Error outputs that may exist in your browser console.

Contributing Improvements
-------------------------
If you are interested in fixing issues and contributing directly to the code base, please the document [How to Contribute](https://github.com/eclipse/che/wiki/How-To-Contribute).
===================
endof CONTRIBUTING.md_4.7.0



getfrom AUTHORING EXTENSIONS
================
\\Introduction
Introduction
This part of the documentation describes how to extend Eclipse Che with custom plugins, e.g. to provide support for new languages. It covers various aspects from adding new file types, extending the code editor, adding intellisense features, defining a specific project-type, and accessing the workspace. Before you start to extend Che, we recommend to get a general technical overview as provided here.

In general, Che can be extended in its three different components, the IDE running in the Browser, the Che Server, and the Workspace (see diagram below).

First, the IDE running in the Browser can be extended by new local features, such as simple actions, new editors, and views, or immediate syntax highlighting. Some of these extensions can run completely local, some will use the Che server API.

Second, the Che Server can be extended by new plugins. Those extensions will also affect the IDE, e.g. defining a new project type in a plugin, which is done on the server, will create a menu entry in the “New” dialog of the IDE. Server plugins might provide new APIs to be consumed by IDE plugins, e.g. to provide new IntelliSense features. Finally, server plugins can also access the current workspace, e.g. to access files, projects or even the current target machine. Again, there is existing API provided by the workspace agent to be used.

Third, the Workspace can also be extended to provide new API to be consumed by the Che server.


Therefore, typical extensions of Che are deployed to up to three different components, depending on the use case. However, as many extensions include plugin parts for the IDE, the server and even the Workspace, the extension documentation is not organized by Che components, but by extension use cases (e.g. adding a new file type or implementing a client server communication accessing the workspace).

Technically, client and server extensions are different components, however, as they conceptually belong together, they are organized in one plugin containing several sub-components.

This tutorial starts with an introduction on the following prerequisites to build a custom extensions. If you want to follow the tutorial hands-on, you should read those sections, if you are just interested in learning about a specific extension use case, you might skip them for now.

How to set-up a workspace for developing a Che extension.
How to create and build extensions including a description of the general plugin structure used in Che
A brief introduction on dependency injection and its usage in Che, on the client and on the server side. (If you are already familiar with Guice and Gin, you might want to skip this part)
The remaining tutorial is structured along extension use cases. For every extension capability, we provide a general introduction containing code examples.

The tutorial often refers to a continuous example: The implementation of simple JSON support in Eclipse Che. If you are interested in learning about a certain extension use case, please directly navigate to the respective part of the tutorial. If you are interested in getting an overview about the most important extension features, please have a look at the introduction of the JSON example in the following section. It provides a use case oriented overview of the contents of this tutorial and contains links to the detailed parts.

THE JSON EXAMPLE
In this section, we give a functional overview of the continuous example that we use in most parts of this tutorial, the “JSON Example”. It provides simple support for creating, modifying and validating JSON files within Eclipse Che. Please note that the JSON example is not designed to provide perfect JSON support in Che. In fact, it is designed to cover most aspects of providing support for a custom language in Eclipse Che while remaining as simple as possible. This section shall provide an overview about the example and at the same time about Che’s various extension use cases.

The source code for the JSON example is part of the Eclipse Che project itself, you can find it here:
https://github.com/eclipse/che/tree/master/samples/sample-plugin-json

The example includes the following parts, which can be found in the respective parts of this tutorial.

File Type and Code Editor
The example provides a custom file type for JSON including a custom icon. For this file type it includes a custom code editor for JSON files. The code editor provides syntax highlighting for JSON files.


Additionally, the example implements code completion based on a list of suggestions. There are two sources for the list of suggestions, the first and simple one is directly calculated on the client, it can therefore only operate on information available in the context (e.g. the current file opened). The second one is calculated on the server and can therefore access the complete workspace to calculate the suggestions.


Project Type
There is a custom project type for working with JSON files. The example provides a custom project creation wizard which allows to enter project specific data. In case of the JSON example, it allows to specify a URL pointing to a JSON schema, which is later used to validate the JSON files within the project. The project wizard is available in the standard “Create New Project” dialog of Che:


The JSON example wizard will initialize a new project with two existing JSON files and a directory to contain custom ones:


Actions
The JSON example register two project-specific actions for the custom project type. The first one implements a simple “Hello World”. The second one calls a custom service on the server which will access the workspace and count the number of lines of all JSON files within the project. It thereby also includes a template for client/server communication and for accessing source files (e.g. for validation or compilation).


\\\\\\\\\\\\\\\\\IDE Setup
IDE Setup
This page explains how to setup a developer workspace for Che using various IDEs. This includes checking out the sources. If you want to build an extension for Che, you should also follow these instructions.

Setting up your environment consist of three steps, (1) Getting the source code, (2), setting up your IDE for development, (3) and configuring the maven build.


Che is IDE agnostic. We provide configuration instructions for:

Eclipse (using the Eclipse Installer)
IntelliJ
Che IDE (coming soon)
After setting up a workspace, you find documentation about how to setup your build and run environment for Che in the following guide: Developing Extensions.

Pre-requisites
Dependencies

Docker 1.8+
Maven 3.3.1+
Oracle or OpenJDK Java 1.8
The M2_HOME and M2 variables should be set correctly.

To build the user dashboard submodule, you will need npm, bower, gulp, and python.

Python v2.7.x (v3.x.x is currently not supported)
Node.js v4.x.x (v5.x.x / v6.x.x are currently not supported)
npm
Bower
gulp
Installation instructions for Node.js and npm can be found on the following link. Bower and gulp are CLI utilities which are installed via npm:

Shell
$ npm install --global bower gulp
Developers on Windows
To build the Che core, you will need the maven-patch-plugin. Windows does not support this plugin, and we give instructions on how to skip this plugin when building. You can also optionally modify your build to download the patch tool and then add the patch tool to your PATH.

If you are a developer on Windows you'll not be able to do a complete build of Che by doing a mvn clean install. There are certain modules that require additional libraries and are OS specific. (dashboard and svn plugin)

In this situation, we recommend to build Che sources using the "che-dev" Docker image. This image has the dependencies necessary to build Che. You'll mount Che source code from your host to the container and then compile the code within the container.

Shell
# For Windows, replace $HOME with maven repo directory.
# For Windows, replace $PWD with Che source code directory.

docker run -it --rm --name build-che 
           -v "$HOME/.m2:/home/user/.m2" 
           -v "$PWD":/home/user/che-build 
           -w /home/user/che-build 
           eclipse/che-dev 
           mvn -DskipTests=true 
               -Dfindbugs.skip=true
               -Dgwt.compiler.localWorkers=2 -T 1C 
               -Dskip-validate-sources 
               -Dmdep.analyze.skip=true 
               -Dlicense.skip=true
               clean install

# For Mac + Linux - replace $PWD with the root path to build:
Alternatively you can also skip building certain submodules:

Shell
# Each submodule may require additional software to build properly.
# You can skip a submodule to avoid installing additional software.
# For example, to skip building the dashboard:
mvn -pl '!dashboard' clean install
Eclipse IDE - Yatta Installer
The Yatta Installer for Eclipse Che installs Eclipse, the necessary plugins, checkout the Che source code, and configure a Che workspace. There is a lot going on, so this installation can take a few minutes.

 The Yatta Installer Requires JavaFX

In case you use OpenJDK, you will need to install openjfx first.



OPTIONAL
You can consider to deactivate automatic builds in eclipse as this will run maven in places you may not want it to. Rebuilding some Che modules is not necessary unless you modify the code in that module. Otherwise, maven will grab the latest versioned module from Nexus.

If you plan to update files outside the workbench, then you can add a native update hook refresh.

Eclipse IDE - Neon Installer
If you install Eclipse manually, you will need to use the Eclipse Installer. Please get the Eclipse IDE for Java configured with the maven plugin.

Download Eclipse Neon from https://www.eclipse.org/downloads/eclipse-packages/ and select Eclipse IDE for Java EE Developers

Clone Eclipse Che sources on your local computer (repository URL: https://github.com/eclipse/che)

Once Eclipse installed, do Import > Maven > Existing Maven Projects


You will then be asked to select the existing projects to imported. Select them all.

The projects will be imported and you will see them in the explorer.

While the workspace will be built for the first time, you'll be asked to install the missing Eclipse plugins corresponding to the maven goals:




Define the Maven command to build Che. Create a new "Run Configuration"

Double click on "Maven Build"

Choose "che-parent" or "assembly-main" to be the base directory:


Add the following goal clean install

Check the checkmark for skipping tests:


Build the workspace by executing the command you defined:

This will create an assembly in {workspace-path}\che\assembly\assembly-main\target\eclipse-che-<version>\eclipse-che-<version>

 Tips

You might have Eclipse not discovering properly your environment variables. In this case, configure your environment variables with the custom command.
It happens sometimes, that 'npm' is not having the right permissions to complete the build. In this case, remove your npm repository (.npm folder)
Fixing the error marks
There are certains Maven goals that are not completed by Eclipse at once.
The idea is to require Eclipse to rebuild the workspace and update the project's dependencies. You can do that by doing right click on the projects (probably all the first time you are setupping the workspace).


To start Che from the custom assembly you just built, you can refer to this Usage: Docker Launcher. Remind your custom assembly is located in {workspace-path}\che\assembly\assembly-main\target\eclipse-che-<version>\eclipse-che-<version>
GWT Super Dev Mode for Eclipse
GWT Super Dev Mode allows you to perform incremental compilations of Che's Java IDE into JavaScript. This makes redeploys nearly instant and allows for a natural style of IDE development.

You do not need GWT Super Dev Mode if you are building Che server-side or workspace extensions. This is only needed for customizations to the Java IDE which is transpiled into JavaScript.

INSTALL GOOGLE PLUGIN FOR ECLIPSE
This is a general purpose plugin that orchestrates integrating and configuring other Google software within Eclipse. The plugin is downloaded by entering a plugin URL in Help > Install New Software. The plugin URL is on [Google's Eclipse page]


(https://developers.google.com/eclipse/docs/getting_started). You will be asked to install software for Google App Engine and other Google utilities. You only need the Eclipse plugin package.

DOWNLOAD GWT SDK
Download the GWT SDK 2.7.0 zip from Google's site. You will need to explode it and save in a directory on your compuer.

In Eclipse, go to Window > Preferences > Google > Web Toolkit > SDKs > Add. You will need to specify the directory where GWT is installed. The GWT zip has a few different sub-layers, so choose the directory where all of the JAR files are installed.

SETUP RUN CONFIGURATION
In Eclipse, go to Run > Run Configurations, select Java Application, right click and select New.

In the Main tab, add the project assembly-ide-war with main class as com.google.gwt.dev.codeserver.CodeServer.


In the same panel, select the Arguments tab. We will add some content to Program arguments. Some of the parameters are mandatory, and you must add a -src parameter for each plugin that you have authored.

Shell
-noincremental -src target/generated-sources/gen -src {path-to-your-extension}/src/main/java org.eclipse.che.ide.IDE

In the Classpath tab, go to User Entries > Add External Jars. Add:

gwt-codeserver.jar (in the directory where you unzipped GWT zip),
gwt-dev.jar, (also in the same directory)
The JAR file for any extensions or plugins that you have built. You can find this JAR file in two locations. First, you can find it in the /target folder where you compiled the plugin. Second, you can also find it in your maven's local repository, typically in its .m2 folder.

In the Source tab, remove any non-existent source folders. This is uncommon, but if you see something like src/text/java then these folders should be removed.

LAUNCH SUPER DEV MODE
Run super dev mode in Eclipse by Run > Run Configurations. Select the run configuration that you just created and select Run. The first boot can take a few minutes as GWT is recompiling the application with development mode hooks.

In the Eclipse console output, you will see a special URL - http://localhost:9876/. Launch a browser with this page. There will be two bookmarklets to drag onto your browser’s bookmark bar - Dev Mode On and Dev Mode Off.


LAUNCH CHE WITH SUPER DEV MODE
Run Che normally. You can use the CLI, the Che launcher, or Eclipse. Within your browser create a workspace and then identify the workspace name. Open the workspace with the workspace name or ID that you captured, so this would be http://<che-url>/che/<ws-name>`.

Click the Dev Mode On bookmark on your booksmark bar. A message will appear asking you to recompile the application. Select the _app and compile it.


The compilation will likely take 5 to 10 Minutes:


Che is now running in Super Dev Mode. You can now make incremental Java source file changes within your IDE and then have the browser trigger an incremental rebuild and reload.

DEBUGGING GWT APPS IN THE CHROME BROWSER
Google Chrome has an ability where you can set breakpoints for your Java GWT apps from within the Chrome browser itself, even though Chrome has loaded your GWT app as JavaScript!

For this to work, you will need to enable source maps in the Chrome developer console. Open the developer console and navigate to the Sources tab.


You will see the Java classes that make up your IDE plugin. You can open individual classes to set breakpoints. To set a breakpoint, right click on the line of code.


The chrome debugger panel.
The app will pause in a chrome debugger on any breakpoint. You will see traces with exceptions if any. You can also step over, into and out of function calls. If you modify any of the Java source code in Eclipse, click on the Dev Mode On bookmark to recompile the application.

GWT Super Dev Mode for IntelliJ
The steps to configure Super Dev Mode for IntelliJ are largely similar to what you do for Eclipse.

DOWNLOAD GWT SDK
Download the GWT SDK 2.7.0 zip from Google's site. You will need to explode it and save in a directory on your compuer.

CONFIGURE INTELLIJ FOR GWT
JetBrains has a helpful page. There is just a single step.

MODIFY THE CHE ASSEMBLY
There are a few additional modifications to /che/assembly/assembly-ide-war/pom.xml. First, add a gwt-dev dependency and delete all 'provided' scopes.

/che/assembly/assembly-ide-war/pom.xml
<dependency>
    <groupId>com.google.gwt</groupId>
    <artifactId>gwt-dev</artifactId>
    <version>${com.google.gwt.version}</version>
</dependency>

<!-- delete me -->
<scope>provided</scope>
SETUP RUN CONFIGURATION
In Run > Edit Configurations > GWT Configuration, add a new configuration. You must add Dev Mode parameters to include the items listed in the graphic below.


RUN SUPER DEV MODE
Follow the remaining steps for running a configuration to launch Super Dev Mode, running Che in Super Dev Mode, and then debugging your application within Chrome.

Setup the Che IDE
 Building Che Extensions in Che Coming Soon

This is currently disabled in the Che beta. It will be added shortly. To build and run Che within Che, we start getting into some Docker inception, so there is some additional engineering we must complete to enable this.

You can create, build and run client-side Che extensions using the Che IDE.

Start Che.
Select File > New > Project.
Choose Empty Extension Project from the list of samples.
Enter a name for the project and click Create.
Run the extension to compile it and package into the existing assembly.
Che will launch another Che instance with your assembly.
In this mode, you can make updates to your extension source code without restarting the Che server. After you have made changes, press Update Extension. Your extensions will be recompiled and relaunched within the existing runner.



\\\\\\\\\\\\\\\\\Building Extensions
Building Extensions
This section describes, how to create, build and run a new extension to Che. It is focused on the infrastructural part only. To set-up a workspace, you should first refer to the Contributor Setup: Che Workspace

Build and Run Che
We document how to build and run Che from source in the GitHub repository wiki. You should get familiar with this development workflow and be able to compile and run Che before you start to build an extension.

In order to build Che, you need to properly set the dependencies, they are listed in the GitHub repository wiki.
Similarly, to build the Dashboard submodule, you'll find the dependencies and instructions in the following wiki readme.md of the GitHub repository.

To simplify this we build a Docker image with all the dependencies needed to build Che and all its submodules. Please follow theses instructions build Che using the Docker image.

If you want to work with an IDE, please follow this guideline: IDE Setup.

Sample Extensions
There are a set of sample extensions that are included in the Che source code. They are in the /samples directory. The examples below reference once of those samples, named sample-plugin-embedjs.

The Che sample plugins are not packaged with Che. You need to add each one to Che to test its capabilities. Most of the documentation provides instructions on how to create, build and link extensions manually.

Usually, most developers will copy an existing extension into a new directory and then build that. The linking process is one-time and can be cumbersome the first time that you do it. Che provides a utility in the source code (in a built assembly) called bin/che-install-plugin that automates the linking of your extensions into Che and the rebuilding of an assembly. While this utility is helpful, it's best if you go through the linking exercise once manually to understand the various relationships of what is linked where and why.

Extension Structure
The typical structure of a Che extension is composed of the following:

File	Details
/extension/pom.xml
/extension/src/
/extension/target/

Your extension source and build files. The pom.xml is a build file that compiles your extension and creates a JAR packaging of it. Your JAR is placed in the /target directory and installed into your local maven repository.

Depending on the complexity of your extension, you might build the structure of your plugin with multiple modules. Each module is independently buildable, and they each would have their own pom.xml, src, and target entries.

File	Details
/extension/extension-ide

Your extension module for the IDE client.

/extension/extension-server

Your extension module for the server part.

/extension/extension-shared

Your extension module for the shared code between the server and the client.

Each module has a directory structure that is based upon maven and will include source code and a target where artifacts are placed.

Shell
pom.xml
src/main/java/{package-name}/{extensionName}.java
Depending on the extension, you may also need to include:

Text
# Required for client-side extensions
src/main/resources/{package-name}/{extensionName}.gwt.xml

# Optional, required if you use GIN injection (in client-side extensions)
# GIN injection causes configuration & invocation during IDE activation
src/main/java/{package-name}/{extensionName}GinModule.java

# Optional, required if you use Guice injection (in server-side extensions)
# Guice injection causes configuration & invocation during Che server activation
src/main/java/{package-name}/{extensionName}GuiceModule.java

# Optional, required if you want to include static JavaScript or CSS files (in client-side extensions)
src/main/resources/{full-qualified-extension-name}/your-javascript.js
Generally you can give Gin and Guice modules any file name, but for the sake of simplicity we suggest sticking to the naming convention above.

See the following example for an advanced sample extension.

Compiling Extensions
POM.XML
Each extension has a root pom.xml file. When configuring an extension pom.xml file, you must define an <artifactId> tag which will be the unique name identifier given to this extension. This identifier tag will be referenced by the Che assembly to declare that your extension is part of Che. You can override the groupId and version parameters from the parent, or if not specified, it will inherit the values set by the <parent> tag reference.

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>che-parent</artifactId>
        <groupId>org.eclipse.che</groupId>
        <version>!!! REPLACE_WITH_CHE_VERSION !!!</version>
    </parent>
    <artifactId>che-examples-service</artifactId>
    <packaging>jar</packaging>
    <name>Che :: Examples :: Service</name>
    <dependencies>
        <dependency>
            <groupId>com.google.inject</groupId>
            <artifactId>guice</artifactId>
        </dependency>
        <dependency>
            <groupId>javax.ws.rs</groupId>
            <artifactId>javax.ws.rs-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.eclipse.che.core</groupId>
            <artifactId>che-core-commons-inject</artifactId>
        </dependency>
        <dependency>
            <groupId>com.google.gwt</groupId>
            <artifactId>gwt-user</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    <repositories>
        <repository>
            <id>codenvy-public-repo</id>
            <name>codenvy public</name>
            <url>https://maven.codenvycorp.com/content/groups/public/</url>
        </repository>
        <repository>
            <id>codenvy-public-snapshots-repo</id>
            <name>codenvy public snapshots</name>
            <url>https://maven.codenvycorp.com/content/repositories/codenvy-public-snapshots/</url>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository>
            <id>codenvy-public-repo</id>
            <name>codenvy public</name>
            <url>https://maven.codenvycorp.com/content/groups/public/</url>
        </pluginRepository>
        <pluginRepository>
            <id>codenvy-public-snapshots-repo</id>
            <name>codenvy public snapshots</name>
            <url>https://maven.codenvycorp.com/content/repositories/codenvy-public-snapshots/</url>
        </pluginRepository>
    </pluginRepositories>
    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
            </resource>
        </resources>
    </build>
</project>
Extensions can choose to reference the Che maven dependency management pom.xml which enforces coding standards incorporated throughout Che. It will also set dependencies version automatically. The <repositories> tag provides a reference to Che's maven repository hosted by Codenvy.

Please notice the <version> tag. Make sure you alter the version reference so it points to the correct version of Che that you installed (or merely the Git tag/branch you checked out). You can find out the correct Che version by looking at the che parent pom /che/pom.xml.

We do not require you to use this parent configuration file. Therefore you can bypass the default Che parent configuration and use a custom maven configuration according to your needs.

LICENSING
Referencing the Che parent pom.xml enforces the Eclipse Che license header to be in place for all source files. You can execute mvn license:format to add license headers to your files. Or, to skip the license check add:

pom.xml
<plugin>
  <groupId>com.mycila</groupId>
  <artifactId>license-maven-plugin</artifactId>
  <configuration>
    <skip>true</skip>
  </configuration>
</plugin>
If you modify the pom.xml it needs to be sorted. Run mvn sortpom:sort to sort the pom.xml.

BUILD YOUR EXTENSION
In your extension directory, run mvn clean install. This will build JAR files that bundle your extension.

Text
/target
  {your-extension-name}-{version}-sources.jar
  {your-extension-name}-{version}.jar
Linking Extensions
After you compile your extension, they will be packaged as JAR files. Those JAR files will need to be included into Che and then you can create a custom assembly of Che that includes the JAR files of your extensions.

CHE FILES FOR LINKING
File	Details
/che/assembly/pom.xml

Both server-side and client-side extensions. Due to a temporary limitation in version management, your dependency must also be added to the root Che build artifact.

/che/assembly/assembly-ide-war/pom.xml

Client-side (IDE) extensions. Build file for main Che assembly.client side components, extension dependency should be added to this pom.xml.

/che/assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml

Client-side (IDE) extensions. Client-side extensions are authored in GWT. Add your extension GWT module as an inheritance to this IDE GWT module.

/che/assembly/assembly-wsagent-war/pom.xml

Server-side workspace extensions. Build file that generates the Che web application agent that is deployed inside of a running workspace. You can add your extension to be included with this agent by adding it as a dependency in this file. Update this if your extension brings a new server-side service or component, or extends an existing API deployed with a workspace agent.

/che/assembly/assembly-wsmaster-war/pom.xml

Server-side Che server extensions. Add your extension as a dependency here if you want your server-side APIs to be accessible as part of the Che server. We call the workspace master (Che server) the location where master functions are provide like add / remove workspace. But if you just want server-side functionality that is available to the IDE, it must go into the workspace, which we call a workspace agent.

che/assembly/assembly-wsagent-server/pom.xml

Optional This assembly constructs all of the pieces to create a Che agent server that will be packaged and deployed into any running workspace that has the dev-agent deployed into it. This Che agent server runs a Tomcat server that deploys any of your server-side workspace extensions along with other APIs required by Che to manage the workspace.

YOUR EXTENSION IDENTIFIER
Every extension has a unique maven identifier. You will need to reference this identifier as a dependency. You can define your own identifiers for extensions or pull the identifier out of the pom.xml of the extension you are working with. For example, in the samples that are provided with che the samples/sample-plugin-embedjs/ has a single module for the IDE, and the identifier for the IDE extension is located in sample/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/pom.xml.

/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/pom.xml
<parent>
  <artifactId>che-sample-plugin-embedjs-parent</artifactId>
  <groupId>org.eclipse.che.sample</groupId>
  <version>5.0.0-M6-SNAPSHOT</version>
</parent>
<artifactId>che-sample-plugin-embedjs-ide</artifactId>
And the identifier of this extension is the artifactId, groupId, and version tags combined together. Tags can inherit values from parents if they are not explicitly defined in the pom.xml. So this extension has the identifier of.

XML
<artifactId>che-sample-plugin-embedjs-ide</artifactId>
<groupId>org.eclipse.che.sample</groupId>
<version>5.0.0-M6-SNAPSHOT</version>
ADD EXTENSION TO ROOT CHE POM
In order to allow your extension to be visible from the root level of Che, add your extension as a dependency in the list of <dependencies> from the <dependencyManagement>block. There are a lot of them in the root pom.xml. To avoid transitive dependencies, we require every dependency to be explicitly listed and added. While this may seem like a pain in the arse, this will save you a lot of pain in the future from having circular references.

/pom.xml
<dependencyManagement>
  <dependencies>
    ...
    <dependency>
      <groupId>org.eclipse.che.sample</groupId>
      <artifactId>che-sample-plugin-embedjs-ide</artifactId>
      <version>${che.version}</version>
    </dependency>
    ...
  </dependencies>
</dependencyManagement>
You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.

Optional: Skip Enforcement
By default, Che has the Maven enforcer plug-in activated. When this plugin is activated, your dependency must be declared in the root pom.xml. You can skip enforcement, which will not require your extension to be in the root pom.xml. You skip enforcement by building -Denforcer.skip=true.

IDE EXTENSION: LINK TO ASSEMBLY
To include your jar files within the Che assemblies you have to introduce your extension as a dependency in /che/assembly/assembly-ide-war/pom.xml and also have it added as a dependency to the GWT application. First add the dependency:

/che/assembly/assembly-ide-war/pom.xml
<dependency>
  <groupId>org.eclipse.che.sample</groupId>
  <artifactId>che-sample-plugin-embedjs-ide</artifactId>
</dependency>
You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.

Second, link your GUI extension into the GWT app. You will add an <inherits> tag to the module definition. The name of the extension is derived from the direction + package structure that you have given your extension. For example:

/che/assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml
<inherits name='org.eclipse.che.plugin.embedjsexample.EmbedJSExample'/>
And this means that in our embed sample, there is a file with a *.gwt.xml extension in a folder structure identical to the name above.

Shell
# This name was derived from the package structure in your sample:
/che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/resources/org/eclipse/che/plugin/embedjsexample/EmbedJSExample.gwt.xml
Once you have added the IDE extension to both locations, you need to rebuild the IDE.

Shell
# Build a new IDE.war
# This IDE web app will be bundled into the assembly
cd che/assembly/assembly-ide-war
mvn clean install

# Create a new Che assembly that includes all new server- and client-side extensions
cd assembly/assembly-main
mvn clean install

# Start Che natively
cd che/assembly/assembly-main/target/eclipse-*/eclipse-*/bin
che run

# Or start Che using the CLI with your new assembly
# Replace <version> with the actual directory name
export CHE_LOCAL_BINARY=path_to_che_sources/assembly/assembly-main/target/eclipse-che-<version>/eclipse-che-<version>
che start
SERVER SIDE WORKSPACE EXTENSIONS: LINK TO ASSEMBLY
To include your jar files within the Che assemblies you have to introduce your extension as a dependency in /che/assembly/assembly-wsagent-war/pom.xml and then rebuild the agent server.

/che/assembly/assembly-wsagent-war/pom.xml
<dependency>
  <groupId>org.eclipse.che</groupId>
  <artifactId>che-examples-service</artifactId>
</dependency>
Once you have added the server-side extension as a dependency, you need to rebuild the agent that is deployed into the workspace.

Shell
# Create a new web-app that includes your server-side extension
cd che/assembly/assembly-wsagent-war
mvn clean install

# Creates a new agent that includes your server web app that will deploy into workspace
cd che/assembly/assembly-wsagent-server
mvn clean install

# Create a new Che assembly that includes all new server- and client-side extensions
cd assembly/assembly-main
mvn clean install

# Start Che natively
cd che/assembly/assembly-main/target/eclipse-*/eclipse-*/bin
che run

# Or start Che using the CLI with your new assembly
# Replace <version> with the actual directory name
export CHE_LOCAL_BINARY=/assembly/assembly-main/target/eclipse-che-<version>/eclipse-che-<version>
che start
SERVER SIDE CHE SERVER EXTENSIONS: LINK TO ASSEMBLY
To include your jar files within the Che assemblies you have to introduce your extension as a dependency in /che/assembly/assembly-wsmaster-war/pom.xml and then rebuild the Che server, which we call master.

XML
<dependency>
  <groupId>org.eclipse.che</groupId>
  <artifactId>che-examples-service</artifactId>
</dependency>
Once you have added the extension to the Che server, you need to rebuild the Che server.

Shell
# Create a new Che server web app that includes your Che server extension
cd che/assembly/assembly-wsmaster-war
mvn clean install

# Create a new Che assembly that includes all new server- and client-side extensions
cd assembly/assembly-main
mvn clean install

# Start Che natively
cd che/assembly/assembly-main/target/eclipse-*/eclipse-*/bin
che run

# Or start Che using the CLI with your new assembly
# Replace <version> with the actual directory name
export CHE_LOCAL_BINARY=/assembly/assembly-main/target/eclipse-che-<version>/eclipse-che-<version>
che start
Loading Sequence
There are three ways your extension code is invoked:

Compiled into the Che IDE application.
When the Che IDE application is activated your GIN modules are invoked.
When the Che server boots your Guice modules are invoked.
Text
CHE ASSEMBLY                              YOUR PLUGIN (title: YourExtension)
------------                              ----------------------------------
IDE.gwt.xml  ------>  references  ----->  YourExtension.gwt.xml
pom.xml  ---------->  builds  --------->  YourExtension.java
  |
  | builds
  |
  🔻
  Che IDE  -------->  injects  -------->  YourGinModule.java      (optional)


CHE RUNTIME                              
-----------                              
@boot  ------------>  injects  -------->  YourGuiceModule.java    (optional)

The Che assembly is the root Che project that builds a number of assemblies from a set of system plug-ins together with your custom plug-in. The Che assembly has a master configuration file, /assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml which defines the modules to compile into the application.

To manually add your plug-in to the Che assembly, you update the IDE.gwt.xml file and the assembly pom.xml with information about your plug-in. When the Che assembly is built, it will download your extension as a dependency and compile it into the Che IDE application. The Che IDE application will use dependency injection to load any Gin modules. When you boot Che within tomcat or another application server, Che uses Guice to load any server-side modules for dependency injection.

Your extension may require access to types provides by Che or the Che API, i.e. if you are implemenenting a custom project type or wizard. Che objects can be injected with Gin and Guice which enables your extension to make use of them.

Improving Incremental Builds
There are a number of tweaks you can use to speed up the various stages of development. One possibility to speed up the initial build and packaging process is by disabling tests and skipping certain maven plugins.

Shell
# Add flags to skip the testing and code analysis phases of maven
mvn clean install -DskipTests -Dskip-validate-sources -Dgwt.compiler.localWorkers=4 -Dfindbugs.skip=true
XML
<!-- In /assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml -->

<!-- Tell Che to only build one type of browser JavaScript -->
<!-- Values can be 'safari' or 'firefox'.  Safari builds for chrome -->
<set-property name="user.agent" value="safari"/>

<!-- Reduces compiler permutations through some GWT magic. -->
<!-- See https://code.google.com/p/google-web-toolkit/wiki/SoftPermutations. -->
<collapse-all-properties />
If you intend to develop an IDE extension, incremental deployments of compiled changes can safe a lot of time. To enable incremental deployments use the so called "super development mode" provided by GWT. Setup instructions are provided on IDE Configuration.

\\\\\\\\\\\\\\\\\\\\Assemblies
Assemblies
An assembly is a packaging of Che libraries and plug-ins distributable as a desktop IDE or workspace server.

The assemblies generated by Che can be packaged and distributed as a new desktop IDE or workspace server. You can reuse this infrastructure to customize how assemblies and installers are generated. To do so, you must learn about the assembly module and dependency hierarchy.

Che Layout
A Che assembly has the following directory structure after it is installed.

Text
/bin             # Scripts to start, stop, and manage Che
/conf            # Configuration files
/lib             # Workspace agent, terminal and other resources a workspace may require
/plugins         # Staging for Che plugins that you author
/sdk             # Che packaging with SDK tools required to compile custom Che assemblies
/templates       # Project samples that appear in dashboard or IDE
/tomcat          # App server used as a runner for Che extensions, packaged with war and jar artifacts
Modules
The purpose of the http://github.com/eclipse/che/assembly module is to generate Che assemblies. It has five sub-modules.

Text
assembly-main            # Contains the base structure of a Che assembly
assembly-ide-war         # Generates the IDE web app (ide.war) loaded by Che server (client side)
assembly-wsagent-server  # Contains the base structure of a workspaces server 

assembly-wsagent-war     # Generates a machine web app (ide.war) used by workspace agent (server side APIs)
assembly-wsmaster-war    # Generates IDE web app with server side components
Run mvn clean install in the /assembly module to build the project and generate an assembly. The output of the mvn clean install command generates a new assembly and places the resulting files in the target folder. The assembly-ide-war module is the longest operation as it uses a GWT compilation operation to generate cross-browser JavaScript from numerous Java libraries. You can speed the assembly generation process by building assembly-main, which will download the latest IDE web application from Che's nexus repositories.

Text
/assembly-main
  /target
    /archive-tmp
    /eclipse-che-{version}               # Exploded tree of assembly
    /dependency                          # Copied into /lib folder of assembly
    /dependency-maven-plugin-markers
    /findbugs
    eclipse-che-{version}.tar.gz         # TAR file of assembly
    eclipse-che-{version}.zip            # ZIP file of assembly
Custom Assemblies
You can generate assemblies that include custom plug-ins and extensions. Custom assemblies can be distributed as ZIP or TGZ packages.

Shell
che-install-plugin [OPTIONS]         
     -a            --assembly          Creates new distributable Che assembly with your plugins 
     -s:deps,      --skip:deps         Skips automatic injection of POM dependencies of your plugins 
     -s:maven,     --skip:maven        Skips running maven to inject your plugins into local repository
     -s:update,    --skip:update       Skips updating this assembly; leaves packages in /temp build dir 
     -s:wsagent,   --skip:wsagent      Skips creating new ws agent 
     -s:wsmaster,  --skip:wsmaster     Skips creating new ws master, which contains IDE & ws manager
     -d,           --debug             Additional verbose logging for this program
     -h,           --help              This help message
This utility will create new web application packages with your custom plugins and optionally create new assemblies. Custom plug-ins are placed into the /plugins directory. Che packages extensions and plug-ins into Web application packages that are then deployed by Che. The location of your plug-ins determines how your plug-ins will be packaged and deployed.

Place plug-in JARs & ZIPs:

PlugIn_Location>>>>>>	What Is Built
/plugins/ide

IDE extension, compiled with GWT & packaged into new ws-master Web application.

/plugins/ws-master

Server-side extension & packaged into new ws-master Web application with IDE.

/plugins/ws-agent

Server-side extension that runs in workspace machine & packaged into new ws-agent Web application.

/

Packaged in both ws-master and ws-agent Web applications. (Not Recommended)

You extension is compiled into one of two Web applications:

Workspace Master.
Workspace Agent.
The workspace master is deployed into the core Che server. The workspace agent is deployed into the machine powering each workspace created by your users. Each workspace agent is unique to the workspace that created it. While you can deploy plug-ins into both locations, this is costly at compile and runtime.

The Che assembly is generated by Che utility in stages.

Text
1. Install your plug-ins to a local maven repository.

2. Create a staging module to build new Web applications
   `/sdk/assembly-ide-war/temp`     --> Where ws-master web app will be generated
   `/sdk/assembly-machine-war/temp` --> Where ws-agent web app will generated

3. Your plug-ins are added as dependencies to the maven pom.xml in each staging module. 

4. The new Web application packages are compiled and packaged in the staging directory.
    `mvn sortpom:sort`
    `mvn -Denforcer.skip=true clean package install -Dskip-validate-sources=true`

5. If your plug-ins are added into a workspace agent Web app, we then create a new ws-agent.zip.
   `/sdk/assembly-machine-server`          --> Packages ws agent Web app w/ Tomcat into ws-agent.zip.
   `mvn -Denforcer.skip=true clean package install` 

6. The new Web applications are copied into your core Che assembly, overwriting old version. 
   `/sdk/assembly-ide-war/temp/target/*.war`          --> /tomcat/webapps
   `/sdk/assembly-machine-server/target/*.zip`        --> /lib/ws-agent.zip
   Use `--skip:update` to avoid overwriting existing files.
   
7. If `--assembly`, then we create a new distributable package of Che.
   `/sdk/assembly-main`
   `mvn clean package`
Runtime Deployment
When Che is running, the embedded assets are deployed into different locations.

Text
BROWSER CLIENT                           CHE SERVER                                 WORKSPACE (DOCKER)

                                         launches ws-agent.zip in workspace ----->  /webapps/ide.war
                                         launches terminal in workspace     ----->  /webapps/terminal

JS / CSS / HTML -- download from ---->   /tomcat/webapps/ide.war
JS / CSS / HTML -- download from ---->   /tomcat/webapps/dashboard.war

JS / CSS / HTML -- download from ------------------------------------------------>  /webapps/ide.war
JS / CSS / HTML -- download from ------------------------------------------------>  /webapps/terminal
Your browser clients download JavaScript, HTML, and CSS resources from two different locations, both from the Che server and from a second Che server that is running within the workspace. Each workspace has its own ws-agent.zip that is injected into the workspace at runtime by Che. The ws-agent.zip contains a second application server that is booted when the workspace is activated.

While both the Che server and the ws-agent.zip each have an ide.war web application within them, they are not identical. There are numerous common libraries between the two, but the Che server hosts the primary IDE files that are shared by clients across all workspace development, and the ws-agent.zip deployment contains additional libraries for plug-ins that perform workspace modification (such as doing local JDT intellisense) along with additional Che classes that make it possible for the workspace agent to communicate over REST to the Che server.

The dashboard.war web application is an Angular JS application that provides the user dashboard that is booted when Che launches. It is used for managing workspaces, projects and user preferences.

Assembly Dependency Hierarchy
There are two servers that are deployed when Che is started:

The Che server, and:
The workspace agent, which is a server running in each workspace
The Che assembly, packaged as eclipse-che-{version}.zip contains both servers. The following charts layout which assembly modules build each of the assets.

Text
eclipse-che-{version}.zip                              ==> Generated by assembly-main
-> ide.war           ==> Placed in /tomcat/webapps     ==> Generated by assembly-ide-war
-> dashboard.war     ==> Placed in /tomcat/webapps     ==> Generated by che-dashboard repo
-> wsmaster.war           ==> Placed in /tomcat/webapps     ==> Generated by assembly-wsmaster-war
-> ws-agent.zip      ==> Placed in /lib                ==> Generated by assembly-machine-server
-> terminal          ==> Placed in /lib                ==> Generated by che-websocket-terminal repo
Text
ws-agent.zip                                           ==> Generated by assembly-wsagent-server
-> tomcat            ==> Placed in /                   ==> Downloaded from Che maven repo
-> ide.war           ==> Placed in /webapps            ==> Generated by assembly-wsagent-war
   -> che-core-*.jar                                   ==> Downloaded from Che maven repo
   -> che-plugins-*.jar                                ==> Downloaded from Che maven repo
   -> ws-agent specialized classes                     ==> Built by assembly-machine-war
Note that the ide.war web application generated for the workspace agent is not identical to the one generated for the Che application server, even though they have the same name. The workspace agent does not include many of the IDE libraries and adds in additional libraries for communicating to the Che server and running plug-ins within the workspace itself.

Che Repositories
The ide.war, ws-agent.zip, and other assembly files depend upon a wide range of libraries. Many of these resources and libraries are stored in other Che repositories.

These are the repositories that are stored at http://github.com/eclipse organization. Each repository is referenced by its first entry, ie: http://github.com/eclipse/che or http://github.com/eclipse/che-dependencies.

Shell
/che
/che/assembly                             # Generates binary assemblies of Che
/che/assembly/assembly-main               # Final packaging phase
/che/assembly/assembly-ide-war            # Creates the IDE.war from plug-ins & core
/che/assembly/assembly-wsmaster-war       
/che/assembly/assembly-wsagent-war        # Creates the agent WAR from plug-ins & core
/che/assembly/assembly-wsagent-server     # Creates the agent server that goes into ws
/che/core                                 # Platform APIs
/che/dashboard                            # AngularJS app for managing Che
/che/plugins                              # IDE & agent plug-ins
/che/wsmaster                             # Libraries used by the Che server
/che/wsagent                              # Libraries used by agents installed into workspaces

/che-lib                                  # Forked dependencies that require mods
/che-lib/swagger
/che-lib/terminal
/che-lib/websocket
/che-lib/pty
/che-lib/che-tomcat8-slf4j-logback

# All modules in /che and /che-lib depend upon /che-dependencies
/che-dependencies                         # Maven dependencies used by che
/che-dev                                  # Code style and license header

# /che-dependencies and /che-dev depends upon /che-parent
/che-parent                               # Maven plugins and profiles
You can build individual directories of Che, or any of its sub-modules. These modules will generate JARs, WARs or other artifacts. The same happens if you build plug-ins of your own. These are artifacts are installed into a local maven repository that /che/assembly uses when creating a combined assembly. It is also possible for you to copy the JAR files of plug-ins you author to an assembly staging area instead of installing them into a nexus repository.

If you build Che locally and if the necessary artifact dependencies are not locally installed into your maven repository, then Che will look in Codenvy's hosted nexus for packages. Codenvy maintains tagged versions of packages for the current SNAPSHOT and older versions.

You can see the reference to Codenvy's repositories in the che-dependencies repository at the end of the pom.xml.

XML
<repositories>
    <repository>
        <id>codenvy-public-repo</id>
        <name>codenvy public</name>
        <url>https://maven.codenvycorp.com/content/groups/public/</url>
    </repository>
    <repository>
        <id>codenvy-public-snapshots-repo</id>
        <name>codenvy public snapshots</name>
        <url>https://maven.codenvycorp.com/content/repositories/codenvy-public-snapshots/</url>
    </repository>
</repositories>
 Installers

Currently, the installers are generated from the http://github.com/codenvy/che-installer repository. This repository contains an Innosetup package for creating the Windows bundle and IZPack for creating a universal installer.

Codenvy Assemblies
It is possible to package Che plug-ins into assemblies for Codenvy On-Prem, which will make those services available in an elastically scalable, highly available cloud infrastructure.

\\\\\\\\\\\\\\\\\\\\\\\\\Dependency Injection
Dependency Injection
In this section, we briefly introduce the usage of dependency injection in Che, on the client and on the server side. If you are already familiar with Guice and Gin, you might want to skip this part.

Che uses dependency injection to wire the different components, in order to create objects as well as register and retrieve extensions. Therefore, dependency injection is technically the core mechanism of communicating with the framework and connecting custom extensions. This includes accessing framework services and objects (e.g. a file type or a file type registry) and providing custom objects to the framework (e.g. a custom wizard).

Che uses the existing dependency injection framework Guice on the server-side and the GWT version of Guice, Gin, on the client-side.

In general, there are two use cases for dependency injection: consuming objects and providing objects.


Please note that when extending Che, DI consumer and provider can be either in your custom extension or within the Che framework. As an example, if you want to provide a new wizard to be used in the IDE, you will create an object provider, which provides the wizard. Che implements an object consumer, which picks up the wizard class and uses it. In turn, if you want to access a service provided by Che, your extension will be the object consumer.

The main goal of using dependency injection is to decouple object provider and object consumer. Both parties just need to know about the object they consume/provide. The object is identified by its type (typically a Java interface) and optionally an additional key.
In the following, we first describe how to consume objects (in Guice and Gin) and subsequently, how to provide objects.

CONSUMING OBJECTS
Required objects can be injected in any class that is instantiated by the framework. If a custom component requires objects, e.g. a service, it can be injected as a parameter. This can be done in the constructor or in methods of a class. If the parameter is required for a class to operate, we recommend using the constructor for injection. To get parameters injected in a method or constructor, it is marked with the annotation @Inject (see code example below). By adding the annotation, all parameters of a constructor/method will be resolved by the framework and passed in through the initialization of the class.

The dependency injection framework needs to know how to identify the correct object to be used as a parameter. There are two essential ways of specifying the parameters as a consumer

First, if you just specify a parameter of a certain type (in the example SomeService), the framework will search for an object of that type. This will only work, if there is exactly one object of this type in the context, which is typically true for services.

Second, if there can be several objects of the required type and you want a specific object out of those, you can additionally specify a key using the annotation @Named.

In the following example, for the second parameter, the framework will look for an object which is of type MyClass has been explicitly registered with the key MyID. Please see the following section how to provide objects to be consumed that way.

Java
public class MyClass {

  private MyOtherClass myOtherClass;

  @Inject
  public MyClass(final SomeService someService,
                            final @Named("MyID") MyClass myClass) {
    someService.someMethod(myClass);
    this.other = new MyOtherClass(myClass);
  }

  // do somehting with myOtherClass;
}
Please note, that dependency injection is only available for objects which are instantiated by the dependency injection framework. In the example above, the class MyOtherClass is instantiated using plain Java, therefore it is not possible to use @Inject in its constructor.

PROVIDING OBJECTS
Implementing an object provider serves two purposes when writing an extension:

First, you can consume the objects that you provide from within other custom classes.

Second, the provided classes can be consumed by the Che framework.

As an example, if you provide a wizard class, it will be integrated by the Che IDE. Therefore, dependency injection is a core extension mechanism of Che.

To provide custom objects, you implement a module class. It is responsible to create the objects to be injected as well as register them using the type and optionally a key. Depending on the general structure of your extension, you could add as many modules as you like, however, most extensions use only one module for the client (Gin) and one for the server part (Guice).

The following code example shows a simple Guice module. All Guice modules inherit from AbstractModule and are marked with the annotation @DynaModule, which registers the module itself to be executed by Guice. The mandatory method #configure is responsible for the registration of objects. We will not go into detail about all the different options of Guice/Gin, but focus on relevant use cases in Che. In the following code example, we register a custom object (CustomObject), which implements an existing Che type (ExistingCheType). The Che type defines an extension point for Che, e.g. a wizard.

Java
public class CustomObject implements ExistingCheType {
  // ...
}
Now, we register our custom object using the type and therefore make it available for the Che framework. To register and to retrieve the object, the type ExistingCheType is used as an identifier. In the example, there can be an arbitrary number of objects implementing ExistingCheType, so Che will retrieve a set of objects. To register the object, we create a new Set Binder for the type ExistingCheType. Then, we add a binding and register the custom object. The CustomObject will be instantiated by the framework using dependency injection. Therefore, the @Inject annotation can be used in the constructor of CustomObject.

Java
import org.eclipse.che.inject.DynaModule;
import com.google.inject.AbstractModule;
import com.google.inject.multibindings.Multibinder;

@DynaModule
public class MyGuiceModule extends AbstractModule {

    @Override
    protected void configure() {
        Multibinder.newSetBinder(binder(), ExistingCheType.class)
                   .addBinding()
                   .to(CustomObject.class);
    }
}
Gin modules inherit from AbstractGinModule and use the @ExtensionGinModule annotation. Gin has a different binding mechanism than Guice, however, for the typical use case, the code would look the same:

Java
import org.eclipse.che.ide.api.extension.ExtensionGinModule;
import com.google.gwt.inject.client.AbstractGinModule;
import com.google.gwt.inject.client.multibindings.GinMultibinder;

@ExtensionGinModule
public class MyGinModule extends AbstractGinModule {

    @Override
    protected void configure() {
        GinMultibinder.newSetBinder(binder(), ExistingCheType.class)
                      .addBinding()
                      .to(CustomObject.class);
    }
}
As an alternative to the registration above, objects can also be registered using methods marked with the @Provides annotation. The following example provides a simple object, which only needs to be instantiated once (@Singleton). In this example, the registration additionally contains a key specified by the @Named annotation. Please note that in this case, the CustomObject is created manually, so no dependency injection can be used within it. The following method is placed in your custom Gin/Guice module.

Java
@Provides
@Singleton
@Named("MyID")
protected FileType provideMyClass() {
      return new MyClass();
}
The examples of dependency injection cover all basic use cases to understand the following extension tutorial. If you want to learn more about the different types of Guice bindings, please refer to this page.

EXTENSION CLASSES
Besides the extensibility using dependency injections, many custom extensions need to call some Che services or registries on start-up. Therefore, most extensions contain a central class called Extension. To register those classes, Che provides the custom annotation @Extension, which also allows to define a title for the extension. A common example for a class which gets instantiated by Che and which requires parameters is the Extension class.

Extension classes will automatically be picked-up by Che on start-up and all methods will be executed using dependency injection. In the following example, the extension class connects SomeParameter to SomeService.

Java
@Extension(title = "My Extension")
public class MyExtension {

  @Inject
  private void myInitialization(
          final SomeService someService,
          final SomeParameter someParameter) {
        someService.doSth(someParameter);
  }
}
Please note that there is typically only one extension class in every extension.


\\\\\\\\\\\\\\\\\\\\\Editors
Editors
This part of the tutorial describes how to extend the Eclipse Che code editor to support a new language. It starts with defining a custom file type and associating it with the specific editor to be opened. Subsequently, we describe how to adapt and enhance the syntax highlighting as well as the code completion of the code editor.

FILE TYPES
In this part of the tutorial, we describe, how new file types can be defined in Che and how those file types can be associated with a specific editor to be opened with. File types can be anything, from a source file to a configuration or properties file. By defining a new file type, it will be displayed in the project explorer using a specific icon. Further, it can be opened and modified with the associated editor. Please note, that Che already provides support for many common file types, so before defining a new one, you should check whether it is already supported.

Defining a new file type consists of three basic steps:

Define the file type itself, including specifying a name, a file extension and an icon
Register the new file type in the file type registry
Optional: Register the file type in the editor registry and thereby associate it with a specific editor to be opened with
A simplified version of a registration of a new file type with the extension .my covering exactly these three necessary steps in correct order looks like this:

Java
FileType myFileType = new FileType("My FileType", anIcon, "my");
fileTypeRegistry.registerFileType(myFileType);
editorRegistry.registerDefaultEditor(myFileType, defaultTextEditorProvider);
In the first line, the new FileType is defined, the parameters of its constructor define a name (visible in the UI), an icon, the mime type and a file extension. 
In line 2, the new file type is registered in Che’s FileTypeRegistry. 
In line 3 the file type is added to Che’s editor registry and thereby associated with Che’s default editor. 
Please note that step three is optional, as Che will associate all file types with the default text editor by itself. However, this step is necessary, if you later want to implement a custom editor provider.

Following a modular design, and following the guideline for the structure of Che plugins, the creation of the file type and the registration should be kept in two separate components (Java Classes).
The following diagram shows all components of a typical file type registration. 
The three classes highlighted in dark grey are to be implemented or adapted for the extension.
The class MyGinModule is responsible for creating the new file type. The icon for the new file type will go to a GWT resource class (MyRessources). Finally, the class MyExtension creates a FileTypeRegistration in Che's FileTypeRegistry.


If you haven’t used Gin or dependency injection before, we recommend you have a look at our brief dependency injection introduction.

First, we define a new class GinModule for the instantiation of the custom FileType. It enables other classes to access the new file type using dependency injection. When adding more extensions later, the GinModule class can also create other components and mappings. So we will not call it FileTypeGinModule, but more generically MyGinModule. For now, the GinModule just provides the custom file type using the ID MyFileType. This makes the custom file type available for injection for other components using the annotation @Named(“MyFileType”).

The creation of the file type defines a name, a custom icon and the file extension. If Strings, such as the file extension, are used at other places later, they should be externalized to a common place, for simpler reading, we keep them inlined for now. If those Strings also need to be consumed by a server component later, it should go to a “shared” module, for now, it is kept in the IDE (client) module.

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/inject/MyGinModule.java
org.eclipse.che.plugin.myextension.ide.inject.MyGinModule
@ExtensionGinModule
public class MyGinModule extends AbstractGinModule {

  @Override
  protected void configure() {
    //Nothing to do here, yet
  }

  @Provides
  @Singleton
  @Named("MyFileType")
  protected FileType provideMyFile() {
     return new FileType(MyResources.INSTANCE.icon(), "my");
  }
}
The custom file type consumes an icon, which is retrieved from a GWT resource:

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/MyResources.java
org.eclipse.che.plugin.myextension.ide.MyResources
public interface MyResources extends ClientBundle {
   MyResources INSTANCE = GWT.create(MyResources.class);
  
   @Source("icons/my.svg")
   SVGResource icon();
}
The icon itself is a svg image located in the resources of the extension:
https://github.com/eclipse/che/tree/master/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/resources/org/eclipse/che/plugin/jsonexample

To register the custom file type at Che’s Editor registry, we create another class called MyExtension. Again, we name this class more generically, as it will additionally contain other extensions to the IDE. The extension gets the new file type and the FileTypeRegistry injected and creates the file type registration.

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/MyFileTypeExtension.java
org.eclipse.che.plugin.myextension.ide.MyExtension
@Extension(title = "My FileType Extension")
public class MyFileTypeExtension {

  @Inject
  private void registerFileType(
          final FileTypeRegistry fileTypeRegistry,
          final @Named("MyFileType") FileType myFileType) {
    /...
    fileTypeRegistry.registerFileType(myFileType);
  }
}
After registering the file type, Che can map the extension to the definition of the file type. Therefore, Che will use the defined icon, if you create a file with the new extension my (as shown in the following screenshot). As we have not yet defined any editor type, Che will open the new file type in the default text editor and it will assume, that the content type is plain text.


As you can see in the screenshot above, Che will open any new file type in the default editor. This even works without defining any editor extension. You might want to contribute another editor type for the new file type later. This is done by adding an editor extension and associating the file type with an editor provider. We will cover this more in detail in the section Code Completion. As we do not have a custom editor provider, yet, the following example code associates the example file type with the default text editor. Please note, this step is redundant in this example, as Che will associate any unknown file type with the default editor anyways.

Since we might want to add more extensions to the editor, again, we use a more generic name for the extension class. As we extend the Che default editor, written in JavaScript and internally referred to a “JSEditor”, we follow the convention of other existing plugins and call the extension MyJsEditorExtension. The following extension class gets the EditorRegistry, the file type and the DefaultTextEditorProvider injected and creates the editor registration. As mentioned, this will have no visible effect in the example. However, if we would replace the Default Text Editor Provider with our own provider (CustomEditorProvider), we could extend or replace the editor used for our new file type.

Java
org.eclipse.che.plugin.myextension.ide.MyJsEditorExtension
@Extension(title = "My JS Editor Extension")
public class MyJsEditorExtension {

  @Inject
  public MyJsEditorExtension(final EditorRegistry editorRegistry,
                            final @Named("MyFileType") FileType myFile,
                            final CustomEditorProvider editorProvider) {
     editorRegistry.registerDefaultEditor(myFile, editorProvider);
  }

}
So far, we have defined a new file type, which can be opened with the default text editor. Currently, the text editor provides no syntax highlighting and code completion, as it knows nothing about the format or grammar of our new language. The syntax highlighting of the default editor is actually provided by the embedded orion editor (referred to as JSEditor). Please refer to the section syntax highlighting to learn how to extend it and add syntax highlighting for the new file type.

Further, the new file type can only be created using the generic “New” action and enter the extension manually. If you want to define a custom action, visible in the “New” menu, please refer to the section New File Actions.

JSON File Type (already supported by Che)
The continuous JSON example, which is used throughout this tutorial uses the file type ".json". As Che already registeres a JSON file type out of the box, that means, the necessary registrations, described above for the "my" file type example are already existing in the Che core framework. For reference, the corresponding registrations can be found in the following classes and can be used as another example.

File Type Definition
che/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/filetypes/FileTypeModule.java
core/ide/che-core-ide-app/src/main/java/org.eclipse.che.ide.filetypes.FileTypeModule (alongside with other file types)

@Provides
@Singleton
@Named("JsonFileType")
protected FileType provideJsonFile(Resources resources) {
   return new FileType(resources.jsonFile(), "json");
}
File Type Registration
che/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/core/StandardComponent.java
core/ide/che-core-ide-app/src/main/java/org.eclipse.che.ide.core.StandardComponentInitializer

fileTypeRegistry.registerFileType(jsonFile);
Resources
che/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/Resources.java
core/ide/che-core-ide-app/src/main/java/org.eclipse.che.ide.Resources

@Source("defaulticons/json.svg")
SVGResource jsonFile();
Based on these existing registrations, Che will show the JSON file type as shown in the following screenshot. As JSON is a known format to the embedded Orion editor, it will also already provide syntax highlighting.


CODE COMPLETION
This part of the tutorial describes how the code-completion of Che’s default code editor can be extended through new suggestions. This also enables you to add code-completion for completely new languages. The following diagram shows all components of a typical file type registration. The classes highlighted in dark grey are to be implemented for the extension.


First, we need to register a custom editor provider, MyEditorProvider, which plugs in our custom code completion. If you did not register a custom editor provider before, Che will use the DefaultEditorProvider, which we now replace. This is done in a class JsEditorExtension which contains all potential extensions for the JSEditor (see also here).

An editor provider is responsible for configuring a specific editor type. Therefore, it provides an EditorConfiguration, which is responsible for editor features such as code completion, quick assist or code formatting. To provide custom code completion, the EditorConfiguration needs to create a custom CodeAssistProcessor.

In the following example, we will describe how to provide a custom code completion to the existing JSON example editor. For simplicity, the code completion will just return a static list of keywords, however, the example can be extended to provide more sophisticated completion processing.

As a first step, we register a custom JsonExampleEditorProvider:

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/JsonExampleEditorExtension.java
org.eclipse.che.plugin.jsonexample.ide.JsonExampleJsEditorExtension
@Extension(title = "JSON Example Editor")
public class JsonExampleJsEditorExtension {

@Inject
public JsonExampleJsEditorExtension(
final EditorRegistry editorRegistry,
final @Named("JsonFileType") FileType jsonFile,
final JsonExampleEditorProvider editorProvider) {
      editorRegistry.registerDefaultEditor(jsonFile, editorProvider);
   }
}
An Editor Provider needs to implement the interface EditorProvider. If you want to use the default editor configuration, you can inherit from AbstractTextEditorProvider, in this case, you just need to define an ID and a description. Additionally, you can optionally create a custom EditorPartPresenter by implementing the method getEditor. If you do not implement getEditor, the default editor will be created by AbstractTextEditorProvider.
In this tutorial, we create an extension for the existing DefaultTextEditor. Therefore, we first retrieve the existing editor from the DefaultEditorProvider and initialize it with our new custom editor configuration JsonExampleEditorConfiguration, which will add the custom auto-completion to the editor.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleEditorProvider.java
org.eclipse.che.plugin.jsonexample.ide.editor.JsonExampleEditorProvider
/**
 * The JSON Example specific {@link EditorProvider}.
 */
public class JsonExampleEditorProvider extends AbstractTextEditorProvider {

  private JsonExampleEditorConfigurationFactory editorConfigurationFactory;

  /**
  * Constructor.
  *
  * @param editorConfigurationFactory
  * the JSON Example Editor configuration factory
  */
  @Inject
  public JsonExampleEditorProvider(
         final JsonExampleEditorConfigurationFactory                    editorConfigurationFactory) {
        this.editorConfigurationFactory = editorConfigurationFactory;
  }

  @Override
  public String getId() {
     return "JsonExampleEditor";
  }

  @Override
  public String getDescription() {
      return "JSON Example Editor";
  }

  @Override
    public TextEditor getEditor() {
      TextEditor editor = super.getEditor();
      TextEditorConfiguration configuration = this.editorConfigurationFactory.create(editor);
      editor.initialize(configuration);
      return editor;
    }
}
As we just want to adapt the code completion, the example implementation of the editor configuration inherits from the existing DefaultTextEditorConfiguration. The method getContentAssistantProcessors is expected to return a mapping from content types to CodeAssistProcessors. In our case, if this mapping has exactly one entry registering the custom JsonExampleCodeAssistProcessor for the default content type.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleEditorConfiguration.java
org.eclipse.che.plugin.jsonexample.ide.editor.JsonExampleEditorConfiguration
public class JsonExampleEditorConfiguration extends AutoSaveTextEditorConfiguration {

  private Map<String, CodeAssistProcessor> codeAssist;

  public JsonExampleEditorConfiguration() {
    codeAssist = new LinkedHashMap<>();
    codeAssist.put(DEFAULT_CONTENT_TYPE, new JsonExampleCodeAssistProcessor());
  }

  @Override
  public Map<String, CodeAssistProcessor> getContentAssistantProcessors() {
    return codeAssist;
  }
}
A CodeAssistProcessor is responsible for calculating CompletionProposals. Therefore, it gets the editor, from which the completion was triggered, the current offset in this editor and a callback to be filled with completion proposals. In this example, we fill the list of proposals with three SimpleCompletionProposals (see below) containing static Strings (“firstName”, “lastName” and “age”). In a real completion use case, this simple and static example is to be replaced with a more advanced proposal calculation. If any exception occurs during the computation of the completion proposals, e.g. the server is not reachable, a corresponding message should be returned in #getErrorMessage.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleCodeAssistProcessor.java
public  class JsonExampleCodeAssistProcessor implements CodeAssistProcessor {

  @Override
  public void computeCompletionProposals(TextEditor editor, 
                                         int offset, 
                                         CodeAssistCallback callback) {

      List<CompletionProposal> proposals = new ArrayList<>();

      proposals.addAll(Arrays.asList(
         new SimpleCompletionProposal("firstName"),
         new SimpleCompletionProposal("lastName"),
         new SimpleCompletionProposal("age")
      ));

      callback.proposalComputed(proposals);
    }

    @Override
    public String getErrorMessage() {
       return null;
    } 
}
A CompletionProposal represents a completion option to be displayed when the users trigger auto-completion in the editor. Therefore, it shows all necessary information for the user and allows to select the right proposal to be applied. The following example shows a code proposal based on a static String, which is retrieved as a parameter in the constructor. This String is used as the displayed name and, along with the defined icon, will be shown to the user in the proposal list. Finally, once the user has selected a proposal which should be applied, the CompletionProposal returns the Completion (using a callback) in the #getCompletion method.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleCodeAssistProcessor.java
org.eclipse.che.plugin.jsonexample.ide.editor.SimpleCompletionProposal
public class SimpleCompletionProposal implements CompletionProposal {

  private String proposal;

  public SimpleCompletionProposal(String proposal) {
     this.proposal = proposal;
  }

  @Override
  public Widget getAdditionalProposalInfo() {
     return null;
  }

  @Override
  public String getDisplayString() {
     return proposal;
  }

  @Override
  public Icon getIcon() {
     return new Icon("", JsonExampleResources.INSTANCE.completion());
  }

  @Override
  public void getCompletion(CompletionCallback callback) {
     callback.onCompletion(new SimpleCompletion(proposal));
  }
}

A Completion is finally responsible for applying a proposal, once the user has selected one. Therefore, after accessing the Document it can apply any text change necessary. In the following example, we append the static String of the Completion at the current offset. The #getSelection method can optionally set a new selection in the editor after the proposal has been applied. This is done in absolute document coordinates. Returning null (as in the example) will not set any new selection.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/SimpleCompletion.java
org.eclipse.che.plugin.jsonexample.ide.editor.SimpleCompletion
public class SimpleCompletion implements Completion {

  private final String proposal;

  public SimpleCompletion(String proposal) {
     this.proposal = proposal;
  }

  @Override
  public void apply(Document document) {
    document.replace(
        document.getCursorOffset(),
        proposal.length(),
        proposal
     );
  }

  @Override
  public LinearRange getSelection(Document document) {
     return null;
  }
}
In the example, we have shown, how to extend the code completion and used a static list of Strings. However, in a real world example, the calculation of the available proposals might, of course, be more complex. Furthermore, our example completion happens entirely on the client-site, without accessing the server or the workspace. If you need to access dependencies or other resources of a project, please see here to learn how to implement server site services to be used for more advanced code completion.

SYNTAX HIGHLIGHTING
Syntax highlighting allows you to mark characters and keywords in certain colors, based on a given grammar. To enable syntax highlighting in the browser IDE, Che embeds the existing Orion Editor. It already provides a wide range of supported grammars to be used. Please refer to the section “contentType parameter” within this document for a list of supported types.

If the orion editor already knows the language you want to support, you need to associate the file extension with the content type defined by orion. As an example, we could associate our a custom file type .my (see here for its definition) with the existing content type Json, which is already supported by the Orion editor. Therefore, we add the following line to org.eclipse.che.ide.jseditor.client.filetype.ExtensionFileTypeIdentifier:

che/core/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/filetype/ExtensionFileTypeIdentifier.java
org.eclipse.che.ide.jseditor.client.filetype.ExtensionFileTypeIdentifier
  //...
      this.mappings.put("my", makeList("application/json"));
  //...
By adding this mapping, the embedded Orion editor will now provide the JSON syntax highlighting for our custom file type.


To adapt or extend the syntax highlighting of the orion editor, please have a look at the Orion Documentation.

Add syntax highlighting for your own language
There are two options how you can add a syntax highlighting for your own language:

Add the highlighting of content type, supported by Orion, but not by IDE.
Add extension with mime type to File Extension Registry. For example:
/che/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/filetype/ExtensionFileTypeIdentifier.java
//...
this.mappings.put("ino", makeList("text/x-c++src"));
...//
You can configure arbitrary new contentTypes and corresponding highlight configuration.
Usage example:
Java
@Inject
    protected void configureContentType(final OrionContentTypeRegistrant contentTypeRegistrant) {
        // register content type and configure orion
        final String contentTypeId = "text/x-testlang";

        OrionContentTypeOverlay contentType = OrionContentTypeOverlay.create();
        contentType.setId(contentTypeId);
        contentType.setName("Test Language");
        contentType.setExtension("testlang");
        contentType.setExtends("text/plain");

        // highlighting
        OrionHighlightingConfigurationOverlay config = OrionHighlightingConfigurationOverlay.create();
        config.setId("testlang.highlighting");
        config.setContentTypes(contentTypeId);
        config.setPatterns(
                "[\n" + 
                        "  {include: \"orion.lib#string_doubleQuote\"},\n" + 
                        "  {include: \"orion.lib#string_singleQuote\"},\n" + 
                        "  {include: \"orion.lib#brace_open\"},\n" + 
                        "  {include: \"orion.lib#brace_close\"},\n" + 
                        "  {include: \"orion.lib#bracket_open\"},\n" + 
                        "  {include: \"orion.lib#bracket_close\"},\n" + 
                        "  {include: \"orion.lib#parenthesis_open\"},\n" + 
                        "  {include: \"orion.lib#parenthesis_close\"},\n" + 
                        "  {include: \"orion.lib#number_decimal\"},\n" + 
                        "  {include: \"orion.lib#number_hex\"},\n" + 
                        "  {\n" + 
                        "    match: \"\\\\b(?:false|true)\\\\b\",\n" + 
                        "    name: \"keyword.json\"\n" + 
                        "  }\n" + 
                "]");

        contentTypeRegistrant.registerFileType(contentType, config);
    }
	
	
	\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Project Types
	Project Types
Project types allow you to provide custom project behavior for a certain language. Additionally, they allow you to specify specific project templates, which can be instantiated and already contain language specific content. Further, they allow the user to specify language specific properties for a project, e.g. compiler settings or dependencies. Finally, specific actions, e.g. in the context menu, can be associated with a project type.

In this part of the tutorial, we describe how to define a custom project type, how to provide a custom creation wizard, and how to add project-specific actions.

CUSTOM PROJECT TYPE
In this part of the tutorial, we describe how to define a new custom project type including a project initialization (e.g. to add default content). The following diagram shows all components of a project type registration. The classes highlighted in dark grey are to be implemented for the extension.


The custom ProjectTypeDef implementation defines the actual project type. Therefore, it defines an ID, a name and some configuration options. As the ID is referenced from other classes, it is retrieved from a shared constant class MyConstants.
A custom ProjectCreateHandler is responsible for creating a new project of the custom type. As an example, it can create some default files on project creation.
ProjectCreateHandler is a subtype of ProjectHandler, other sub types, e.g. PostImportProjectHandler and ProjectInitHandler provide further hooks to configure projects.

Both, the custom ProjectTypeDef as well as the custom ProjectCreateHandler are bound by a GuiceModule to make them available for the Che Framework. Please note that all these components are part of a server plugin. Necessary adaptations within the IDE, e.g. the extension of the “New” menu are done automatically by Che.

As an example, we will describe in the following how to add a simple project type for managing JSON files, although in a real use case JSON files are usually embedded into other projects (e.g. a JavaScript project). We will also add a default initialization to the project type, which already creates a new JSON file in any created project.
As a first step, we implement a custom subclass of ProjectTypeDef (see code example below). Its constructor calls the default super constructor to define the ID and the name for the custom project type.
Further, it specifies with the remaining three boolean parameters:

primary=true: That the project can be a top-level project, meaning that it can be created on the root level of a workspace
mixin=false: That the project cannot be embedded into other projects (as sub-projects)
After specifying the project, we add a constant and a variable definition to the project type. Constants can not be changed, once they are defined and therefore contain static information about the project type. In our example, we add the information, that the project’s language is “json”. The first parameter specifies a key, the second a description of the Constant, and the third the corresponding value.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/projecttype/JsonExampleProjectType.java
Server-side: org.eclipse.che.plugin.jsonexample.projecttype.JsonExampleProjectType 
public class JsonExampleProjectType extends ProjectTypeDef {

  @Inject
  public JsonExampleProjectType() {
    super(JSON_EXAMPLE_PROJECT_TYPE_ID, "JSON Example", true, false);
    addConstantDefinition(LANGUAGE, LANGUAGE, JSON_EXAMPLE_PROJECT_TYPE_ID);
    addVariableDefinition("json-schema-ref", "Referenced base schema", /*required*/ true);
  }
}
Variables can be changed, e.g. to store values that the user enters on project creation. In the example, we define a custom variable to store a reference to a JSON schema. We will allow the user to set this variable in a custom project wizard in the corresponding part of this tutorial. You can define your own variables to store project specific properties. All String constants of the following code example are defined in a shared constant class, which is listed below.

che/samples/sample-plugin-json/che-sample-plugin-json-shared/src/main/java/org/eclipse/che/plugin/jsonexample/shared/Constants.java
org.eclipse.che.plugin.jsonexample.shared.Constants 
public final class Constants {

  /**
  * Language attribute name.
  */
  public static final String LANGUAGE             = "language";

  /**
  * Language attribute value.
  */
  public static final String JSON_EXAMPLE_LANG    = "json";

  /**
  * JSON Example Project Type ID.
  */
  public static final String JSON_EXAMPLE_PROJECT_TYPE_ID = "json-example";

  /**
  * JSON Example Category.
  */
  public static final String JSON_EXAMPLE_CATEGORY    = "JSON Example";

  /**
  * JSON Schema reference attribute name.
  */
  public static final String JSON_EXAMPLE_SCHEMA_REF_ATTRIBUTE = "json-schem-ref";

  private Constants() {

  }
}
To make our new project type available in Che, we need to register it using Guice. The following example code registers the JsonExampleProjectType from above as a ProjectTypeDef. Che will automatically pick up all bound ProjectTypeDefs. Please see our [Dependency Injection Basics] (doc:dependency-injection-basics) section for a general introduction of this mechanism.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/inject/JsonExampleGuiceModule.java
org.eclipse.che.plugin.jsonexample.inject.JsonExampleGuiceModule 
@DynaModule
public class JsonExampleGuiceModule extends AbstractModule {

  @Override
  protected void configure() {
    Multibinder<ProjectTypeDef> projectTypeDefMultibinder = newSetBinder(binder(),
    ProjectTypeDef.class);
    projectTypeDefMultibinder.addBinding().to(JsonExampleProjectType.class);
  }
}
By defining the new project type, Che will add a new entry in the “New” menu of the IDE and allow us to create a new and empty project:


Typical project types often need to be initialized with some default content, e.g. some files. This can be done by implementing a CreateProjectHandler (subtype of ProjectHandler). In the method #onProjectCreate, you can access the base folder, as well as the attributes and options of the project.

In the following example, we will create the following files: a "person.json" file with some default content that will be stored in a folder named "myJsonFiles" as well as a "package.json" file, which we’ll need later on. The method #getProjectType needs to provide the project type ID to allow Che to map the ProjectHandler to the correct type.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/inject/JsonExampleGuiceModule.java
org.eclipse.che.plugin.jsonexample.generator.JsonExampleProjectGenerator 
public class JsonExampleCreateProjectHandler implements CreateProjectHandler {

  private static final String FILE_NAME = "package.json";

  @Override
  public void onCreateProject(FolderEntry baseFolder, 
                              Map<String, AttributeValue> attributes,
                              Map<String, String> options) throws /.../ 
  {
    InputStream packageJson = null;
    InputStream personJson = null;
    try {
      FolderEntry myJsonFiles = baseFolder.createFolder("myJsonFiles");
      packageJson = getClass().getClassLoader()
                .getResourceAsStream("files/default_package");
      personJson = getClass().getClassLoader()
                .getResourceAsStream("files/default_person");
      baseFolder.createFile(FILE_NAME, packageJson);
      myJsonFiles.createFile("person.json", personJson);
    } finally {
      Closeables.closeQuietly(packageJson);
      Closeables.closeQuietly(personJson);
    }
  }

  @Override
  public String getProjectType() {
    return Constants.JSON_EXAMPLE_PROJECT_TYPE_ID;
  }
}
Finally, the ProjectHandler needs to be bound using Guice just as the project type was bound before:

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/inject/JsonExampleGuiceModule.java
org.eclipse.che.plugin.jsonexample.inject.JsonExampleGuiceModule 

/...
Multibinder<ProjectHandler> projectHandlerMultibinder = newSetBinder(binder(), 
     ProjectHandler.class);
projectHandlerMultibinder.addBinding().to(JsonExampleCreateProjectHandler.class);
/...
Once the ProjectHandler has been added and executed, the example project will already contain the files in the IDE:


PROJECT CREATION WIZARD
Project creation wizards are executed once the user creates a new project. They allow you to enter general properties (such as a name and a description), but also project-specific properties (e.g. a compiler option, a project dependency, etc.). Without providing a specific project creation wizard, Che already allows you to enter the general properties available for all projects as shown in the following screenshot for the JSON example project type we have defined in the previous section of the tutorial:


In this section, we will describe how to extend the default project creation wizard with a new page allowing it to enter an additional property. As part of the JSON example, we will allow the user to enter the URL of a JSON Schema. We will later use the schema to validate JSON files on the server.
Therefore, we will add a new page to the JSON project creation wizard allowing to enter the schema url property:


This page serves as a simple example, it can be adapted for any other project specific property.

The following diagram shows all components for the extension of the project wizard. The classes highlighted in dark grey are to be implemented for the project wizards extension.


Before we look at the detailed implementations, we will first give an overview of all participating components.
As a first step, we need to implement a ProjectWizardRegistrar. It holds a set of AbstractWizardPages. These pages are added to the default wizard and displayed during project creation. Our implementation of a ProjectWizardRegistrar is in JsonExampleProjectWizardRegistrar and contributes one wizard page (see its method #getWizardPages) which will contain exactly one field for entering a JSON schema URL.

The page itself is implemented in SchemaUrlWizardPage. To actually display a UI, it configures a GWT view defined in SchemaUrlPageViewImpl and its corresponding SchemaUrlPageViewImpl.ui.xml. Furthermore, the wizard page will create and configure a handler for URL changes called SchemaUrlChangedDelegate.

Now all required classes are set up and the actual runtime behavior can be performed. Whenever the user performs a change in the textbox for the schema URL, GWT will trigger the method #onSchemaUrlChanged in SchemaUrlPageViewImpl since it is annotated as a handler for changes on this textbox. The method will then notify the SchemaUrlChangedDelegate. The SchemaUrlChangedDelegate will in turn write the changed URL into a ProjectConfigDto owned by the SchemaUrlWizardPage.

Finally, to wire everything up with Gin, all we need to do is to define a module to register our class JsonExampleProjectWizardRegistrar as an implementation of ProjectWizardRegistrar:

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/inject/JsonExampleModule.java
org.eclipse.che.plugin.jsonexample.ide.inject.JsonExampleModule
@ExtensionGinModule
public class JsonExampleModule extends AbstractGinModule {

  @Override
  protected void configure() {
      GinMultibinder
              .newSetBinder(binder(), ProjectWizardRegistrar.class)
              .addBinding()
              .to(JsonExampleProjectWizardRegistrar.class);
       }
      //... 
}

Now let us look at the implementation of all required classes in more detail.
The JsonExampleProjectWizardRegistrar is responsible for setting up the SchemaUrlWizardPage as one of its wizard pages. To do this, it requests a provider for a SchemaUrlWizardPage injected in its constructor. The provider is just a wrapper around the actual wizard page which is required by the Che framework. In the method #getWizardPages we can then just return a list of providers for wizard pages containing only the injected provider.

In addition to setting up the wizard page we need to declare the project type and category for which the project wizard is responsible for.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/JsonExampleProjectWizardRegistrar.java
org.eclipse.che.plugin.jsonexample.ide.project.JsonExampleProjectWizardRegistrar 
public class JsonExampleProjectWizardRegistrar implements ProjectWizardRegistrar {
  private final List<Provider<? extends WizardPage<ProjectConfigDto>>> wizardPages;

  @Inject
  public JsonExampleProjectWizardRegistrar(
         Provider<SchemaUrlWizardPage> wizardPage) {
    wizardPages = new ArrayList<>();
    wizardPages.add(provider);
  }

  @NotNull
  public String getProjectTypeId() {
    return Constants.JSON_EXAMPLE_PROJECT_TYPE_ID;
  }

  @NotNull
  public String getCategory() {
    return JSON_EXAMPLE_CATEGORY;
  }

  @NotNull
  public List<Provider<? extends WizardPage<ProjectConfigDto>>> getWizardPages()  {
    return wizardPages;
  }
}
The SchemaUrlWizardPage class defines the actual wizard page for entering a schema URL. In the constructor it requires the injection of a view for displaying the UI of the page called SchemaUrlPageViewImpl. In the method #go, which is called when the page is about to be displayed, it will set this view as the only widget on the page and pass a new SchemaUrlChangedDelegate to the view. The view will later use this delegate to trigger changes on the page's ProjectConfigDto whenever something is entered into the schema URL text box on the view.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlWizardPage.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlWizardPage 
public class SchemaUrlWizardPage extends AbstractWizardPage<ProjectConfigDto> {

  private final SchemaUrlChangedDelegate view;

  @Inject
  public SchemaUrlWizardPage(SchemaUrlPageViewImpl view) {
    this.view = view;
  }

  @Override
  public void go(AcceptsOneWidget container) {
    container.setWidget(view);
    view.setDelegate(new SchemaUrlChangedDelegate (this.dataObject));   
  }

}

The SchemaUrlChangedDelegate receives a ProjectConfigDto in its constructor which holds all the values that are defined during project creation including the schema URL. Whenever its #schemaUrlChanged method is fired, it will write the new value into the ProjectConfigDto.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlChangedDelegate.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlChangedDelegate   
public class SchemaUrlChangedDelegate {

  private ProjectConfigDto dataObject;

  public SchemaUrlChangedDelegate(ProjectConfigDto dataObject) {
    this.dataObject = dataObject;
  }

  public void schemaUrlChanged(String value) {
    dataObject.getAttributes().put("json-schema-ref", 
           Collections.singletonList(value));
  }
}

SchemaUrlPageView is just a marker interface required by the framework to declare that our SchemaUrlPageViewImpl is an implementation of a view with a SchemaUrlChangedDelegate.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlPageView.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlPageView   
public interface SchemaUrlPageView extends View<SchemaUrlChangedDelegate> {}
SchemaUrlPageViewImpl is the class which will actually create the UI with a TextBox for entering the schema URL. It is a GWT Composite with its contents defined in SchemaUrlPageViewImpl.ui.xml.
To receive all changes of the schema URL in the UI it declares a method #onSchemaUrlChanged with an annotation @UiHandler("schemaUrl"). This annotation defines that the method is to be called whenever the text in the schemaUrl text box as defined in SchemaUrlPageViewImpl.ui.xml is changed.
The method will just forward any call to the SchemaUrlChangedDelegate which was configured earlier by the SchemaUrlWizardPage.
In its constructor the view gets a JsonExamplePageViewUiBinder injected which is used to create and bind the UI defined in SchemaUrlPageViewImpl.ui.xml.
This requires you to define JsonExamplePageViewUiBinder as a marker interface extending UiBinder<DockLayoutPanel, SchemaUrlPageViewImpl>.

More about declarative UIs with GWT UI binder can be found on the GWT homepage.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlPageViewImpl.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlPageViewImpl
class SchemaUrlPageViewImpl extends Composite implements SchemaUrlPageView {

  interface JsonExamplePageViewUiBinder extends UiBinder<DockLayoutPanel, SchemaUrlPageViewImpl> {
  }

  @UiField
  TextBox schemaUrl;

  private SchemaUrlChangedDelegate delegate;

  @Inject
  public SchemaUrlPageViewImpl(JsonExamplePageViewUiBinder uiBinder) {
    initWidget(uiBinder.createAndBindUi(this));
  }

  /** {@inheritDoc} */
  @Override
  public void setDelegate(SchemaUrlChangedDelegate delegate) {
    this.delegate = delegate;
  }

  @UiHandler("schemaUrl")
  void onSchemaUrlChanged(KeyUpEvent event) {
    delegate.schemaUrlChanged(schemaUrl.getValue());
  }
}
che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlPageViewImpl.ui.xml
SchemaUrlPageViewImpl.ui.xml
<ui:UiBinder xmlns:ui='urn:ui:com.google.gwt.uibinder'
          xmlns:g='urn:import:com.google.gwt.user.client.ui'
          xmlns:ide='urn:import:org.eclipse.che.ide.ui'>
  <g:DockLayoutPanel unit="PX" >
      <g:north size="200">
          <g:FlowPanel ui:field="panel">
              <g:FlowPanel height="90px" >
                  <g:Label text="JSON Schema URL" />
                  <ide:TextBox ui:field="schemaUrl"
                              tabIndex="0"
                              debugId="file-createProject-schemaUrl"/>
                  <g:Label ui:field="labelUrlError" width="100%"    wordWrap="true"/>
              </g:FlowPanel>
          </g:FlowPanel>
      </g:north>
  </g:DockLayoutPanel>
</ui:UiBinder>
By adapting the SchemaUrlPageViewImpl.ui.xml you can customize the layout of the final wizard page. The example page will look like this:


PROJECT-SPECIFIC ACTIONS
Actions allow you to add custom behavior to the Che IDE. They can be placed in menus, toolbars or context menus. Some actions shall only be available on a specific project type. In the JSON example, we place two actions in the context menu of the defined project type. The screenshot shows a project-specific HelloWorldAction, as well as another project specific action implemented in the section Server/Workspace Access.


Please see the general section Actions how to define actions and the section Project/Perspective-specific Actions for a more detailled description on how the actions for the JSON project type are defined.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Actions
Actions
Action API

Actions allow you to add custom behavior to the Che IDE. They can be placed in menus, toolbars or context menus. An Action is a Java class, which implements the behavior to be executed. Additionally, it defines a text to be shown, a tooltip and an icon. In the following section, we describe the implementation of Actions more in detail.
To make Actions available in the Che IDE, they need to be registered and placed into ActionGroups. Thereby, you specify the location (e.g. a menu or toolbar), where the actions is shown. The registration of actions is described in the subsequent section Registering Actions.

AUTHORING ACTIONS
Simple Actions directly inherit from org.eclipse.che.ide.api.action.Action. In the constructor, we use the super class to configure our action with the following parameters:

text (String): The name of the action shown in the UI, in our case defined by concrete Actions (sub classes).
Optional: description (String): The description of the action shown in the UI, in our case defined by concrete Actions (sub classes).
In the example action below, the constructor also gets the NotificationManager injected, which is used to display a "Hello World" message.
A custom Action need to implement the #actionPerformed method, which is called when it is invoked. Actions can be associated with a variety of triggers within the system such as buttons, menu item selections, or user input (see following section).

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/action/HelloWorld.java
@Singleton
public class HelloWorldAction extends Action {

  private NotificationManager notificationManager;

  @Inject
  public HelloWorldAction(NotificationManager notificationManager) {
      super("Say Hello World", "Say Hello World Action");
      this.notificationManager = notificationManager;
  }

  @Override
  public void actionPerformed(ActionEvent e) {
      this.notificationManager.notify("Hello World", StatusNotification.Status.SUCCESS,                       StatusNotification.DisplayMode.FLOAT_MODE);
  }
}
Additionally, you can optionally define an icon for an Action. This is done by calling an alternative constructor including the following two parameters:

imageResource: An icon for the action shown in the UI, in our case defined by concrete Actions, we pass in null, as we alternatively use svgResource.
svgResource (SVGResource): An Icon for the the action shown in the UI, in our case defined by concrete Actions (sub classes).
The following code example defines another "Hello World" action including a corresponding icon:

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/action/HelloWorldActionWithIcon.java
@Singleton
public class HelloWorldActionWithIcon extends Action {

    private NotificationManager notificationManager;

    @Inject
    public HelloWorldActionWithIcon(
            NotificationManager notificationManager) {
        super("Say Hello World", "Say Hello World Action", null, SampleActionsResources.INSTANCE.icon());
        this.notificationManager = notificationManager;
    }

    /...
}
REGISTERING ACTIONS
Once we have implemented a custom action, we must register it. This is done in the custom Extension class , which is used for other extensions, too (see Dependency Injection Basics ).

As a first step, we register the HelloWorldAction itself at the ActionManager. Thereby, Che is aware of the action to be executed. Along with the registration, an action must be associated with a unique ID, which allows to reference the Action.

Second, to define a place in the IDE where the Action is visible to the user, we place the Action in an existing ActionGroup. Actions are organized into groups, which, in turn, can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of the group can form submenus of the menu. You can directly place an Action into an existing group. Alternatively, you can create a custom group containing your action and add this group into Che.
In the following example, a custom group is created (SampleGroup), the HelloWorldAction is added to it and the Group is placed in the main menu of Che.
Additionally, the HelloWorldActionWithIcon is directly placed into the main menu.
Please see the following section on more details about existing action locations (i.e. groups) in Che and how to specify the order of actions within those groups.

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/SampleActionsExtensions.java
@Extension(title = "Sample Actions Extension", version = "1.0.0")
public class SampleActionsExtensions { 
    @Inject 
    public SampleActionsExtensions(HelloWorldAction helloWorldAction, ActionManager actionManager) { 
      
      actionManager.registerAction("helloWorldAction", helloWorldAction);
      actionManager.registerAction("helloWorldActionWithIcon", helloWorldActionWithIcon);
      /...
        
      DefaultActionGroup sampleGroup = new DefaultActionGroup("Sample actions", true, actionManager);

      sampleGroup.add(helloWorldAction);
      
      // add sample group after help menu entry
      DefaultActionGroup mainMenu = (DefaultActionGroup)actionManager.getAction(GROUP_MAIN_MENU);
        mainMenu.add(sampleGroup);
      
      // add the sample group to the beginning of the toolbar as well
      DefaultActionGroup toolbar = (DefaultActionGroup)actionManager.getAction(IdeActions.GROUP_MAIN_TOOLBAR);
      toolbar.add(helloWorldActionWithIcon);
      /...
    }
}
ACTION LOCATIONS
In this section, we describe more in detail, how actions can be placed at specific locations within Che and how the order within toolbars and menus can be specified. Both, the location and the order is specified along with the registration of an action.

Every action and action group in Che has a unique identifier. This allows to reference existing groups and actions when registering a new element and thereby specify its location. In the example registration in the previous section, we have used the ID of the Che main menu to place our custom action group and action in it. All existing identifiers for existing che action groups can be found in org.eclipse.che.ide.api.action.IdeActions.
Additionally, you can find a collection of examples within the example extension for actions (che/samples/sample-plugin-actions/che-sample-plugin-actions-ide).

In addition to placing actions in groups, you can define a relative order for actions and groups within their parent container. Therefore, a constraint needs to be specified when adding an element to a group. The constraint defines an anchor (ID of an existing element) and a relation to it (BEFORE or AFTER). Alternatively, you can use Constraints.FIRST and Constraints.LAST (default) to add an element at the beginning or at the end, respectively.

The following code example shows the registration of the group containing HelloWorldAction after the existing help menu, as well as the action itself at the beginning of the main toolbar.

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/SampleActionsExtensions.java
DefaultActionGroup sampleGroup = new DefaultActionGroup("Sample actions", true, actionManager);
sampleGroup.add(helloWorldAction);

// add sample group after help menu entry
DefaultActionGroup mainMenu = (DefaultActionGroup)actionManager.getAction(GROUP_MAIN_MENU);
mainMenu.add(sampleGroup, new Constraints(AFTER, GROUP_HELP));

// add the sample group to the beginning of the toolbar as well
DefaultActionGroup toolbar = (DefaultActionGroup)actionManager.getAction(IdeActions.GROUP_MAIN_TOOLBAR);
toolbar.add(helloWorldActionWithIcon, Constraints.FIRST);
VISIBILITY AND ENABLEMENT
By default, actions will always be visible to the user and enabled. However, certain actions shall only be visible or enabled based on the current state of Che. The implementation of an action is responsible for managing its visibility and enabled state.

Therefore, you need to implement the method Action.update() in a custom action. The method is periodically called by the IDE for updating the state. The object of type ActionEvent passed to this method carries the information about the current context for the action, e.g. the current perspective of the current selection. Additional information about the current state of the IDE can be retrieved form the service AppContext (see here for an example).

The ActionEvent allows access to the specific presentation which needs to be updated. As every action can be included in multiple groups and appear in multiple places within the IDE user interface, the visibility and enabled state can not centrally be controlled for an action. For every place where the action appears, a new Presentation is created on which the visibility and enabled state is set alternatively. Please note, that the ActionEvent instance is also passed to the actionPerformed() method, when the action is executed.

The following example shows the OnProjectHelloWorldAction, which is placed in the main menu of Che. It controls its visibility based on the state and is only visible if a project is selected in the navigator.

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/action/OnProjectHelloWorldAction.java
public class OnProjectHelloWorldAction extends Action {

    private AppContext appContext;
    private final NotificationManager notificationManager;

    /**
     * Constructor.
     * @param appContext
     *           the application context
     * @param notificationManager
     *           the notification manager
     */
    @Inject
    public OnProjectHelloWorldAction(
            final AppContext appContext,
            final NotificationManager notificationManager) {
        super("Project specific Hello World", "We have a project");
        this.appContext = appContext;
        this.notificationManager = notificationManager;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        this.notificationManager.notify(
                "Hello World in the context of a project",
                StatusNotification.Status.SUCCESS,
                StatusNotification.DisplayMode.FLOAT_MODE);
    }

    @Override
    public void update(ActionEvent e) {
        e.getPresentation().setEnabledAndVisible(appContext.getRootProject() != null);
    }
}
REUSABLE ACTIONS
For common operations such as creating files, Che provides reusable default actions. Custom implementations can inherit from those and thereby only need to specify their specifics, while reusing most of the default behavior. In this section, we provide an overview of the most common reusable actions in Che.

Create File Actions
Che provides a template implementation for actions to create new resources (i.e. files). When using the template, you only need to specify the name of the action as well as the file extension to be created (as shown in the following code example).

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/action/CreateMyFileAction.java
org.eclipse.che.plugin.myextension.ide.action.CreateMyFileAction 
public class CreateMyFileAction extends AbstractNewResourceAction {

  @Inject
  public CreateMyFileAction(MyResources myResources) {
    super("Create my File", "Create a new file ", myResources.icon());
  }

  @Override
  protected String getExtension() {
    return "my";
  }
}
PROJECT/PERSPECTIVE-SPECIFIC ACTIONS (JSON EXAMPLE)
In this part of the tutorial, as part of the JSON example we describe how to add project- and perspective-specific actions, meaning actions that are only available for a specific project type and within specific perspectives. As we want to define several actions of this type, we will create a template implementation and then inherit from it for the implementation of several actions.

These example actions will be placed in the context menu on the specific JSON project type defined before. The following diagram shows all components of a project type registration. The classes highlighted in dark grey are to be implemented for the extension.

First, our actions must determine whether they are available based on the current app context, in our case, based on the current project type. As we want to add several project specific actions, it makes sense to extract this behavior into an abstract class, in our case MyAbstractProjectSpecificAction. By inheriting from this abstract base class, we can now easily add project specific actions implementing the actual behavior to be executed.

As described before, to make an action available in Che, it needs to be registered at the ActionManager. This is done in an Extension.


In the following example, we first define the perspective- and project specific template action. Then, we define a simple action for the JSON example and register it in the context menu of the JSON project type. The action itself will trigger a simple notification once executed. However, the action could be adapted to execute any kind of behavior.

To make our abstract template action perspective-specific, we inherit from a reusable action implementation AbstractPerspectiveAction provided by Che. Compared to the basic Action its constructor allows the definition of a list of perspectives, in which the action is visible, referenced by ID. Null or empty list means the action is enabled everywhere. In the example, the project perspective, only.

The constructor also gets the AppContext injected, which is used in the following to control the project-specific visiblity of the action (see description below).

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/JsonExampleProjectAction.java
org.eclipse.che.plug.plugin.jsonexample.ide.action.JsonExampleProjectAction
public abstract class JsonExampleProjectAction extends AbstractPerspectiveAction {

  private AppContext appContext;

  public JsonExampleProjectAction(AppContext appContext,
                                  @NotNull String text,
                                  @NotNull String description,
                                  @Nullable SVGResource svgResource) {
    
    super(Collections.singletonList(ProjectPerspective.PROJECT_PERSPECTIVE_ID),
              text,
              description,
              null,
              svgResource);
    this.appContext = appContext;
  }

  @Override
  public void updateInPerspective(@NotNull ActionEvent event) {
    CurrentProject currentProject = appContext.getCurrentProject();
    event.getPresentation().setEnabledAndVisible(
                  isJsonExampleProjectType(currentProject));
  }

  private static boolean isJsonExampleProjectType(CurrentProject currentProject)  {
    if (currentProject == null) {
      return false;
    }
    return Constants.JSON_EXAMPLE_PROJECT_TYPE_ID.equals(
              currentProject.getProjectConfig().getType());
  }
  
}

The #updateInPerspective method is responsible for updating the enablement and the visibility of the action. In this example, we only want to show the action, if the current project is a JSON project. Therefore, we retrieve the current project from the AppContext, check whether there is a current project and if so, whether it has the expected project type.
Calling event.getPresentation().setEnabledAndVisible(true/false) will set the enablement and the visibility accordingly.

After defining a project specific action, we can now define an arbitrary number of concrete implementations to add custom behavior. The example below inherits from our JsonExampleProjectAction and uses the super constructor to configure the specificity of the action. Further, the constructor gets the NotificationManager injected, which is used in the implementation of the action below. The method #actionPerformed will be called once the user has clicked on an action.

In the example, we trigger a simple notification. However, this simple behavior could be replaced with any custom operation.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/HelloWorldAction.java
org.eclipse.che.plug.plugin.jsonexample.ide.action.HelloAction
@Singleton
public class HelloWorldAction extends JsonExampleProjectAction {

  private NotificationManager notificationManager;

  @Inject
  public HelloWorldAction(AppContext appContext,
                          NotificationManager notificationManager) {
        super(appContext,
              "Say Hello World",
              "Say Hello World Action",
              null);
        this.notificationManager = notificationManager;
  }


   @Override
  public void actionPerformed(ActionEvent e) {
        this.notificationManager.notify(
              "Hello World",
              StatusNotification.Status.SUCCESS,
              StatusNotification.DisplayMode.FLOAT_MODE
        );
  }
}
Once we have implemented a custom action, we must register it. This is done in the custom extension class JsonExampleExtension, which has been used for other extensions before (see Dependency Injection Basics ).

To keep all JSON example related actions together, we define a new ActionGroup called “JSON Example”. The second parameter defines that the group is displayed as a popup. After registering the new group at the ActionManager, we add our custom HelloWorldAction to it.

To define a place in the IDE where the Action is visible to the user, we further place the Action in an existing ActionGroup, in our case, the context menu of a project.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/JsonExampleExtension.java
org.eclipse.che.plugin.jsonexample.ide.JsonExampleExtension
@Extension(title = "JSON Example Extension", version = "0.0.1")
public class JsonExampleExtension {
  @Inject
  public JsonExampleExtension(
          ActionManager actionManager,
          HelloWorldAction helloWorldAction,
          JsonExampleResources jsonExampleResources,
          IconRegistry iconRegistry) {

    actionManager.registerAction("helloWorldAction", helloWorldAction);

    DefaultActionGroup jsonGroup = new DefaultActionGroup("JSON Example", 
         true, actionManager);
    actionManager.registerAction("jsonExample", jsonGroup);
    jsonGroup.add(helloWorldAction);

    DefaultActionGroup mainContextMenuGroup = (DefaultActionGroup) actionManager.getAction("resourceOperation");
    mainContextMenuGroup.add(jsonGroup);
      
  }
}

Finally, we can open the context menu on our custom project type and trigger the example action, the screenshot show the HelloWorldAction, as well as another project specific action defined in the section Server/Workspace Access.


FURTHER EXAMPLE ACTIONS
In this section, we provide a collection of existing example actions to demonstrate the variety of possible locations and behavior to be executed.

The following example creates a RedirectToDashboardWorkspacesAction which is the behavior that redirects the IDE back into the user dashboard application.

https://github.com/eclipse/che/blob/master/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/actions/RedirectToDashboardWorkspacesAction.java
package org.eclipse.che.ide.actions;

import com.google.gwt.user.client.Window;
import com.google.inject.Inject;

import org.eclipse.che.ide.CoreLocalizationConstant;
import org.eclipse.che.ide.api.action.Action;
import org.eclipse.che.ide.api.action.ActionEvent;

public class RedirectToDashboardWorkspacesAction extends Action {

    private static final String REDIRECT_URL = "/dashboard/#/workspaces";

    @Inject
    public RedirectToDashboardWorkspacesAction(CoreLocalizationConstant localization) {
        super(localization.actionRedirectToDashboardWorkspacesTitle(),
              localization.actionRedirectToDashboardWorkspacesDescription(), 
              null, 
              null);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Window.open(REDIRECT_URL, "_blank", "");
    }
}
The following example (from the JSON example) executes a server call to retrieve and display the number of lines of code from all JSON files within a project:

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/CountLinesAction.java
/**
 * Action for counting lines of code of all JSON files within the current project.
 * Line counting is implemented by consuming a RESTful service.
 */
@Singleton
public class CountLinesAction extends JsonExampleProjectAction {

    private final AppContext            appContext;
    private final StringMapUnmarshaller unmarshaller;
    private final AsyncRequestFactory   asyncRequestFactory;
    private final NotificationManager   notificationManager;

    /**
     * Constructor
     *
     * @param appContext
     *         the IDE application context
     * @param resources
     *         the JSON Example resources that contain the action icon
     * @param asyncRequestFactory
     *         asynchronous request factory for creating the server request
     * @param notificationManager
     *         the notification manager used to display the lines of code per file
     */
    @Inject
    public CountLinesAction(AppContext appContext,
                            JsonExampleResources resources,
                            AsyncRequestFactory asyncRequestFactory,
                            NotificationManager notificationManager) {

        super(appContext,
              "Count JSON Lines of Code",
              "Counts lines of code for all JSON Files in the project",
              resources.icon());

        this.appContext = appContext;
        this.asyncRequestFactory = asyncRequestFactory;
        this.notificationManager = notificationManager;
        this.unmarshaller = new StringMapUnmarshaller();
    }

    @Override
    public void actionPerformed(ActionEvent e) {

      String url = this.appContext.getDevMachine().getWsAgentBaseUrl() + "/json-example/" + this.appContext.getWorkspaceId() +
this.appContext.getCurrentProject().getRootProject().getPath();

      asyncRequestFactory.createGetRequest(url, false).send(
        new AsyncRequestCallback<Map<String, String>>(unmarshaller) {
          
        @Override
        protected void onSuccess(Map<String, String> linesPerFile) {
          for (Map.Entry<String, String> entry : linesPerFile.entrySet()) {
            String fileName = entry.getKey();
            String loc = entry.getValue();
            notificationManager.notify("File " + fileName + " has " + loc + " lines.", StatusNotification.Status.SUCCESS,                                   StatusNotification.DisplayMode.FLOAT_MODE);
          }
         }

         @Override
         protected void onFailure(Throwable exception) {
          notificationManager.notify(exception.getMessage(), StatusNotification.Status.FAIL, StatusNotification.DisplayMode.FLOAT_MODE);
         }
       });
    }
}
The following example shows how Che registers all of the actions for the Git menu.

https://github.com/eclipse/che/blob/master/plugins/plugin-git/che-plugin-git-ext-git/src/main/java/org/eclipse/che/ide/ext/git/client/GitExtension.java
DefaultActionGroup git = new DefaultActionGroup(GIT_GROUP_MAIN_MENU, true, actionManager);
actionManager.registerAction("git", git);
mainMenu.add(git, new Constraints(BEFORE, GROUP_HELP));

DefaultActionGroup commandGroup = new DefaultActionGroup(COMMAND_GROUP_MAIN_MENU, false, actionManager);
actionManager.registerAction("gitCommandGroup", commandGroup);
git.add(commandGroup);
git.addSeparator();



\\\\\\\\\\\\\\\\\\\\\\\\\\\Services
Services
Many simple extensions to Che are directly implemented in the IDE running in the browser. This has the advantage that the execution of simple actions do not require any server round-trips and are therefore typically very fast.
However, more complex operations, especially when accessing resources from a project or the workspace require you to run on the server or within the workspace. Examples for such operations are validating files, compiling code, providing auto-completion or creating workspaces. All those operations are implemented as REST services and can be consumed by the client IDE.

Services can either be deployed on the server or directly in a workspace. Server services provide generic features which are not depending on the Workspace or its content, e.g. user management. Workspace services can access the contents of a project (e.g. source files) and also trigger operations in the workspace (such as compilation).
In the following, we will describe how to create server and workspace services and how they are consumed from the client IDE. As the specification of workspace services is a special case of specifying server services, we will start with a simple server service, including an introduction of general basics about services.
Based on that, in the subsequent section “Workspace Services”, we will describe a more complex example, which accesses the files of a specific project.
Server and Workspace services need to be deployed differently, please refer to the section Create and build extensions to learn how.

SERVER SERVICES
The following diagram shows all components of server services. The classes highlighted in dark grey are to be implemented for the extension. The ServerService offers a REST service to be consumed.
The IDE plugin implements a client class (MyClient), which calls the REST service using Che helper classes. The result is made available by a Java API, which is to be defined based on the result type. By calling the client class, different components of the IDE, such as Actions or CodeCompletionProcessors, can consume the ServerService without having to deal with the REST API itself.


In the following, we will describe how to build a simple example server service that accepts a String {name} and responds with "Hello {name} !".
Further, we will demonstrate how this service can be consumed from within the client IDE.

Every REST service defines the path under which it is reachable. In the following code example, the path consists of two parts. The first one identifies the service itself and is specified with the @Path annotation of the class itself, in this case “hello”.
The second part of the path defines a parameter for the @GET method to be called and is specified with the @Path annotation at the method #sayHello itself, in this case “name”.
In combination, this example will register a service that will listen to localhost:8080/api/hello/{name}, where {name} is an arbitrary String to be passed by the client.
As specified using the @PathParam annotation, the {name} parameter will be passed as an input and then be used in the return statement.

che/samples/sample-serverservice/che-sample-plugin-serverservice-server/src/main/java/org/eclipse/che/plugin/serverservice/MyService.java
@Path("hello")
public class MyService {
    
  @GET
  @Path("{name}")
  public String sayHello(@PathParam("name") String name) {
    return "Hello " + name + " !";
  }
}
To make the server service consumable within the IDE, we implement a client encapsulating the REST call (see following code example).
Therefore, the client will offer a method #getHello, which can be called by any IDE component with a parameter “name”. To send an asynchronous REST request, the client uses two Che utilities, the AsyncRequestFactory and the LoaderFactory, which both get injected into the constructor.

The AsyncRequestFactory simplifies the creation of REST calls by providing a method #createGetRequest which will create a request using the provided parameter as a path. It will automatically prefix this path with the current server URL used by the IDE, so the parameter “hello” would be bound to http://serveradress/hello.

The request is sent by passing in an Unmarshaller. It is responsible for unmarshalling the response from the transport format (JSON) to a Java type, e.g. a String. Che already provides a collection of Unmarshallers, please see the section Calling Workspace APIs for details.

Finally, the send method returns a Promise, which can be consumed by callers on MyClient (see below) to retrieve the answer from the server.

che/samples/sample-serverservice/che-sample-plugin-serverservice-ide/src/main/java/org/eclipse/che/plugin/serverservice/ide/MyServiceClient.java
/che-ide-extension/src/main/java/examples/MyServiceClient.java
public class MyServiceClient {
    private final AsyncRequestFactory asyncRequestFactory;
    private final String helloPath;
    private final LoaderFactory loaderFactory;

    @Inject
    public MyServiceClient(AsyncRequestFactory asyncRequestFactory,
                           LoaderFactory loaderFactory) {
      this.asyncRequestFactory = asyncRequestFactory;
      this.loaderFactory = loaderFactory;
    }

    //Can be invoked by consumers
    public Promise<String> getHello(String name) {
      return asyncRequestFactory.createGetRequest(“hello” + "/" + name)
          .loader(loaderFactory.newLoader("Waiting for hello..."))
          .send(new StringUnmarshaller());
    }

}
Now, MyClient can be consumed from any other component in the IDE without having to deal with the REST call itself.
The following example action gets the MyServiceClient injected and calls the #getHello method to retrieve the Promise.
On the Promise you can pass in an operation to be executed if the server call has been successful using the #then method. As we have used a StringUnmarshaller before, the parameter will be the String created by the server service.
In the example, it is passed to the Che NotificationManager. Using the #catchError method on the Promise, you can define an operation to be executed on an error during the server call.

che/samples/sample-serverservice/che-sample-plugin-serverservice-ide/src/main/java/org/eclipse/che/plugin/serverservice/ide/action/MyAction.java

public class MyAction extends Action {

    private final NotificationManager notificationManager;
    private final MyServiceClient serviceClient;

    @Inject
    public MyAction(MyResources resources, NotificationManager
                    notificationManager, MyServiceClient serviceClient) {
      
      super("My Action", "My Action Description", null, 
            resources.MyProjectTypeIcon());
      this.notificationManager = notificationManager;
      this.serviceClient = serviceClient;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        // This calls the service in the workspace.
        // This method is in our MyServiceClient class
        // This is a Promise, so the .then() method is invoked after the response is made
        
      serviceClient.getHello("CheTheAllPowerful!").then(new Operation<String>()
      {
        
        @Override
        public void apply(String arg) throws OperationException {
          // This passes the response String to the notification manager.
          notificationManager.notify(arg, StatusNotification.Status.SUCCESS, StatusNotification.DisplayMode.FLOAT_MODE);
        }
        
       }).catchError(new Operation<PromiseError>() {
       
          @Override
          public void apply(PromiseError arg) throws OperationException {
            notificationManager.notify("Fail", StatusNotification.Status.FAIL, StatusNotification.DisplayMode.FLOAT_MODE);
          }
        
       });
    }

WORKSPACE SERVICES
Workspace services are special types of server services, they are deployed directly within the workspace agent. Therefore, they can access the content of a workspace, e.g. projects, source files, etc. Furthermore, they can trigger native operations in the running workspace.
Besides their different scope, workspace services are developed like standard server services using REST. Therefore, we recommend to first cover the previous section about server services. The main difference between workspace and server services is where they are actually deployed to. Please refer to the section Create and build extensions to learn how to deploy services correctly.

In the following, we describe an example workspace service from the JSON example, which accesses a selected project and counts the number of lines in all JSON files. This demonstrates how to access files and their content. In a custom use case, this could be adapted to do any kind of file operation, e.g. parsing contents for auto completion. After introducing the service, we demonstrate how it can be consumed by an action from within the IDE.

Like a server service, workspace services need to define the path in which they are reachable at. As they are running for a specific workspace, the path includes the variable {ws-id}, which identifies the workspace the service is running in (see @Path annotation in the following code example). The example service gets the Che ProjectManager injected in the constructor. It allows to access projects and their contents. Please note that this service is not available for server services.

The method #countLinesPerFile receives a projectPath as a parameter for which it should count the number of lines. It uses the ProjectManager to retrieve the project. Using the project, it then navigates over all JSON files in the project and accesses the contents of those files to count the lines. Finally, it returns the result as a map.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/JsonLocService.java
org.eclipse.che.plugin.jsonexample.JsonLocService
@Path("json-example/{ws-id}")
public class JsonLocService {

  private ProjectManager projectManager;

  @Inject
  public JsonLocService(ProjectManager projectManager) {
    this.projectManager = projectManager;
  }

  
  @GET
  @Path("{projectPath}")
  public Map<String, String> countLinesPerFile(
         @PathParam("projectPath") String projectPath)
          throws ServerException, NotFoundException, ForbiddenException {
    
    Map<String, String> linesPerFile = new LinkedHashMap<>();
    RegisteredProject project = projectManager.getProject(projectPath);

    for (FileEntry child : project.getBaseFolder().getChildFiles()) {
      if (isJsonFile(child)) {
        linesPerFile.put(child.getName(), Integer.toString(countLines(child)));
      }
    }
    
    return linesPerFile;
  }

  private static int countLines(FileEntry fileEntry) 
         throws ServerException, ForbiddenException {
    String content = fileEntry.getVirtualFile().getContentAsString();
    String[] lines = content.split("\r\n|\r|\n");
    return lines.length;
  }

  private static boolean isJsonFile(FileEntry fileEntry) {
    return fileEntry.getName().endsWith("json");
  }

}
To access workspace services on the client-side, the path needs to include the workspace ID as well as the project ID. Both can be retrieved using the AppContext. Furthermore, all services running within the workspace have a basic context path which can be retrieved from the AppContext.

The following example creates a path, which would access the service above with the current project as a parameter:

Java
String url = this.appContext.getDevMachine().getWsAgentBaseUrl() 
  + "/json-example/"
  + appContext.getWorkspaceId()
  + appContext.getCurrentProject().getProjectConfig().getPath();
Besides the specific path, workspace services can be consumed like any other server service using the REST utilities of Che. Please have a look at the sections Server Services and Client Server Communication for more details.

The following example action consumes the workspace service defined above and shows the result using the notification manager.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/CountLinesAction.java
org.eclipse.che.plugin.jsonexample.ide.action.CountLocAction

@Singleton
public class CountLinesAction extends JsonExampleProjectAction {

  private final AppContext appContext;
  private final StringMapUnmarshaller unmarshaller;
  private AsyncRequestFactory asyncRequestFactory;
  private NotificationManager notificationManager;

  @Inject
  public CountLinesAction(AppContext appContext,
                        JsonExampleResources resources,
                        AsyncRequestFactory asyncRequestFactory,
                        NotificationManager notificationManager) {

    super(appContext,
              "Count JSON Lines of Code",
              "Counts lines of code for all JSON Files in the project",
              resources.icon());

    this.appContext = appContext;
    this.asyncRequestFactory = asyncRequestFactory;
    this.notificationManager = notificationManager;
    this.unmarshaller = new StringMapUnmarshaller();
  }

  @Override
  public void actionPerformed(ActionEvent e) {
    String url = this.appContext.getDevMachine().getWsAgentBaseUrl()
      + "/json-example/"
      + this.appContext.getWorkspaceId()
      + this.appContext.getCurrentProject().getProjectConfig().getPath();

      asyncRequestFactory.createGetRequest(url, false).send(
        new AsyncRequestCallback<Map<String, String>>(unmarshaller) {
  
          @Override
          protected void onSuccess(Map<String, String> linesPerFile) {
          
            for (Map.Entry<String, String> entry : linesPerFile.entrySet()) {
              String fileName = entry.getKey();
              String loc = entry.getValue();
              notificationManager.notify(
                "File " + fileName + " has " + loc + " lines.",
                StatusNotification.Status.SUCCESS,
                StatusNotification.DisplayMode.FLOAT_MODE
              );
             }
           }

           @Override
           protected void onFailure(Throwable exception) {
            notificationManager.notify(
              exception.getMessage(),
              StatusNotification.Status.FAIL,
              StatusNotification.DisplayMode.FLOAT_MODE
              );
           }
        });

  }
}


\\\\\\\\\\\\\\\\\\\\\\\\Parts
Parts
Part API

Parts represent the content of the Che workbench, i.e. views and editors within the IDE. Che already provides various parts such as the project explorer, the output console, the build result view, file outline and the code editor. In this part of the tutorial, we describe how to implement a custom view and embed it into the Che IDE. Furthermore, we demonstrate how to open and hide views.

CREATE A CUSTOM PART
Creating a part in Che consists of two four components, which are marked in grey in the diagram below. In this section, we provide a general overview, in the following sections, we describe the concrete implementation more in detail.
The central component is the implementation of the view itself (MyViewImpl). It will create all the UI widgets, which are shown within a part. MyViewImpl inherits from BaseView, a base implementation of common functionality for all views provided by Che. If the view needs to be accessed by other components, e.g. to set a selection, public methods should be extracted to an interface (MyView). To allow other components to get an instance of MyView, the interface is bound to the implementation within MyGinModule. See the section Dependency Injection Basics for more details about this.
As mentioned before, the view implementation is responsible for the content of a view. The integration into the Che IDE, including configuring the tab (title, icon, etc.) is done by a part presenter (MyPartPresenter), which inherits from BasePresenter. Part presenter are called by Che or a custom action to interact with a part, e.g. to open it or to fill it with content. The part presenter forwards relevant calls to the implementation of a view (encapsulated by the interface).


In the following sections, we describe the implementation of the mentioned components more in detail. As an example, we create a part displaying "Hello World" and define an action to open it.

Implementing a View
In this section, we describe the implementation of a simple "Hello World" view. The implementation is shown in the following listing. All views in Che inherit from org.eclipse.che.ide.api.parts.base.BaseView, which implements basic features for views embedded into the Che IDE. The super constructor requires the PartStackUIResources which we get injected as a parameter.
Views in Che are implemented using GWT. Therefore, we can use any GWT widgets or framework capabilities to actually implement the views. In the following example, we simply create a label and set its text. To implement more complex views and use other GWT features, such as describing the UI using XML, please refer to the GWT project page.

In the last line of the example, we call the method #setContenWidget of the base class to specifiy the root widget to be shown in the view. In our case, this is the Label, if you create a more complex layout of widgets, this would be the root container of the view.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldViewImpl.java
package org.eclipse.che.plugin.parts.ide.helloworldview;

import com.google.gwt.user.client.ui.Label;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.eclipse.che.ide.api.parts.PartStackUIResources;
import org.eclipse.che.ide.api.parts.base.BaseView;

public class HelloWorldViewImpl extends BaseView<HelloWorldView.ActionDelegate> implements HelloWorldView {

    @Inject
    public HelloWorldViewImpl(PartStackUIResources resources){
        super(resources);
        Label label = new Label("Hello World");
        setContentWidget(label);
    }


}
As mentioned in the introduction of this section, an explicit interface should defined, when implementing a view, encapsulating all interaction with other components (see following listing). Therefore, the interface contains all methods, which shall be accessible by other components. In the following example, the interface defines a method #setVisible to allow controlling the visibility of the view. This method is already implemented by BaseView so we do not need to implement it in HelloWorldViewImpl. If you need to provide any other methods for a view, e.g. to pass in some input parameters to be shown, you should extend the view interface accordingly.

Following the GWT pattern, the view interface also defines an ActionDelegate. This interface can be implemented by components, which want to listen to events triggered with the view, e.g. a button click. Our HelloWorldViewis currently not triggering any actions, so the interface is empty. Please see the section "Interacting from within views" below for more details.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldView.java
package org.eclipse.che.plugin.parts.ide.helloworldview;

import org.eclipse.che.ide.api.mvp.View;
import org.eclipse.che.ide.api.parts.base.BaseActionDelegate;

public interface HelloWorldView extends View<HelloWorldView.ActionDelegate> {


    void setVisible(boolean visible);

    interface ActionDelegate extends BaseActionDelegate {

    }
}
Finally, we have to make our view available for other components, using dependency injection. This is done in MyGinModule, which can contain other bindings, too. Please see the section Dependency Injection Basics for more details about this binding.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/inject/MyGinModule.java
package org.eclipse.che.plugin.parts.ide.inject;

import com.google.gwt.inject.client.AbstractGinModule;
import org.eclipse.che.ide.api.extension.ExtensionGinModule;
import org.eclipse.che.plugin.parts.ide.helloworldview.HelloWorldView;
import org.eclipse.che.plugin.parts.ide.helloworldview.HelloWorldViewImpl;

@ExtensionGinModule
public class MyGinModule extends AbstractGinModule {

    @Override
    protected void configure() {
        bind(HelloWorldView.class).to(HelloWorldViewImpl.class);
    }

}
Implementing a Part Presenter
To connect the view implementation to the Che workbench, we need to implement a part presenter. It defines, how a view is embedded into Che (e.g. a title and an icon). Furthermore, it handles all interactions with the view. This goes in both directions. As a first example, if you want to hide a view, you will call the presenter. As a second example, if you click a button within a view, which should trigger something in Che, the presenter will receive this event and trigger the specified action.

The following listing shows the HelloWorldPresenter for the previous example view. It retrieves the HelloWorldview using dependency injection in its constructor. The following methods define, how the view is presented as a tab in Che: a title, an icon and a tooltip. The method #setVisible delegates to the view itself.
The method #go is called, when a view is opened. As a parameter, it receives a callback, which expects a view implementation to be set. With this call, the view implementation is wired to the Che workbench.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldPresenter.java
package org.eclipse.che.plugin.parts.ide.helloworldview;
import com.google.gwt.user.client.ui.AcceptsOneWidget;
import com.google.gwt.user.client.ui.IsWidget;
import com.google.inject.Inject;
import org.eclipse.che.ide.api.parts.base.BasePresenter;
import org.eclipse.che.plugin.parts.ide.SamplePartsResources;
import org.vectomatic.dom.svg.ui.SVGResource;

/**
 * Presenter for the sample Hello World View.
 */
@Singelton
public class HelloWorldPresenter extends BasePresenter {

    private HelloWorldView view;

    @Inject
    public HelloWorldPresenter(HelloWorldView view){
        this.view = view;
    }

    @Override
    public String getTitle() {
        return "Hello World View";
    }
  
    @Override
    public SVGResource getTitleImage() {
        return (SamplePartsResources.INSTANCE.icon());
    }
  
    @Override
    public String getTitleToolTip() {
        return "Hello World Tooltip";
    }

    @Override
    public IsWidget getView() {
        return view;
    }

    @Override
    public void setVisible(boolean visible) {
        view.setVisible(visible);
    }

    @Override
    public void go(AcceptsOneWidget container) {
        container.setWidget(view);
    }
}
Interacting from within a view
To trigger any behavior from with views, the ActionDelegate is used as a receiver of events following the GWT MVP pattern. Therefore, you extend the interface by the required methods, in the following listing a method #onButtonClicked.

Java
/** Required for delegating functions in view. */ 
public interface ActionDelegate extends BaseActionDelegate { 
  /** Performs some actions in response to a user's clicking on Button */ 
  void onButtonClicked(); 
}
The ActionDelegate interface has to be implemented and provided to the view. For a part, the part presenter is a good component to do both, especially, if the relevant operations to be triggered are related to the Che workbench or to Che services. Therefore, the part presenter implements the interface MyView.ActionDelegate, implements the defined method and sets itself as a delegate (see listing below).

Java
@Singelton
public class MyPartPresenter extends BasePresenter implements MyView.ActionDelegate {

    private MyView view;

    @Inject
    public MyPartPresenter(MyView view){
        this.view = view;
        view.setDelegate(this);
    }
  
    public void onButtonClicked(){
      //Do sth.
    }
Finally, the action delegate can be called from within the view implementation, as shown below.

Java
public class MyViewImpl extends BaseView<HelloWorldView.ActionDelegate> implements MyView {

/...

public void onButtonClicked(ClickEvent event) { 
    delegate.onButtonClicked(); 
}
OPENING PARTS
To open parts, the service WorkspaceAgent is used. It provides a method #openPart which accepts two parameters:

The part presenter of the part to be opened
The location, where the part is to be opened
The following locations are supported by Che:

EDITING: area just above the editor, like a file tab
NAVIGATION: area on the left to project explorer
TOOLING: area to the right of the editor
INFORMATION: area under the editor, 'console' area
After a pat has been opened, it must be activated to ensure that it gets visible and receives the focus. This is done using WorkspaceAgent#setActivePart.
The following code example shows an action, which opens the "Hello World" part defined before. Please see the section Actions for more details about the implementation of actions.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldViewAction.java
package org.eclipse.che.plugin.parts.ide.helloworldview;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.eclipse.che.ide.api.action.Action;
import org.eclipse.che.ide.api.action.ActionEvent;
import org.eclipse.che.ide.api.parts.PartStackType;
import org.eclipse.che.ide.api.parts.WorkspaceAgent;

/**
 * Action for showing a the Hello World View.
 */
@Singleton
public class HelloWorldViewAction extends Action {

    private WorkspaceAgent workspaceAgent;
    private HelloWorldPresenter helloWorldPresenter;

    /**
     * Constructor.
     *
     */
    @Inject
    public HelloWorldViewAction(WorkspaceAgent workspaceAgent, HelloWorldPresenter helloWorldPresenter) {
        super("Show Hello World View");
        this.workspaceAgent = workspaceAgent;
        this.helloWorldPresenter = helloWorldPresenter;
    }


    @Override
    public void actionPerformed(ActionEvent e) {
        workspaceAgent.openPart(helloWorldPresenter, PartStackType.INFORMATION);
        workspaceAgent.setActivePart(helloWorldPresenter);
    }
}

\\\\\\\\\\\\\\\\\\\\\\\\\REST APIs
REST APIs
Many of the IDE components that you build into your extension will need to communicate directly with the Che server or to the workspace the IDE is currently bound to. Che provides helper utilities to make REST calls simpler. Che's REST library is built on top of Google's HTTP Java client libraries.

In your extension code, you can create an AsyncRequestFactory object, which has helper methods for creating requests that will have responses.

che/core/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/project/ProjectTypeServiceClientImpl.java
private void getProjectType(@NotNull String workspaceId, 
                            @NotNull String id, 
                            @NotNull AsyncCallback<ProjectTypeDto> callback) {
  
    final String url = extPath + "/project-type/" + workspaceId + '/' + id;
    asyncRequestFactory.createGetRequest(url)
                       .header(ACCEPT, APPLICATION_JSON)
                       .loader(loaderFactory.newLoader("Getting info about project type..."))
                       .send(newCallback(callback, 
                                         dtoUnmarshallerFactory.newUnmarshaller(ProjectTypeDto.class)));

}
This example comes from the class used by the IDE to ask the server to provide a response on what the current project type is within the currently active workspace. The asyncRequestFactory object was instantiated by the system as an input parameter. Calling the createGetRequest() method with the GET REST URL as an input will generate a request and a response. The .loader() method is an optional display component that will appear on the screen while the contents of the response are loading. The send() method takes a callback object which will be invoked by the system when a response is delivered.

In the debugger implementation class, you can see a range of REST calls for different individual functions such as step into, step over, and so forth.

In the Java content assist class, you can see the sequence of REST calls that are made for generating requests for information from the server about intellisense features that can only be processed on the server side.

Callbacks
In Che, you will frequently see AsyncRequestCallback<T> objects passed into an AsyncRequestFactory object. Callbacks will be invoked by the system when a response is returned. This class inherits from com.google.gwt.http.client.RequestCallback and we add in a few additional objects:

Unmarshallable<T> which is logic to convert the response payload from data into a Java object.
AsyncRequestLoader which is a visual loader to display while downloading data.
AsyncRequest which is the original request.
Che provides different types of Unmarshallable objects including StringUnmarshaller, StringMapUnmarshaller, StringMapListUnmarshaller, DtoUnmarshaller, and LocationUnmarshaller. These different marshallers represent the most common types of JSON to Java payload conversions.

For example, this logic comes from the git plugin and is the method that is called when a user asks to delete the local git repository contained within the project.

che/plugins/plugin-git/che-plugin-git-ext-git/src/main/java/org/eclipse/che/ide/ext/git/client/delete/DeleteRepositoryPresenter.java
public void deleteRepository() {
    final CurrentProject project = appContext.getCurrentProject();
    final GitOutputConsole console = gitOutputConsoleFactory.create(DELETE_REPO_COMMAND_NAME);

     service.deleteRepository(workspaceId, project.getRootProject(), 
                              new AsyncRequestCallback<Void>() {
        @Override
        protected void onSuccess(Void result) {
            console.print(constant.deleteGitRepositorySuccess());
            consolesPanelPresenter.addCommandOutput(appContext.getDevMachineId(), console);
            notificationManager.notify(constant.deleteGitRepositorySuccess(), project.getRootProject());
            getRootProject(project.getRootProject());
        }

        @Override
        protected void onFailure(Throwable exception) {
            // The logic for what to do if the response generated a failure message
        }
    });
}
In this example, the service.deleteRepository(...) is a method that will generate the AsyncRequestFactory object for calling the server. This object requires a AsyncRequestCallback<T>. This method creates a new instance inline with a callback that expects the response to send data of Void type, which basically means that there is no response payload. In this case, either the server tells us there is success or there is failure. The AsyncRequestCallback instance needs to implement two methods onSuccess(<T>) and onFailure(Throwable), which will be called by the AsyncRequestFactory when the response arrives on the wire. It is within these methods that the logic is placed that tells the IDE what to do in each event.


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Java Class Reference
Java Class Reference
JavaDoc for the Che & GWT classes available to developers

You can generate the JavaDoc for your installation from source.

Shell
# You need the che-core library
git clone http://github.com/eclipse/che
git checkout {version-that-matches-your-install}
cd core/
mvn javadoc:aggregate

# JavaDoc available at:
/core/target/site/apidocs/index.html

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Properties
Properties
Referencing Properties in Extensions
You can reference properties in Che extensions that you author. Configuration parameters may be injected with a constructor or directly in the fields. The parameter of the field must be annotated with @javax.inject.Named. The value of the annotation is the name of the property. For example, if the configuration property is: data_file:/home/user/storage then in your extension code:

Java
public class MyClass {
  ...
  @Inject
  public MyClass(@Named("data_file") File storage) {
      ...
  }
}
or

Java
public class MyClass {
  @Inject
  @Named("data_file")
  private File storage;
  ...
}
All system properties and environment variables may be injected into your extensions with prefixes sys. and env., respectively. So, for example, environment variable HOME name must be env.HOME. Here is an example of how to inject the value of system property java.io.tmpdir and value of environment variable HOME.

Java
public class MyClass {
  @Inject
  public MyClass(@Named("sys.java.io.tmpdir") File tmp, @Named("env.HOME") File home) {
      ...
  }
}
Any value can be converted into a java.lang.String Java type. You can also directly convert properties to the following Java types:

boolean
byte
short
int
long
float
double
java.net.URI
java.net.URL
java.io.File
String[] (value is a comma separated string)
Workspace Extension Properties
Each workspace is a separate runtime, and has at least one development agent that runs as a miniaturized Che server within the workspace. That agent has its own properties that can be configured as well. If you are authoring custom workspace extensions that are deployed within Che's agent in the workspace, you can customize.

Properties saved in CHE_CONF_FOLDER\plugin-conf\ folder will be mounted into the runtime for each workspace created by Che. The Che development agent that runs within the workspace will load these properties when it boots.


\\\\\\\\\\\\\\\\\\\\\\\\\\\\Workspace Access
Workspace Access
One of the core strengths of Che is the workspace concept. Additionally to project files, such as source code, Che also allows to share workspaces, which provide the necessary runtime to compile and run the system under development. Workspaces can also provide any other kind of tooling to work on a project, this tooling can then be triggered in the Che IDE.

The concept of workspaces makes it very convenient to reuse any existing tool in Che, as those tools can be executed on the workspace runtime. Che already provides several of those tool integrations, such as Maven or Git.

There are two ways to integrate tools running on the workspace: First, you can provide a custom workspace service, which triggers the native workspace call and provides an API to be used by the client IDE. Second, you can use the existing command support of Che, which already allows to execute native commands on the workspace without implementing a custom service. In this tutorial, we will demonstrate the second option, please refer to this tutorial this tutorial to learn how to implement custom services.

In the following, we implement a simple command, which creates a new file called "che-was-here" using the native "touch" command. The command is finally called by a sample action, however, we encapsulate the execution of the command into a dedicated class called CommandManager which can execute arbitrary commands on the workspace (see following listing).

To execute a command, Che provides the service MachineServiceClient. To execute a command, it requires the ID of the machine the command should be executed on, the command to be executed, an output channel and a callback.

The ID can be retrieved from the AppContext. The Command is created using the Che DtoFactory. The parameter CommandLine specifies the native command to be executed. Finally, we create a sample output channel and execute the command with an empty call back.

che/samples/sample-plugin-nativeaccess/che-sample-plugin-nativeaccess-ide/src/main/java/org/eclipse/che/plugin/nativeaccessexample/machine/client/command/CommandManager.java
@Singleton
public class CommandManager {

    private final DtoFactory dtoFactory;
    private final MachineServiceClient machineServiceClient;
    private final NotificationManager notificationManager;
    private final AppContext appContext;

    @Inject
    public CommandManager(DtoFactory dtoFactory, MachineServiceClient machineServiceClient, NotificationManager notificationManager, AppContext appContext) {
        this.dtoFactory = dtoFactory;
        this.machineServiceClient = machineServiceClient;
        this.notificationManager = notificationManager;
        this.appContext = appContext;
    }

    /** Execute the the given command configuration on the developer machine. */
    public void execute(String commandLine) {
        final Machine machine = appContext.getDevMachine().getDescriptor();
        if (machine == null) {
            return;
        }
        String machineID = machine.getId();
        final CommandDto command = dtoFactory.createDto(CommandDto.class)
                .withName("some-command")
                .withCommandLine(commandLine)
                .withType("arbitrary-type");
        final String outputChannel = "process:output:" + UUID.uuid();
        executeCommand(command, machineID, outputChannel);
    }

    public void executeCommand(final CommandDto command, @NotNull final String machineID, String outputChannel) {
        final Promise<MachineProcessDto> processPromise = machineServiceClient.executeCommand(machineID, command, outputChannel);
        processPromise.then(new Operation<MachineProcessDto>() {
            @Override
            public void apply(MachineProcessDto process) throws OperationException
            {
                //Do nothing in this example
            }

        });

    }
}
Now, the CommandManager can be used to trigger any kind of command line operation. The following example action uses the native "touch" command to create a new file.

che/samples/sample-plugin-nativeaccess/che-sample-plugin-nativeaccess-ide/src/main/java/org/eclipse/che/plugin/nativeaccessexample/ide/action/RunNativeCommandAction.java
@Singleton
public class RunNativeCommandAction extends Action {

    public final static String ACTION_ID = "runNativeCommandSAction";

    private CommandManager commandManager;

    @Inject
    public RunNativeCommandAction(CommandManager commandManager) {
        super("Run native command demo");
        this.commandManager = commandManager;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Log.warn(getClass(), "Executing native command...");
        commandManager.execute("cd && touch che-was-here");
    }

}


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Native HTML/JS
Native HTML/JS
The Che IDE is developed based on GWT. If you want to extend the Che UI with new UI components, the default is to develop those custom components using GWT, too. Please refer to this tutorial to learn how to extend Che with new parts (view or editors).

However, as Che is a browser application based on HTML and JavaScript, it is also possible to embed native web components. Those do not have to be based on GWT. This also enables you to reuse any kind of existing UI component in Che. As an existing example, Che embeds the Orion code editor.

Details
For instructions on how to build and run an extension, see Building Extensions.

JavaScript
Location:     github.com/eclipse/che/samples/sample-plugin-embedjs
Type:         IDE extension
groupId:      org.eclipse.che.sample
artifactId:   che-sample-plugin-embedjs-ide
Steps
In this tutorial, we demonstrate, how to embed a minimal HTML/JavaScript component into Che. We will create a custom part, which shows a "Hello World" produced by a simple JavaScript snippet (see screenshot below). You can extend this example, to embed any HTML/JavaScript component you like.


The following example is based on a simple part, which is opened by a sample action. Therefore, we recommend to get familiar with the implementation of Parts and Actions first.

The HelloWorldView is a default view, in this example, the HelloWorldView just creates an empty Panel. The panel will finally be represented by a HTML element in the running browser application.

In the HelloWorldPresenter we use the GWT ScriptInjector library to inject a custom script (helloWorld.js) into the main window of the browser application. Finally, we use HelloWorldOverlay to call the custom JavaScript from within our GWT application. In our example, it will modify the HTML element, which represents the Panel, and will add the "Hello World from JavaScript" text to it.


The HelloWorld.js contains a simple function, which replaces the text content of an arbitrary element in the DOM. It could also add new elements and therefore embed an arbitrary sub component to running the browser application.

che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/resources/org/eclipse/che/plugin/embedjsexample/public/helloworld.js
function HelloWorld(element, contents) {
    element.textContent = contents;
};
To add the custom JavaScript function to the running application, we use the GWT ScriptInjector library. We load the JavaScript file and add it to the top window of the application. If adding the script was successful, we directly call the method #sayHelloWorld of the HelloWordView, which we explain in the following.

Java
@Singleton
public class HelloWorldViewPresenter extends BasePresenter implements HelloWorldView.ActionDelegate, HasView {

    private final HelloWorldView helloWorldView;

    @Inject
    public HelloWorldViewPresenter(final HelloWorldView helloWorldView) {
        this.helloWorldView = helloWorldView;

        ScriptInjector.fromUrl(GWT.getModuleBaseURL() + Constants.JAVASCRIPT_FILE_ID)
                .setWindow(ScriptInjector.TOP_WINDOW)
                .setCallback(new Callback<Void, Exception>() {
                    @Override
                    public void onSuccess(final Void result) {
                        Log.info(HelloWorldViewPresenter.class, Constants.JAVASCRIPT_FILE_ID + " loaded.");
                        sayHello();
                    }

                    @Override
                    public void onFailure(final Exception e) {
                        Log.error(HelloWorldViewPresenter.class, "Unable to load "+Constants.JAVASCRIPT_FILE_ID, e);
                    }
                }).inject();

    }

    private void sayHello() {
        this.helloWorldView.sayHello("Hello from Java Script!");
    }
The HelloWorldViewImpl creates an empty panel (which is defined in che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/java/org/eclipse/che/plugin/embedjsexample/ide/view/HelloWorldViewImpl.ui.xml).

Furthermore, it implement the method #sayHello and forwards it to HelloWorldViewOverlay.

che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/java/org/eclipse/che/plugin/embedjsexample/ide/view/HelloWorldViewImpl.java
public class HelloWorldViewImpl extends BaseView<HelloWorldView.ActionDelegate> implements HelloWorldView {

    interface HelloWorldViewImplUiBinder extends UiBinder<Widget, HelloWorldViewImpl> {
    }

    private final static HelloWorldViewImplUiBinder UI_BINDER = GWT.create(HelloWorldViewImplUiBinder.class);

    @UiField
    FlowPanel helloWorldPanel;

    @Inject
    public HelloWorldViewImpl(PartStackUIResources resources) {
        super(resources);
        setContentWidget(UI_BINDER.createAndBindUi(this));
    }

    @Override
    public void sayHello(String content) {
        HelloWorldViewOverlay.sayHello(helloWorldPanel.getElement(), content);
        helloWorldPanel.setVisible(true);
    }

}
Finally the HelloWorldOverlay provides access to the JavaScript function and therefore redirects the Java method to a call of the HelloWorld function that we added before. Such overlays are used for communicating between the Che IDE, written in Java/GWT and native JavaScript components, which are embedded into it.

Java
public class HelloWorldViewOverlay extends JavaScriptObject {

    protected HelloWorldViewOverlay() {
    }

    public final static native void sayHello(final Element element, String message) /*-{
        new $wnd.HelloWorld(element, contents);
    }-*/;

}
Use
This particular extension adds an action to the main context menu group. This is the group that appears when you right click on the project tree. To verify that your plugin is installed, you can also check the Profile > Preferences > Plugins > List to verify that the "Hello world from JavaScript example" plugin has been installed.


\\\\\\\\\\\\\\\\\\\\\\\\\\\HelloWorld Extension
HelloWorld Extension
Create your first extension

This documentation is a step-by-step guide to build your first HelloWorld extension for Eclipse Che.

In order to follow this guide, we consider you have successfully configured Eclipse Che sources inside of Eclipse IDE and have been able to execute your manually built assembly. If not, please refer to the following documentation.

1- CREATE A NEW MAVEN PROJECT
Create a new maven project.


Skip the archetype selection.


Provide basic information about the Maven project.


Provide asked information (we will update them in the next step)

2- ADD DEPENDENCIES AND PARENT DEFINITION TO THE POM.XML
In order to be properly defined, we will rely on che-parent for the hello world extension. We will inherit from the global che definition.

We add the dependencies for:

Guice
Che Core IDE API
GWT
We also add the Maven repository used to retrieve artifacts and the Build configuration (refer to https://eclipse-che.readme.io/v5.0/docs/create-and-build-extensions#section-pom-xml) .

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright (c) 2012-2016 Codenvy, S.A.
    All rights reserved. This program and the accompanying materials
    are made available under the terms of the Eclipse Public License v1.0
    which accompanies this distribution, and is available at
    http://www.eclipse.org/legal/epl-v10.html

    Contributors:
      Codenvy, S.A. - initial API and implementation

-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>che-parent</artifactId>
        <groupId>org.eclipse.che</groupId>
        <version>5.0.0-M6-SNAPSHOT</version>
    </parent>
    <artifactId>che-helloworld-sample</artifactId>
    <packaging>jar</packaging>
    <name>Che Sample :: Hello World</name>
    <dependencies>
        <dependency>
            <groupId>com.google.inject</groupId>
            <artifactId>guice</artifactId>
        </dependency>
        <dependency>
            <groupId>org.eclipse.che.core</groupId>
            <artifactId>che-core-ide-api</artifactId>
        </dependency>
        <dependency>
            <groupId>com.google.gwt</groupId>
            <artifactId>gwt-user</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    <repositories>
        <repository>
            <id>codenvy-public-repo</id>
            <name>codenvy public</name>
            <url>https://maven.codenvycorp.com/content/groups/public/</url>
        </repository>
    </repositories>
    <build>
        <sourceDirectory>src/main/java</sourceDirectory>
        <outputDirectory>target/classes</outputDirectory>
        <resources>
            <resource>
                <directory>src/main/java</directory>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>com.google.code.sortpom</groupId>
                <artifactId>maven-sortpom-plugin</artifactId>
                <configuration>
                    <verifyFail>Warn</verifyFail>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
Once your pom.xml file is edited, save it.
You will see that Eclipse is displaying an error on the che-helloworld-extension module. Fix this error by doing an "Update Project" with the Eclipse's Maven plugin:


3- CREATE HELLOWORLDEXTENSION CLASS
Create the package org.eclipse.che.ide.ext.helloworld in src/main/java:


Add HelloWorldExtension java class in the package org.eclipse.che.ide.ext.helloworld:


In this extension we'll need to talk to Parts and Action API. Gin and Singleton imports are obligatory as well for any extension. Add the following import:

imports
...
import org.eclipse.che.ide.api.extension.Extension;
import com.google.inject.Inject;
import com.google.inject.Singleton;
...
We add the following annotations:

annotations
/**
 * @Singleton is required in case the instance is triggered several times this extension will be initialized several times as well.
 * @Extension lets us know this is an extension and code injected in it will be executed when launched
 */
@Singleton
@Extension(title = "Hello world", version = "1.0.0")
public class HelloWorldExtension
{
}
In the constructor, we want our HelloWorld extension to display an "Hello World" message in the Events Panel. In order to do that, we will use the notification manager.

construtor
{
    @Inject
    public HelloWorldExtension(NotificationManager notificationManager) {
        notificationManager.notify("Hello World");
    }
}
Finally, your class should be like this:

HelloWorldExtension.java
/*******************************************************************************
 * Copyright (c) 2012-2016 Codenvy, S.A.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Codenvy, S.A. - initial API and implementation
 *******************************************************************************/
package org.eclipse.che.ide.ext.helloworld;

import org.eclipse.che.ide.api.extension.Extension;

/**
 * Che API imports. In this extension we'll need
 * to talk to Parts and Action API. Gin and Singleton
 * imports are obligatory as well for any extension
 */

import org.eclipse.che.ide.api.notification.NotificationManager;

import com.google.inject.Inject;
import com.google.inject.Singleton;

/**
 * @Singleton is required in case the instance is triggered several times this extension will be initialized several times as well.
 * @Extension lets us know this is an extension and code injected in it will be executed when launched
 */
@Singleton
@Extension(title = "Hello world", version = "1.0.0")
public class HelloWorldExtension
{
    @Inject
    public HelloWorldExtension(NotificationManager notificationManager) {
        notificationManager.notify("Hello World");
    }
}
4- CREATE HELLOWORLDEXTENSION GWT MODULE
Create the package org.eclipse.che.ide.ext.helloworld in src/main/resources:


Add HelloWorldExtension GWT module by creating the file HelloWorldExtension.gwt.xml:


Inherits from the GWT modules: User, Inject. We will also inherits from the IDE GWT API.

HelloWorldExtension.gwt.xml
<!--

    Copyright (c) 2012-2016 Codenvy, S.A.
    All rights reserved. This program and the accompanying materials
    are made available under the terms of the Eclipse Public License v1.0
    which accompanies this distribution, and is available at
    http://www.eclipse.org/legal/epl-v10.html
    Contributors:
      Codenvy, S.A. - initial API and implementation
      
-->
<module>
    <inherits name="com.google.gwt.user.User"/>
    <inherits name="org.eclipse.che.ide.Api"/>
    <inherits name="com.google.gwt.inject.Inject"/>
    <source path=""/>
</module>
5- BUILD THE EXTENSION
Create the following Run Configuration:


Or you can also open a terminal where you create your HelloWorld Extension and run a mvn clean install.

If everything goes well, you should have:

Shell
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 8.673 s
[INFO] Finished at: 2016-10-13T15:05:21+02:00
[INFO] Final Memory: 47M/648M
[INFO] ------------------------------------------------------------------------
6- ADD EXTENSION TO ROOT POM OF CHE
In order to allow your extension to be visible from the root level of Che, add your extension as a dependency in the list of <dependencies> from the <dependencyManagement> block. Edit the pom.xml from che-parent

pom.xml
...
<dependencyManagement>
  <dependencies>
    ...
    <dependency>
      <groupId>org.eclipse.che</groupId>
      <artifactId>che-helloworld-sample</artifactId>
      <version>${che.version}</version>
    </dependency>
    ...
  </dependencies>
</dependencyManagement>
...

You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.


7- LINK TO IDE ASSEMBLY
The HelloWorld extension is only a client-side (IDE) extension. You have to introduce your extension as a dependency in /che/assembly/assembly-ide-war/pom.xml and also have it added as a dependency to the GWT application.

First add the dependency:

/che/assembly/assembly-ide-war/pom.xml
...
<dependencies>
  ...
  <dependency>
     <groupId>org.eclipse.che</groupId>
     <artifactId>che-helloworld-sample</artifactId>
  </dependency>
  ...
</dependencies>
You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.


Second, link your GUI extension into the GWT app. You will add an <inherits> tag to the module definition. The name of the GWT extension is derived from the direction + package structure given to the GWT module defined in our HelloWorld extension.

In assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml add:

assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml
...
<inherits name='org.eclipse.che.ide.ext.helloworld.HelloWorldExtension'/>
...
This means that in our embed sample, there is a file with a *.gwt.xml extension in a folder structure identical to the name above.



8- BUILD CHE WITH YOUR EXTENSION.
First, we need to rebuild the assembly-ide-war:


Or you can also do it in a terminal:

Shell
# Build a new IDE.war
# This IDE web app will be bundled into the assembly
cd che/assembly/assembly-ide-war
mvn clean install
Second, we need to rebuild the whole Eclipse Che assembly:

Or you can also do it in a terminal:

Shell
# Create a new Che assembly that includes all new client-side extensions
cd che/assembly/assembly-main
mvn clean install
9- START YOUR CUSTOM ASSEMBLY
To start Che from the custom assembly you just built, you can refer to this Usage: Docker Launcher. Remind your custom assembly is located in {workspace-path}\che\assembly\assembly-main\target\eclipse-che-<version>\eclipse-che-<version>

10- TEST YOUR EXTENSION
First create a new workspace and open it in the IDE.
Second open the "Events" panel.
You'll see the "Hello World" notification displayed in the list of events.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

=======================
endof AUTHORING EXTENSIONS



getfrom Google Guice 系列教程 － 基础实践
========================
Google Guice 是一个轻量级的依赖注入框架，它支持Java 5或者更高版本的JDK，得利于Java 5中提供的泛型 (Generics) 和注释 (Annotations) ，它可以使得代码类型安全 (type-safe) 。那么何时使用在代码中使用 Guice 进行注入呢？一般来说，如果在你的应用代码中业务对象 (Business Objects) 之间的关系或者依赖需要手动维护的话，你就可以使用Guice 进行注入。

该文章中，首先我将通过一些例子来初步的认识一下 Guice 框架，然后我将介绍下 依赖注入框架的理论知识 以及在应用程序中使用依赖注入的好处，同样我也会和大家探讨一下 Guice 提供的用于简化代码的 API (包括Annotations) 。最后通过大量使用 Guice API的例子来使大家更好地理解这些API。

依赖注入(Dependency Injection)

由于Gucie 是一个依赖注入框架 (Dependency Injection Framework) ，因此我们首先要很清楚依赖注入 (Dependency Injection) 是什么概念。这些年来，依赖注入变得越来越流行，变得越来越重要，在很多典型的应用中它甚至变成了一个必需的机制，比如 J2EE 5.0, Spring, JBoss Seam就是使用依赖注入的很好的例子。现在我们来使用一个简单的例子来说明使用依赖注入框架的必要性。

请看以下代码：

interface Storage{

    public void store(String uniqueId, Data data);
    public Data retrieve(String uniqueId);
 
}
上面的接口 Storage 提供了存储 (store) 和获取 (retrieve) 数据的机制，由于数据可以存储在数据库中也可以存储在一个文件中，因此上面接口 Storage 的实现可以如下。

class FileStorage implements Storage{
 
    public void store(String uniqueId, Data data){
        // Store the object in a file using Java Serialization mechanism.
    }
 
    public Data retrieve(String uniqueId){
        // Code to retrieve the object.
    }
 
}
实现类 FileStorage 可以将数据存储到硬盘文件中，同样也可以从硬盘文件中获取存储数据。接下来是 Storage 接口的另一种实现，它用于将数据存储到数据库中。

class DatabaseStorage implements Storage{
 
    public void store(String uniqueId, Data data){
        // Open a connection and store the data.
    }
 
    public Data retrieve(String uniqueId){
        // Get the data from the Database.
    }
 
}
现在，我们来看一个 Storage 应用客户端的例子。下面的 StorageClient 代码片段中，首先初始化一个 FileSorage，然后在转向 DatabaseStorage 实现。

public class StorageClient {
 
    public static void main(String[] args) {
 
        // Making use of file storage. 
        Storage storage = new FileStorage();
        storage.store("123", new Data());
 
        // Making use of the database.
        storage = new DatabaseStorage();
        storage.store("456", new Data());
    }
}
仔细看下 StorageClient 模块中的代码，尽管接口 (Storage) 和实现类 （ FileStorage / DatabaseStorage ） 松耦合，但是 客户端 (StorageClient) 模块需要手动地去创建实现类的实例对象 (instance) ，同样接口和实现类之间的关系 (Relationship) 是直接在客户端代码中写死的，然而在大多数情况下，在代码编译的时候，客户端应用程序已经知道需要绑定哪一种接口实现类，如果只绑定某一个具体的实现类，肯定比上面的代码中同时实现两个类 (某一个是没必要的) 更有用。Google Guice 就是干这个工作的，它在应用程序的客户端代码中创建不同形式服务 （Services） 实例， 而且客户端和服务之间的依赖是通过一些简单的配置机制 (Configuration Mechanism) 自动注入的。

接下来我将提供一个简单使用 Guice Framework 的例子。

一个简单的 Guice 例子

在这个简单的例子中，让我们看一下 Guice 在维护不同对象之间的关系/依赖时如何简化开发的。让我们看一下下面的代码片段，我们创建了一个 Add 接口，并且在里面定义了一个 add() 方法。

public interface Add {
 
    public int add(int a, int b);
 
}
下面是接口 Add 的一个实现类

public class SimpleAdd implements Add{
 
    public int add(int a, int b) {
        return a + b;
    }
 
}
接着我们定义一个 Module 类，这个类用于使用 Guice API 在一个应用程序中创建 Bindings。Module 和 Bindings 理论方面的详细介绍在后面章节。现在，你只需要明白通过 Binder 类，你可以将一些 Bindings 配置到某个 Module中。在 Guice 条目中，Binding 提供了一种方式将接口 （interface） 和实现类相关联。

import com.google.inject.Binder;
import com.google.inject.Module;
 
public class AddModule implements Module{
 
    public void configure(Binder binder) {
        binder.bind(Add.class).to(SimpleAdd.class);
    }
 
}
在上面的代码中，我们告诉 Guice 将 SimpleAdd 实现类绑定到 Add 接口上，也就是说在客户端调用Add.add() 方法时，实际会去执行 SimpleAdd.add() 方法。下面给出了一个客户端例子用户使用 Add 接口。

import com.google.inject.Guice;
import com.google.inject.Injector;
 
public class AddClient {
 
    public static void main(String[] args) {
 
        Injector injector = Guice.createInjector(new AddModule());
        Add add = injector.getInstance(Add.class);
        System.out.println(add.add(10, 54));
    }
}
更多关于 Injector, Guice 的理论知识将会在后面的章节介绍。injector.getInstance(Add.class) 将会创建并返回一个 SimpleAdd 类型的实例。实际上是通过 AddModule.configure() 方法来获取具体的绑定信息的。

Guice API 探讨

 让我们探讨一下实现 Guice 依赖注入不同的 API。特别会涉及以下的 接口/实现类。

Binder
Injector
Module
Guice
1. Binder

Binder 接口主要是由与 Bindings 相关的信息组成的。一个 Binding 其实就是一个接口和其相应的实现类的映射关系。例如，回想一下上面的例子，我们创建了一个由接口 Add 指向 实现类 SimpleAdd 的映射关系。

从程序角度来说，可以通过以下代码方式实现。注意的是无论是接口 (interface) 还是实现类 (implementation classes)，都是通过 bind() 和 to()方法实现映射的。

binder.bind(Add.class).to(SimpleAdd.class)
同样也可以将一个接口直接映射到一个具体的实例对象，代码如下。

binder.bind(Add.class).to(new SimpleAdd())
第三种方式是将一个接口绑定到一个相应的 Provider 类。默认情况下，Guice 框架会创建并返回应用程序需要的实例对象。但是，如果需要定制化一个对象创建流程（Object Creation Process），该怎么办？ Providers 可以很简单的实现这种定制化。 你只需要遵循传统的工厂模式（Factory Pattern）创建对象的方式使用 Providers，例如下面的代码。

binder.bind(Add.class).to(new AddProvider<Add>())
后面我将会通过一些例子讲解如何创建 Provider 对象。不过现在，你只需要知道在 AddProvider 类中提供了一种工厂方法，它会返回具体的 Add 实现类的实例对象。后面我同样会讲解到如何将一个接口绑定到多个具体实现上。

2. Injector

Injectors 通常会在客户端 （Clients） 使用，它只关心如何创建 （Creating）和维护 (Maintaining) 对象（生命周期）。Injectors 会去维护一组默认的 Bindings (Default Bindings)，这里我们可以获取创建和维护不同对象间关系的配置信息 （Configuration information）。以下代码将会返回 Add 的实现类对象。

Add addObject = injector.getInstance(Add.class)
你可以简单地通过 Injector.getBindings() 方法获取与 Injector 相关的 Bindings信息，getBindings（） 方法会返回一个 Map。

Map<Key, Binding> allBindings = injector.getBindings()
这里需要注意的是每一个 Binding 通常有一个对应的 Key 对象，该对象是由 Guice 自动创建并维护的。如果你想要获取于Injector相关的 Providers 的话，你可以通过以下方法获取。

Provider<SomeType> provider = injector.getProvider(SomeType.class)
3. Module

Module 对象会去维护一组 Bindings。在一个应用中可以有多个 Module  。反过来 Injectors 会通过 Module 来获取可能的 Bindings。Module 是通过一个包含需要被重写 override 的 Module.configure() 方法的接口去管理 Bindings。 简单地说，就是你要继承一个叫做 AbstractModule的类，这个类实现了 Module 接口，并且重写 configure（） 方法， 代码如下。

class MyModule extends AbstractModule{
 
    public void configure(Binder binder){
 
        // Code that binds information using the various
        // flavours of bind method.
    }
}
4. Guice

客户端 （Clients） 是通过 Guice 类直接和其他 Objects 进行交互的。Injector 和不同的 Modules 之间的联系是通过 Guice 建立的。例如下面的代码。

MyModule module = new MyModule();
Injector injector = Guice.createInjector(module);
这里需要注意的是 Guice.createInjector() ，该方法接受一个 Module 对象作为参数。 Module 类必需要重写 configure() 方法， 该方法是用于传递一个 默认 Binder 对象， 该 Binder 对象为应用程序用于填充特定的 Bindings (to Classes, Objects and Providers)。 当客户端调用 Injector 类的 getInstance() 方法创建一个实例的时候，Injector 会从 Binder 对象维护的各种 Bindings 中获取原来的对象。

Guice 注释 （Annotations）

Guice 提供了一些十分有用的 Annotations ，这些 Annotations 可以用来在应用程序中添加 元数据 （meta-data）。 这一章节我将要讲以下几个注释。

Implemented By
Inject
Provided By
Singleton
1. Implemented By

该 Annotation 用于指向接口的实现类。例如，如果 Add 接口有多个实现类，但是我们希望 SimpleAdd 是 Add 的默认实现类，于是我们可以像下面一样处理。

@ImplementedBy(SimpleAdd.class)
interface Add{
 
    public int add(int a, int b);
 
}
2. Inject

我们可以使用 Inject Annotation 来直接将实例注入到客户端的代码中。该注释可以用于某个类的构造方法上，代码如下。

class Client{
 
    @Inject
    public Client(MyService service){
    }
}
上面的代码，我们是基于构造方法层次 （Constrcctor-level）的 注入，并且假设 MyService 接口的具体实现已经在应用程序的 Module 中定义映射好了。同样你也可以在方法层次 （Method-level） 和 字段层次 （Field-level） 使用注释。

3. Provided By

假设我们想要为一些接口定制化对象创建的流程 （Object creation process），那么我们需要依赖 Guice Provider 机制， 对于接口 Add 来说，我们需要使用 AddProvider 来创建并返回 SimpleAdd 对象。在这个案例中，我们可以直接在接口声明处使用 ProvidedBy 注释来指定该接口的 Provider 类型， 代码如下。

@ProvidedBy(AddProvider.class)
public interface Add{
 
}
4. Singleton

默认情况下，客户端可以多次使用 Injector.getInstance() 来调用对象，每一个都会返回一个新创建的对象。如果我们想要使用单例模式（Singleton Pattern）来获取对象，即 One Instance in the application，你可以在实现类上使用 Singleton 注释去标记。

@Singleton
public class MyConnection{
 
    public void connect(){
    }
 
    public void disconnect(){
    }
}

例子 （Samples）

 

这一章节将会提过更多的例子帮助你理解和使用 Guice API ，我将会更加详细的解析。

1. 简单的例子

在这个简单的例子中我们没有使用接口编程，即将接口和实现分离。我们只有一个实现类 Player 和一个依赖它的客户端 PlayerTest， 这里 Guice 没有做什么，只是提供了一个映射。

首先来看一下 Player 类。

public class Player {
 
public String name;
 
    public Player(){        
    }
 
    public String toString(){
        return name;
    }
}
下面是客户端代码的例子，用于使用 Player 类。这里需要注意的是我们没有在 Guice.createInjector() 方法里面传递 Module ，因为我们不需要在程序代码中绑定对象。

import com.google.inject.Guice;
import com.google.inject.Injector;
 
public class PlayerTest {
 
public static void main(String[] args) {
 
    Injector injector = Guice.createInjector();
    Player player = injector.getInstance(Player.class);
    player.name = "David Boon";
    System.out.println(player);
    }
}
2. 处理多个依赖 （Multiple Dependencies）

这一小节里面，我们将探讨如何是用  @Inject 注释来处理多个依赖。 比方说有一个对象直接依赖其它两个或者多个对象。这里我们创建一个简单的 Case ，一个人有一台笔记和一个手机。

首先我们给出 Mobile 类和 Laptop 类。

public class Laptop {
 
    private String model;
    private String price;
 
    public Laptop(){
        this.model = "HP 323233232";
        this.price = "$545034";
    }
 
    public String toString(){
        return "[Laptop: " + model + "," + price + "]";
    }
}
public class Mobile {
 
private String number;
 
    public Mobile(){
        this.number = "988438434";
    }
 
    public String toString(){
        return "[Mobile: " + number + "]"; 
    }
}
接下来我们将会在 Person 类中使用  @Inject 注释来直接引用 Laptop 和 Mobile 对象。注意我们这儿使用的是构造方法层次上的注入。

import com.google.inject.Inject;
 
public class Person {
 
    private Mobile mobile;
    private Laptop laptop;
 
    @Inject
    public Person(Mobile mobile, Laptop laptop){
        this.mobile = mobile;
        this.laptop = laptop;
    }
 
    public void diplayInfo(){
        System.out.println("Mobile:" + mobile);
        System.out.println("Laptop:" + laptop);
    }
}
最后是客户端的代码，这段代码用于使用这个例子。由于我们没有使用到 Bindings， 我们没有在 Guice.createInject() 方法中传递 Module 对象。

import com.google.inject.Guice;
import com.google.inject.Injector;
 
public class MultipleDependencyTest {
 
    public static void main(String[] args) {
 
        Injector injector = Guice.createInjector();
        Person person = injector.getInstance(Person.class);
        person.diplayInfo();
    }
}
上面程序的运行结果如下：

 Mobile:[Mobile: 988438434]
Laptop:[Laptop: HP 323233232,$545034]
3. 使用 Binding 注释

在 Guice 中，一个类型不能绑定多个实现，如下，代码会抛 Runtime Error.

binderObject.bind(SomeType.class).to(ImplemenationOne.class);
binderObject.bind(SomeType.class).to(ImplemenationTwo.class);
由于 Guice 并不知道客户端究竟要绑定哪一个实现类，因此抛出了异常。但是在类似 Java 的语言中，一个类可以实现多个接口，基于这个思想，Guice 提供了一种依赖 Binding 注释的方式来实现一个类型绑定多个实现。例如，接口 Player 定义如下，

public interface Player {
 
    public void bat();
    public void bowl();
 
}
接着我们提供了 Player 的两种实现类， GoodPlayer 和 BadPlayer。

public class GoodPlayer implements Player{
 
    public void bat() {
        System.out.println("I can hit any ball");
    }
 
    public void bowl() {
        System.out.println("I can also bowl");
    }
}
public class BadPlayer implements Player{
 
    public void bat() {
        System.out.println("I think i can face the ball");
    }
 
    public void bowl() {
        System.out.println("I dont know bowling");
    }
 
}
现在我们开始介绍 Guice ，对于接口 Player 而言，有两个实现类 GoodPlayer 和 BadPlayer。无论如何，最终客户端只会使用其中一个具体的实现类，无论它使用GoodPlayer 实现类还是 BadPlayer 实现类，通过一些注释机制 （Annotaion mechanisms） 我们可以指示 Guice 使用不同的实现。代码实现如下。

 1 import com.google.inject.*;
 2  
 3 public class PlayerModule implements Module{
 4  
 5     public void configure(Binder binder) {
 6  
 7         binder.bind(Player.class).annotatedWith(Good.class).to(
 8             GoodPlayer.class);
 9         binder.bind(Player.class).annotatedWith(Bad.class).to(
10             BadPlayer.class);        
11     }
12 }
注意第7行和第9行代码，我们分别使用了.annotatedWith(Good.class) 和 .annotatedWith(Bad.class)， 这两处代码指明了如果使用Good注释，那么就绑定GoodPlayer实现类，如果使用了Bad注释，那么就绑定BadPlayer实现类。

上面的代码中我们使用了两个自定义的 Annotation，Good 和 Bad。下面我们给出 Good annotation 和 Bad annotation 的代码。

import java.lang.annotation.*;
import com.google.inject.BindingAnnotation;
 
@Retention(RetentionPolicy.RUNTIME)
@BindingAnnotation
@Target(ElementType. LOCAL_VARIABLE)
public @interface Good {}
import java.lang.annotation.*;
import com.google.inject.BindingAnnotation;
 
@Retention(RetentionPolicy.RUNTIME)
@BindingAnnotation
@Target(ElementType. LOCAL_VARIABLE)
public @interface Bad {}
接下来是上面程序的客户端代码。这里需要注意的是当在客户端代码中请求某一个接口的具体实现的时候，可以直接通过指定不同的 Annotation 来指定返回不同的实现类。

 1 import com.google.inject.Guice;
 2 import com.google.inject.Injector;
 3 import com.google.inject.Module;
 4  
 5 public class PlayerClient {
 6  
 7     public static void main(String[] args) {
 8  
 9         PlayerModule module = new PlayerModule();
10         Injector injector = Guice.createInjector(new Module[]{module});
11  
12         @Good Player player = (Player)injector.getInstance(Player.class);
13         player.bat();
14         player.bowl();
15     }
16 }
此处注意第10行和第12行。 第12行代码 @Good 告诉 Guice 去 Playe Moduler 中获取一个 GoodPlayer实例对象。

4. Named 注释

像上面例子中，如果只是为了标记实现类以便于客户端使用，而为每一个实现类创建新的 Annotation ，那么是完全没有必要的。我们可以使用 @Named 注释来命名这些 entities。这儿有一个工具方法 － Names.named() ，当你给它一个命名，它会返回好一个命名好的 Annotation。例如上面的例子中，在 Player Module 中可以使用 Names.named() 来完成一些相同的事情。

import com.google.inject.Binder;
import com.google.inject.Module;
 
public class PlayerModule implements Module{
 
    public void configure(Binder binder) {
 
        binder.bind(Player.class).annotatedWith(Names.named("Good")).to(
            GoodPlayer.class);
        binder.bind(Player.class).annotatedWith(Names.named("Bad")).to(
        BadPlayer.class);        
    }
 
}
现在在客户端代码中，我们将使用 @Named() annotation来获取注释。

@Named("Good") Player goodPlayer = (Player)injector.getInstance(Player.class);
 
@Named("Bad") Player badPlayer = (Player)injector.getInstance(Player.class);
5. 一个简单的 Provider

在 Guice 中 Providers 就像 Factories 一样创建和返回对象。在大部分情况下，客户端可以直接依赖 Guice 框架来为服务（Services）创建依赖的对象。但是少数情况下，应用程序代码需要为一个特定的类型定制对象创建流程（Object creation process），这样可以控制对象创建的数量，提供缓存（Cache）机制等，这样的话我们就要依赖 Guice 的 Provider 类。

例如，我们需要为 MockConnection 创建一个对象创建和销毁的流程，代码如下。

public class MockConnection {
 
    public void connect(){
        System.out.println("Connecting to the mock database");
    }
 
    public void disConnect(){
        System.out.println("Dis-connecting from the mock database");
    }
 
}
现在我们来写一个简单的 Provider 类来实现 Guice 的 Provider 接口，使用它创建并返 MockConnection对象，代码如下。

public class ConnectionProvider implements Provider<MockConnection>{
 
    @Override
    public MockConnection get() {
 
        // Do some customization mechanism here.
        MockConnection connection = new MockConnection();
        // Do some customization mechanism here too.
        return connection;
    }    
}
需要注意的是，所有的自定义 Provider 类必需实现 Provider 接口，并且重写里面的 get() 方法。现在 Module 需要留意这个自定义的 Provider 类，它需要请求 ConnectionProvider 来创建对象，而不是直接创建对象，实现的代码如下。

 1 import com.google.inject.*;
 2  
 3 public class ConnectionTest {
 4  
 5     public static void main(String args[]){        
 6         Injector injector = Guice.createInjector(
 7             new Module(){
 8                 @Override
 9                 public void configure(Binder binder) {
10                     binder.bind(MockConnection.class).toProvider(
11                         ConnectionProvider.class);                
12                 }                        
13             }                
14         );
15  
16         MockConnection connection = 
17         injector.getInstance(MockConnection.class);
18         connection.connect();
19         connection.disConnect();
20     }
21 }
注意第10行，我们使用 toProvider() 方法将 MockConnection.class 绑定到一个 Provider 上。
=========================
endof Google Guice 系列教程 － 基础实践




getfrom GWT(Google Web Toolkit)入门学习
=======================
http://blog.csdn.net/struts2/article/details/1758122

GWT是 Google Web Toolkit的简称。
GWT使用JSON格式的数据通讯 

GWT是一个以Java语言为工具，以类似Swing的方式编写UI组件，之后通过GWT Compiler编译

为JavaScritp和HTML在客户端浏览器中运行的一个开发工具和编程模型。

 

GWT应用程序有两种方式运行：

Hosted Model

     在Hosted Model方式下，Java程序并不会被编译成JavaScript，GWT只是创造了一个类似

     浏览器的环境，直接运行使用GWT开发的程序。这种模式最具生产力（这种模式下可以Debug所有的Java代码），

     所以开发环境通常使用Hosted Model，但是真正的程序执行不使用这种模式。

Web Model

     就是将使用GWT编写的Java程序整整编译成JavaScript，在Web容器上运行，使用浏览器

     访问的模式，这种方式只有在测试或者运行的时候才使用，每次对Java类的修改必须重新编译

     这些Java类，之后重新部署应用。所以生产力比较低。

 

安装GWT

从如下位置下载GWT的最新版本：

http://code.google.com/webtoolkit/download.html

当前最新的Release版本为1.4.60， 上一个稳定的版本为1.3.3


>>>>>>>>>>>>>
GWT SDK	gwt2.8.0.zip
Plugin for Eclipse (incl. SDKs)	Eclipse 4.5 (Mars)	Plugin for Eclipse 4.5 (Mars) https://dl.google.com/eclipse/plugin/4.5


第一步，安装JDK， 1.4 以上的版本都可以。

第二步，下载GWT压缩文件，这里使用1.4.59 RC2（gwt-windows-1.4.59.zip）


第三布，将GWT压缩文件解压缩到制定的目录，这里我使用的目录为，C:/程序开发/Java/gwt-windows-1.4.59

第四步，安装成功

 

安装之后的目录结构为：

C:/程序开发/Java/gwt-windows-1.4.59

>>>>>>>>>>>>>D:\DevWork\1114to1119_wk47\gwt-2.8.0

    doc（文档目录，开发文档和Java API文档）
    samples（示例代码目录，非常有名的KitchenSink示例代码即在此目录中）

    about.html
    about.txt
    applicationCreator.cmd
    benchmarkViewer.cmd
    COPYING
    COPYING.html
    gwt-benchmark-viewer.jar
    gwt-dev-windows.jar
    gwt-ll.dll
    gwt-module.dtd
    gwt-servlet.jar
    gwt-user.jar
    i18nCreator.cmd
    index.html
    junitCreator.cmd
    projectCreator.cmd
    release_notes.html
    swt-win32-3235.dll

 

使用GWT建立开发

GWT的安装目录下有一个名叫Samples的目录，里边有很多的例子，其中KitchenSink比较全面的展现了GWT的Web组件。

 Prerequisites

You will need the Java SDK version 1.6 or later. If necessary, download and install the Java SE Development Kit (JDK) for your platform. Mac users, see Apple’s Java developer site to download and install the latest version of the Java Developer Kit available for Mac OS X.
Apache Ant is also necessary to run command line arguments. If you don’t already have it, install Apache Ant.
If you have problems running Ant on the Mac, try setting the $JDK_HOME environment variable with export JDK_HOME=“/Library/Java/Home”


in getfrom ant安装、环境变量配置及验证
-------------
http://www.cnblogs.com/yuzhongwusan/archive/2013/03/26/2982411.html
ant安装、环境变量配置及验证
一、安装ant
到官方主页http://ant.apache.org下载新版（目前为Ant1.8.1）的ant，得到的是一个apache-ant-1.8.1-bin.zip的压缩包。将其解压到你的硬盘上，例如：C:\apache-ant-1.8.1。
.zip archive: apache-ant-1.9.7-bin.zip [PGP] [SHA1] [SHA512] [MD5] -for windows
.tar.gz archive: apache-ant-1.9.7-bin.tar.gz [PGP] [SHA1] [SHA512] [MD5] -for linux
.tar.bz2 archive: apache-ant-1.9.7-bin.tar.bz2 [PGP] [SHA1] [SHA512] [MD5]	-for linux

二、配置环境变量

window中设置ant环境变量：

ANT_HOME    C:/ apache-ant-1.8.1
D:\DevWork\1114to1119_wk47\apache-ant-1.9.7

path             C:/ apache-ant-1.8.1/bin
%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;C:\Program Files\nodejs\;C:\Program Files\Git\cmd;%MAVEN_HOME%\bin;%ANT_HOME%\bin;

classpath      C:/apache-ant-1.8.1/lib
E:\01WangSongLesson\00eclipse\jre\lib;D:\DevWork\1114to1119_wk47\apache-ant-1.9.7;

注意：【
　　配置环境变量：我的电脑----属性-----高级----环境变量
      如：ANT_HOME：C:\apache-ant-1.8.1
      PATH：%ANT_HOME%\bin （为了方便在dos环境下操作）
     实验了总是失败，没办法换成地址 C:/ apache-ant-1.8.1/bin，而不再使用变量。。。成功了。。
】
三、验证ant

为了验证ant是否成功安装，可以进行如下操作：

依次选择：开始->运行->cmd，输入如下命令：ant

如果出现如下内容，说明安装成功：

Buildfile: build.xml does not exist!

Build failed
【说明ant安装成功！因为ant默认运行build.xml文件，这个文件需要我们建立。】

查看版本：ant  -version


但如果出现如下内容，说明安装失败：（可以重复前述步骤，直至安装成功。）

'ant' 不是内部或外部命令，也不是可运行的程序或批处理文件。

 

从别处移动过来的：

使用：
(1)在D盘根目录下建立build.xml

1<?xml version="1.0" encoding="GBK"?>
2<project name="测试脚本" default="copyfile" basedir="." >
3   <target name="copyfile">
4      <copy file="d:/a.txt" todir="e:/Temp" overwrite="true" />
5   </target>
6</project>

（2）在D盘根目录下建立文件a.txt。
（3）进入dos，
         d:
         ant
         
         此时可在E:/Temp目录下见到文件aa.txt，内容与a.txt一样，即拷贝成功！
=outlog
C:\Documents and Settings\Administrator>d:

D:\>ant
Buildfile: D:\build.xml

copyfile:
     [copy] Copying 1 file to e:\Temp

BUILD SUCCESSFUL
Total time: 1 second
=outlog		
 
dos下如何查看文件内容_百度知道
通过“type”命令查看。用法一:直接“typeE:\\test.txt”(绝对路径)。用法二:如果是在相对路径下,直接“typetest.txt”即可。备注:dos窗口只能是打开...		 
-------------
in endof ant安装、环境变量配置及验证

applicationCreator创建一个可以以Hosted Mode形式运行的GWT应用程序，

以下命令将建立一个工程

...........
http://www.gwtproject.org/gettingstarted.html
Windows
cd gwt-2.7.0
webAppCreator -out MyWebApp com.mycompany.mywebapp.MyWebApp


=outlog
D:\DevWork\1114to1119_wk47\gwt-2.8.0>webAppCreator -out MyWebApp com.mycompany.m
ywebapp.MyWebApp
Generating from templates: [sample, eclipse, readme, ant]
Not creating tests because -junit argument was not specified.

Created directory MyWebApp
Created directory MyWebApp\src
Created directory MyWebApp\src\com\mycompany\mywebapp
Created directory MyWebApp\src\com\mycompany\mywebapp\client
Created directory MyWebApp\src\com\mycompany\mywebapp\server
Created directory MyWebApp\src\com\mycompany\mywebapp\shared
Created directory MyWebApp\test
Created directory MyWebApp\test\com\mycompany\mywebapp
Created directory MyWebApp\war
Created directory MyWebApp\war\WEB-INF
Created file MyWebApp\src\com\mycompany\mywebapp\MyWebApp.gwt.xml
Created file MyWebApp\src\com\mycompany\mywebapp\client\GreetingService.java
Created file MyWebApp\src\com\mycompany\mywebapp\client\GreetingServiceAsync.jav
a
Created file MyWebApp\src\com\mycompany\mywebapp\client\MyWebApp.java
Created file MyWebApp\src\com\mycompany\mywebapp\server\GreetingServiceImpl.java

Created file MyWebApp\src\com\mycompany\mywebapp\shared\FieldVerifier.java
Created file MyWebApp\war\WEB-INF\web.xml
Created file MyWebApp\war\MyWebApp.css
Created file MyWebApp\war\MyWebApp.html
Created file MyWebApp\war\favicon.ico
Created file MyWebApp\.classpath
Created file MyWebApp\.project
Created file MyWebApp\MyWebApp.launch
Created file MyWebApp\README.txt
Created file MyWebApp\build.xml

=outlog
Run locally in development mode

To run your newly created application in development mode:
cd MyWebApp/
ant devmode
=outlog ant devmode
D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp>ant devmode
Buildfile: D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\build.xml

libs:
    [mkdir] Created dir: D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\WEB-I
NF\lib
     [copy] Copying 1 file to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\
WEB-INF\lib
     [copy] Copying 1 file to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\
WEB-INF\lib

javac:
    [mkdir] Created dir: D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\WEB-I
NF\classes
    [javac] D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\build.xml:31: warning:
 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to
false for repeatable builds
    [javac] Compiling 5 source files to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyW
ebApp\war\WEB-INF\classes
     [copy] Copying 1 file to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\
WEB-INF\classes

devmode:
     [java] Super Dev Mode starting up
     [java]    workDir: C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\gwt-codeserver-651723
3477508306588.tmp
     [java] 2016-11-13 12:45:05.750:INFO::main: Logging initialized @17953ms
     [java]    Loading Java files in com.mycompany.mywebapp.MyWebApp.

	 
	 
	 in outlog
	      [java]    Module setup completed in 29688 ms
     [java] 2016-11-13 12:49:06.390:INFO:oejs.Server:main: jetty-9.2.z-SNAPSHOT
     [java] 2016-11-13 12:49:07.171:INFO:oejsh.ContextHandler:main: Started o.e.
j.s.ServletContextHandler@1d53f2e{/,null,AVAILABLE}
     [java] 2016-11-13 12:49:09.031:INFO:oejs.ServerConnector:main: Started Serv
erConnector@1e242e6{HTTP/1.1}{127.0.0.1:9876}
     [java] 2016-11-13 12:49:09.031:INFO:oejs.Server:main: Started @261250ms
     [java]
     [java] The code server is ready at http://127.0.0.1:9876/
     [java] 2016-11-13 12:49:12.453:INFO:oejs.Server:main: jetty-9.2.z-SNAPSHOT
     [java] 2016-11-13 12:49:22.015:INFO:oejsh.ContextHandler:main: Started c.g.
g.d.s.j.WebAppContextWithReload@1c2de91{/,file:/D:/DevWork/1114to1119_wk47/gwt-2
.8.0/MyWebApp/war/,AVAILABLE}{D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war}

     [java] 2016-11-13 12:49:22.140:INFO:oejs.ServerConnector:main: Started Serv
erConnector@102fec3{HTTP/1.1}{127.0.0.1:8888}
     [java] 2016-11-13 12:49:22.140:INFO:oejs.Server:main: Started @274359ms

>>>>>>>>>>>>
http://127.0.0.1:8888/
Compiling mywebapp
	
	
	Web Application Starter Project
	
	in outlog=
	Sending name to the server:
GWT User

Server replies:
Hello, GWT User!

I am running jetty/9.2.z-SNAPSHOT.

It looks like you are using:
Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36
	end in outlog=
	
	http://127.0.0.1:9876/mywebapp/
	
	in web outlog=
		mywebapp (GWT Code Server)

Messages from the last time this module was compiled.

Source from the last time this module was compiled.

Output Files

(From the last successful compile.)

AF57087D859AB46CB3FD95369AC7099E.cache.js
clear.cache.gif
compilation-mappings.txt
EDE2AF6509597DC70F62D0E11AA4E732.gwt.rpc
mywebapp.devmode.js
mywebapp.nocache.js
mywebapp.recompile.nocache.js
	end in web outlog=
	
=outlog

This command starts GWT’s development mode server, a local server used for development and debugging, as follows:

Screenshot
Launch the local server in a browser by either 1) clicking “Launch Default Browser” or 2) clicking “Copy to Clipboard” (to copy its URL), then pasting into Firefox, Internet Explorer, Chrome, or Safari.

The starter application will load in Super Dev Mode as follows:


Make a few changes

The source code for the starter application is in the MyWebApp/src/ subdirectory, where MyWebApp is the name you gave to the project above. You’ll see two packages, com.mycompany.mywebapp.client and com.mycompany.mywebapp.server. Inside the client package is code that will eventually be compiled to JavaScript and run as client code in the browser. The java files in the server package will be run as Java bytecode on a server, in the case of this Quick Start on the App Engine servers.

Look inside com/mycompany/mywebapp/client/MyWebApp.java. Line 41 constructs the “Send” button.
D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\src\com\mycompany\mywebapp\client

final Button sendButton = new Button("Send");
Change the text from “Send” to “Send to Server”.

final Button sendButton = new Button("Send to Server");
Now, save the file and simply click “Refresh” in your browser to see your change. The button should now say “Send to Server” instead of “Send”:

Compile and run in production mode

To run the application as JavaScript in what GWT calls “production mode”, compile the application by executing:

ant build

in outlog=
     [java]    Resolving java.util.function.ToLongBiFunction
     [java]       Found type 'java.util.function.ToLongBiFunction'
     [java]          [WARN] Ignoring unresolvable annotation type java.lang.Func
tionalInterface
     [java]    Compiling 5 permutations
     [java]       Compiling permutation 0...
     [java]       Compiling permutation 1...
     [java]       Compiling permutation 2...
     [java]       Compiling permutation 3...
     [java]       Compiling permutation 4...
     [java]    Compile of permutations succeeded
     [java]    Compilation succeeded -- 83.563s
     [java] Linking into D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\myweb
app
     [java]    Link succeeded
     [java]    Linking succeeded -- 0.922s

build:

BUILD SUCCESSFUL
Total time: 1 minute 43 seconds

D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp>

and inoutlog=
The “build” Ant target invokes the GWT compiler which generates a number of JavaScript and HTML files from the MyWebApp Java source code in the MyWebApp/war/ subdirectory. To see the application, open the file MyWebApp/war/MyWebApp.html in your web browser. The application should look identical to the development mode above.

Congratulations! You’ve created your first web application using GWT. Since you’ve compiled the project, you’re now running pure JavaScript and HTML that works in IE, Chrome, Firefox, Safari, and Opera. You could now deploy your application to production by serving the HTML and JavaScript files in your MyWebApp/war/ directory from your web servers.
D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war

Set up an IDE

Now that you’ve created your first app, you probably want to do something a bit more interesting. But first, if you normally work with an IDE you’ll want to set up Eclipse to use the GWT SDK:

Set up Eclipse

If you are going to stick with the command line, check out Speed Tracer and then head over to Build a Sample GWT App.
.........

in getfrom google plungin for eclipse Quick Start
.........................
Quick Start

This guide walks you through creating and deploying your first web application. For more details, please see the User's Guide.

Installing the plugin
Creating your first Web Application
Running your Web Application locally
Deploying your Web Application
App Engine does not yet support Java 8. You can build with version 8 of the JDK locally if and only if you set the Compiler compliance level for your project to Java 1.7. You cannot deploy an application that requires Java 8 to App Engine.

You can install the Google Plugin for Eclipse using the software update feature of Eclipse. Be sure to use the plugin that corresponds to your version of Eclipse. Follow the installation instructions provided at the links below or, if you are familiar with installing Eclipse plugins, you can simply paste the appropriate plugin link directly into Eclipse.

Eclipse version	Installation instructions	Direct plugin link
Eclipse 4.6 (Neon)	Plugin for Eclipse 4.6 (Neon)	https://dl.google.com/eclipse/plugin/4.6
Eclipse 4.5 (Mars)	Plugin for Eclipse 4.5 (Mars)	https://dl.google.com/eclipse/plugin/4.5
Eclipse 4.4 (Luna)	Plugin for Eclipse 4.4 (Luna)	https://dl.google.com/eclipse/plugin/4.4
If you are looking for older versions of the plugin, click here.

If you are having trouble installing from the update sites (due to firewall issues, for instance), you can install the Google Plugin for Eclipse by downloading and installing an archive of the update site.

Creating your first Web Application

To create your first Web Application, select File > New > Web Application Project from the Eclipse menu.

In the New Web Application Project wizard, enter a name for your project and a java package name, e.g., com.example.mywebapp. You can specify a project ID or choose not to (see Setting Project ID in New Web Application Project wizard for more details). Click Finish.

Note: Using Java keywords as a project name (e.g. "New" and "Class") will result in various build errors. Avoid these where possible.

Congratulations, you now have an App Engine and GWT-enabled web application!

Running your Web Application locally

Right-click on your web application project and select Debug As > Web Application from the popup menu. You are testing your application using the Java Development Server.

This action creates an Eclipse Web Application launch configuration for you and launches it. The web application launch configuration will start a server, whose URL will appear in the Development Mode view at the bottom of the Eclipse window. Select the URL and click Copy in the context menu, and then open it in your web browser to load the application.

At this point, you can set breakpoints, inspect variables and modify code as you would normally expect from a Java Eclipse debugging session.

Deploying your Web Application

To deploy your web application, you need to create an App Engine project (not to be confused with the Eclipse project) in the Google Developers Console. If you already have an App Engine project, then you can skip this step.

Once you have an App Engine project ID, right-click on your Eclipse project, and select Google > App Engine Settings... from the context menu. Enter your project ID into the Project ID text box. Click OK.

Right-click on your project and select Google > Deploy to App Engine. If you haven't already signed in using your Google account, you will be prompted to do so. See Sign In for more details.

Click Deploy.

Go to http://project-id.appspot.com/ to see your application.
........................
in endof google plungin for eclipse Quick Start





in getfrom Google Plugin for Eclipse 4.5 (Mars) Installation Instructions
........................
https://developers.google.com/eclipse/docs/install-eclipse-4.5

Google Plugin for Eclipse 4.5 (Mars) Installation Instructions

This procedure installs the Google Plugin for Eclipse and optionally the Android Developer Tools, the GWT SDK, and the Google App Engine SDK. If you are not running Eclipse version 4.5 (Mars), please consult Downloading and Installing the Plugin for the correct plugin version to use.

Start Eclipse, running JVM version 1.7.0 or later.
Select Help > Install New Software... In the dialog that appears, enter the update site URL into the Work with text box:

https://dl.google.com/eclipse/plugin/4.5

And press the enter key.

The required component is Google Plugin for Eclipse. Select the checkbox next to Google Plugin for Eclipse 4.4/4.5/4.6.
If you want to install the Android Developer Tools, select the checkbox next to Developer Tools.
If you want to install the Google App Engine Java SDK, select the checkbox next to Google App Engine Engine Java SDK.
If you want to install the developer tooling for Cloud Endpoints and Android, select the checkboxes next to Developer Tools and Google App Engine Tools for Android.
If you want to install the Maven Integration for Google App Engine, select the checkbox next to Google App Engine Maven Integration.
See Importing an existing Maven Project for more information.

Note: If you are installing the plugin on a multi-user install of Eclipse, please see this FAQ entry. 

Installing the SDKs is optional; you can always install them later on. 

If you are having trouble installing from the update site, please see this FAQ entry.

Click Next.
Review the features that you are about to install. Click Next.
Read the license agreements and then select I accept the terms of the license agreements. Click Finish.

Click OK on the Security Warning.

You will then be asked if you would like to restart Eclipse. Click Restart Now.
xxxxxxxxxxxxx
An internal error occurred during: "Initializing Java Tooling".
java.lang.NullPointerException
xxxxxxxxxxxxx

Now you are ready to build App Engine web applications and mobile backends for your Android applications. If you encountered issues during the installation, please see the FAQ.

..........................
in endof Google Plugin for Eclipse 4.5 (Mars) Installation Instructions

in getfrom Google Plugin for Eclipse Creating a New Web Application
..........................
Creating a New Web Application

Launching the New Web Application Wizard

To create a new project, click on the  New Web Application Project toolbar button. You can also access this wizard by selecting the Web Application Project item from the drop-down menu associated with the  New toolbar button, or by selecting File > New > Web Application Project.

Creating a Project with the New Web Application Wizard

The New Web Application Project wizard allows you to create a new web application that uses GWT and/or Google App Engine:

>>>>>>>>>>MyTestProject
com.huangyong.gwt


The wizard allows you to choose a name and root package for the project. The project's name will be used when generating the names of the classes in the sample application. All of the classes will live in a subpackage of the root package.

Note: Using Java keywords as a project name (e.g. "New" and "Class") will result in various build errors. Avoid these where possible.

In the Google SDKs group box, you can choose which SDKs that you'd like to use in your Web Application. See Using SDKs for more details.

----------Help->Install New Software->点击"already installed"：

In the Identifiers for Google App Engine group box, you can choose to specify a project ID or choose to leave the project ID field blank. See Setting Project ID in New Web Application Project wizards for more details.

Click on the Finish button to create the project.

Generated Project Structure

The sample application generated by the New Web Application Wizard will have a src/ directory for Java source files and a war/ directory for compiled classes, server runtime libraries, static content, and configuration files.

The generated files will differ depending on whether your application is using GWT, App Engine, or both. The sections below highlight the differences between the generated sample for a project named MyTestProject with a root package of com.mytestproject.

If you make a mistake and delete some of the essential resources in the war directory, don't worry! You can easily fix these problems.

GWT

These are the files that are generated for the GWT sample:

MyTestProject
  src/
    com/
      mytestproject/
        MyTestProject.gwt.xml        
        client/
          GreetingService.java
          GreetingServiceAsync.java
          MyTestProject.java      
        server/
          GreetingServiceImpl.java
  war/  
    MyTestProject.css
    MyTestProject.html
    WEB-INF/
      web.xml
      classes/
      lib/
       ...GWT JARs...         
The GWT sample application consists of a simple user interface with a single button. When you press the button, a Remote Procedure Call is performed to get the current time on the server. The results of the call are then displayed in the interface. See GWT's documentation for more information about the project's contents.

App Engine

These are the files that are generated for the App Engine sample:

MyTestProject
  src/
    log4j.properties
    META-INF/
      jdoconfig.xml
    com/
      mytestproject/
        MyTestProjectServlet.java
  war/  
    index.html
    WEB-INF/
      appengine-web.xml
      web.xml
      logging.properties
      classes/
      lib/
       ...App Engine JARs...            
The App Engine sample application consists of a servlet which prints "Hello, World!". The application also has some configuration files for deployment and logging.

GWT + App Engine

When using both the GWT and App Engine SDKs, the following sample application is generated:

MyTestProject
  src/
    log4j.properties
    META-INF/
      jdoconfig.xml
    com/
      mytestproject/
        MyTestProject.gwt.xml        
        client/
          GreetingService.java
          GreetingServiceAsync.java
          MyTestProject.java      
        server/
          GreetingServiceImpl.java
  war/  
    MyTestProject.css
    MyTestProject.html
    WEB-INF/
      appengine-web.xml
      web.xml
      logging.properties
      classes/
      lib/
        ...App Engine JARs...    
        ...GWT JARs... 
The GWT + App Engine sample application is similar in functionality to the GWT sample application. The main difference is that the server component is meant to run on App Engine, so the App Engine configuration files are generated as well.
..............................
in endof Google Plugin for Eclipse Creating a New Web Application


in getfrom Google Plugin for Eclipse Running and Debugging
....................
Running and Debugging

Creating a Launch Configuration

If you created a project using the New Web Application Wizard, a launch configuration will have already been created for you. It can be found by navigating to the Launch Configuration dialog. Select the Run Configurations... item from the drop-down menu associated with the  Run toolbar button:

xxxxxxxxxxxx
Runing CodeServer with parameters: [-noprecompile, -port, 9876, -sourceLevel, 1.7, -bindAddress, 127.0.0.1, -launcherDir, D:\eclipse_jee\MyTestProject2\war, -logLevel, INFO, com.huangyong.gwt.MyTestProject2]
Super Dev Mode starting up
   workDir: C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\gwt-codeserver-2982398748530107542.tmp
Initializing App Engine server
   Loading Java files in com.huangyong.gwt.MyTestProject2.
十一月 13, 2016 5:59:48 下午 com.google.appengine.tools.info.RemoteVersionFactory getVersion
信息: Unable to access http://appengine.google.com/api/updatecheck?runtime=java&release=1.9.34&timestamp=1455219375&api_versions=['1.0']
java.net.ConnectException: Connection timed out: connect
	at java.net.TwoStacksPlainSocketImpl.socketConnect(Native Method)
	at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)
	at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)
	at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)
	at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)
	at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
	at java.net.Socket.connect(Socket.java:579)
	at java.net.Socket.connect(Socket.java:528)
	at sun.net.NetworkClient.doConnect(NetworkClient.java:180)
	at sun.net.www.http.HttpClient.openServer(HttpClient.java:432)
	at sun.net.www.http.HttpClient.openServer(HttpClient.java:527)
	at sun.net.www.http.HttpClient.<init>(HttpClient.java:211)
	at sun.net.www.http.HttpClient.New(HttpClient.java:308)
	at sun.net.www.http.HttpClient.New(HttpClient.java:326)
	at sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:997)
	at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:933)
	at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:851)
	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1301)
	at java.net.URL.openStream(URL.java:1037)
	at com.google.appengine.tools.info.RemoteVersionFactory.getVersion(RemoteVersionFactory.java:76)
	at com.google.appengine.tools.info.UpdateCheck.getApplicationVersionInfo(UpdateCheck.java:153)
	at com.google.appengine.tools.info.UpdateCheck.maybePrintNagScreen(UpdateCheck.java:361)
	at com.google.appengine.tools.development.gwt.AppEngineLauncher.maybePerformUpdateCheck(AppEngineLauncher.java:115)
	at com.google.appengine.tools.development.gwt.AppEngineLauncher.start(AppEngineLauncher.java:81)
	at com.google.gwt.dev.DevMode.doStartUpServer(DevMode.java:632)
	at com.google.gwt.dev.DevModeBase.startUp(DevModeBase.java:1054)
	at com.google.gwt.dev.DevModeBase.run(DevModeBase.java:836)
	at com.google.gwt.dev.DevMode.main(DevMode.java:413)

十一月 13, 2016 6:00:10 下午 com.google.appengine.tools.development.SystemPropertiesManager setSystemProperties
信息: Overwriting system property key 'java.util.logging.config.file', value 'E:\01WangSongLesson\00eclipse\plugins\com.google.appengine.eclipse.sdkbundle_1.9.34\appengine-java-sdk-1.9.34\config\sdk\logging.properties' with value 'WEB-INF/logging.properties' from 'D:\eclipse_jee\MyTestProject2\war\WEB-INF\appengine-web.xml'
十一月 13, 2016 6:00:23 下午 com.google.apphosting.utils.jetty.JettyLogger info
信息: Logging to JettyLogger(null) via com.google.apphosting.utils.jetty.JettyLogger

xxxxxxxxxxxx
http://127.0.0.1:8888/MyTestProject2.html

If you're interested in debugging your application, select the Debug Configurations... item from the drop-down menu associated with the  Debug toolbar button.

Tip: You can also launch your application by right-clicking the project (or an HTML or JSP page within the project) and selecting Run As/Debug As > Web Application from the context menu.

Now, expand the items underneath the Web Application category. You should see a launch configuration with a name matching your project name. Click on the launch configuration.



Notice that the Web Application launch configuration has the Main, Server, GWT, App Engine, and Arguments tabs. The Main tab allows you to choose the project that is associated with the launch configuration and change the main class for the launch. The Server tab allows you to choose a different port for the built-in server. In general, you'll want to run the built-in server, unless you have a specific server instance that you want to test against.

GWT Settings

The GWT settings tab contains the GWT settings for the launch configuration.



In addition to customizing the log level, you can also tweak the set of Available Modules for the launch. All modules you want to access during the Development Mode launch must be included in this list (excluding any inherited modules). The actual set of modules that will be loaded at startup will be determined by the HTML page you launch with (more on this later).

Additional Arguments

If you need to change settings that are not represented on the Main, Server, GWT, or App Engine tabs, you can switch to the Arguments tab and enter them alongside the computed arguments.

Running the Launch Configuration

To launch the web application, click on the Run button in the lower-right corner of the Run Configurations dialog. You can also run your application via context menu shortcuts. To do this, select either a project, a GWT Module file, or an HTML/JSP page in the project's WAR directory. Then, run the application by navigating to Run As > Web Application. Notice that after you run the launch configuration, it will appear in the Run shortcut list:



GWT and GWT + App Engine Applications

If your project uses GWT, the development mode view will appear shortly after launching the application:



Notice that your launch configuration is listed in the view, along with some suggested URLs to start up your GWT application. Copy the URL for your application into the browser's address bar by selecting the entry and choosing Copy from the context menu. Once you have navigated to the startup URL in your browser, you'll notice that a browser entry will be added to the launch configuration:



After a few seconds, you'll notice that loading messages for the GWT modules in your application will appear in the view, indicating that your GWT Application is starting up. Finally, you'll see your application appear in the browser window.

The development mode view is useful for troubleshooting problems with your GWT application. By turning up the log level for the launch configuration, you can see more detailed information about your application's execution. You can search for text within a log by using the filter text field.

When using the view, don't forget about the view's toolbar, which can be used to switch the layout of the view, terminate a launch, clear terminated launch configurations, and restart the embedded web server. The alternate layout presents the launch configurations and browsers in a tree, with browsers as children of their associated launch configuration.

If your project uses Google App Engine and GWT, the only difference is that the embedded server is actually the Google App Engine development server.

Note: If your application uses GWT and you make change to your code during a debugging session, you may need to click Refresh in your browser or Restart Server in the development mode view. See the GWT documentation on development mode debugging for more details.

App Engine-only Applications

If your application uses App Engine but not GWT, the only indication that the App Engine development server is running will be output in the Console view. App Engine-only launches will not appear in the development mode view. The console output includes the URL of the server, which by default is http://localhost:8888/. You can change the port number via Eclipse's launch configuration dialog by selecting your Web Application launch and editing the Port value on the Main tab.

If you open a web browser and navigate to the server's address you should see a welcome page with links to any servlets defined by the application.


..................
in endof Google Plugin for Eclipse Running and Debugging

 >>>>>>>>>>>>>
 @java -cp "%~dp0\gwt-user.jar;%~dp0\gwt-dev.jar" com.google.gwt.user.tools.WebAppCreator %*
 
	webAppCreator.cmd -eclipse GWTLogon -out GWTLogon com.jpleausre.gwt.logon.client.GWTLogon
	
	xxxxxxxxxxxx
	D:\DevWork\1114to1119_wk47\gwt-2.8.0>webAppCreator.cmd -eclipse GWTLogon -out GW
TLogon com.jpleausre.gwt.logon.client.GWTLogon
Unknown argument: -eclipse
Google Web Toolkit 2.8.0
WebAppCreator [-[no]overwriteFiles] [-[no]ignoreExistingFiles] [-templates templ
ate1,template2,...] [-out dir] [-junit pathToJUnitJar] [-[no]maven] [-[no]ant] m
oduleName

where
  -[no]overwriteFiles       Overwrite any existing files. (defaults to OFF)
  -[no]ignoreExistingFiles  Ignore any existing files; do not overwrite. (defaul
ts to OFF)
  -templates                Specifies the template(s) to use (comma separeted).
Defaults to 'sample,ant,eclipse,readme'
  -out                      The directory to write output files into (defaults t
o current)
  -junit                    Specifies the path to your junit.jar (optional)
  -[no]maven                DEPRECATED: Create a maven2 project structure and po
m file (default disabled). Equivalent to specifying 'maven' in the list of templ
ates. (defaults to OFF)
  -[no]ant                  DEPRECATED: Create an ant configuration file. Equiva
lent to specifying 'ant' in the list of templates. (defaults to OFF)
and
  moduleName                The name of the module to create (e.g. com.example.m
yapp.MyApp)

	xxxxxxxxxxxx
	
	webAppCreator.cmd  -out GWTLogon com.jpleausre.gwt.logon.client.GWTLogon
	

C:/程序开发/Java/gwt-windows-1.4.59>applicationCreator.cmd -eclipse GWTLogon -out GWTLogon com.jpleausre.gwt.logon.client.GWTLogon
Created directory GWTLogon/src
Created directory GWTLogon/src/com/jpleausre/gwt/logon
Created directory GWTLogon/src/com/jpleausre/gwt/logon/client
Created directory GWTLogon/src/com/jpleausre/gwt/logon/public
Created file GWTLogon/src/com/jpleausre/gwt/logon/GWTLogon.gwt.xml
Created file GWTLogon/src/com/jpleausre/gwt/logon/public/GWTLogon.html
Created file GWTLogon/src/com/jpleausre/gwt/logon/client/GWTLogon.java
Created file GWTLogon/GWTLogon.launch
Created file GWTLogon/GWTLogon-shell.cmd
Created file GWTLogon/GWTLogon-compile.cmd

 

运行GWTLogon-shell.cmd可以看到GWT启动的服务端的Google Web Toolkit Development Shell，如下图：


和如下的Host Mode的浏览器：



点击其中的 Click Me 按钮，可以看到输出的Hello World！。 
projectCreator建立一个基于ant构建的，或者基于eclipse的GWT开发工程，

例如：

C:/程序开发/Java/gwt-windows-1.4.59>projectCreator.cmd -ant GWTLogon -eclipse GWTLogon -out GWTLogon
Created directory GWTLogon/src
Created directory GWTLogon/test
Created file GWTLogon/GWTLogon.ant.xml
Created file GWTLogon/.project
Created file GWTLogon/.classpath

 

其中的GWTLogon.ant.xml构建文件的内容为：

 <?xml version="1.0" encoding="utf-8" ?>
<project name="GWTLogon" default="compile" basedir=".">
  <description>
    GWTLogon build file.  This is used to package up your project as a jar,
    if you want to distribute it.  This isn't needed for normal operation.
  </description>

  <!-- set classpath -->
  <path id="project.class.path">
    <pathelement path="${java.class.path}/"/>
    <pathelement path="C:/程序开发/Java/gwt-windows-1.4.59/gwt-user.jar"/>
    <!-- Additional dependencies (such as junit) Go here -->
  </path>

  <target name="compile" description="Compile src to bin">
    <mkdir dir="bin"/>
    <javac srcdir="src:test" destdir="bin" includes="**" debug="on" debuglevel="lines,vars,source" source="1.4">
      <classpath refid="project.class.path"/>
    </javac>
  </target>

  <target name="package" depends="compile" description="Package up the project as a jar">
    <jar destfile="GWTLogon.jar">
      <fileset dir="bin">
        <include name="**/*.class"/>
      </fileset>
      <!-- Get everything; source, modules, html files -->
      <fileset dir="src">
        <include name="**"/>
      </fileset>
      <fileset dir="test">
        <include name="**"/>
      </fileset>
    </jar>
  </target>

  <target name="clean">
    <!-- Delete the bin directory tree -->
    <delete file="GWTLogon.jar"/>
    <delete>
      <fileset dir="bin" includes="**/*.class"/>
    </delete>
  </target>

  <target name="all" depends="package"/>

</project>


 

applicationCreator和projectCreator的区别是

applicationCreator创建了src目录和Demo代码，projectCreator不创建Demo代码，但是创建src目录和test目录。

applicationCreator创建了启动脚本GWTLogon-shell.cmd和GWT编译脚本GWTLogon-compile.cmd，而projectCreator不创建。

applicationCreator创建了eclipse launch文件，而projectCreator创建.classpath和.project文件。

 

通常情况下，我们先使用projectCreator创建按project，projectCreator创建的工程可以轻松的import到eclipse中，

之后我们使用applicationCreator创建需要的Java示例代码，eclipse launch文件，启动脚本和编译脚本。

 

使用Eclipse导入的GWT工程如下：

 


 

命令列表

projectCreator 
生成基本项目框架，可以选择使用eclipse或者使用ant构建文件

 

applicationCreator 
生成代码示例和一个可运行的应用程序

 

junitCreator 
生成一个JUnit测试Case

 

i18nCreator

生成一个i18n属性文件和对应的Javascript脚本。


benchmarkViewer 
显示benchmark结果

 

功能介绍（通用）

GWT体系结构

 


GWT Java-to-JavaScript Compiler
将Java程序翻译为JavaScript，通过GWT Compiler可以让GWT程序在Web 模式下运行
GWT Hosted Web Browser
GWT Hosted Web Brower让你的程序可以在Hosted模式下运行，在Hosted模式下运行的是Java代码而不是编译出来的JavaScript代码，在Hosted模式下可以轻松的做Debug。

JRE emulation library
可以称为JRE简化的类库。在客户端（用来编译成JavaScript代码的客户端Java代码）不是所有的java类库都被gwt支持，只有部分被支持，这些类库是几乎所有的java.lang包，java.util包的一部分。
GWT Web UI class library
使用GWT Web UI类库可以创建web 浏览器的组件，例如按钮，文本框，图片等。这是GWT的核心UI类库。

 

 


功能介绍（Web控件）

Web控件是GWT表示层的核心，通过使用GWT提供的Web控件可以创建丰富的客户端画面。

GWT的web组件主要分为两类：输入控件和Layout控件。

 


输入控件主要是指向服务器提交数据，处理操作，显示服务器数据的空间，主要包括：

Button，RadionButton，PushButton，ToggleButton，CheckBox，TextBox，PasswordBox

TextArea, HyperLink,ListBox,MenuBar,Tree,Table, TabBar,DialogBox, PopupPanel

RichTextArea, DisclosurePanel, SuggestBox


Layout 空间主要用来有规律地放置输入控件，主要包括：

Stackpanel,HorizontalPanel,VerticalPanel, FlowPanel, VerticalSplitPanel, HorizontalSplitPanel,

DockPanel, TabPanel,

 

事件模型（Event & Listener）
如何处理页面的事件呢，例如点击按钮，Textbox失去焦点等？

如下的代码建立了一个按钮，按钮的名字是“Click Me”，当你点击这个按钮的时候处罚一个Click事件，Click事件触发onClick(Widget sender)方法。

sender表示触发onClick方法的组件，这里只是简单的在页面上显示Hello World信息（相当于javascript的alert方法）。

 Button b = new Button("Click Me");
 b.addClickListener(new ClickListener() {
  public void onClick(Widget sender) {
    Window.alert("Hello World");
  }
});

常见的Listener如下：

ChangeListener 
ClickListener 
FocusListener
KeyboardListener
MouseListener
MouseWheelListener
PopupListener
ScrollListener
TableListener
TreeListener

功能介绍（远过程调用RPC）

    体系结构

GWT应用中页面一旦加载，就再也不会向服务器请求HTML内容，所有的画面迁移，转换都在客户端进行，但是数据还是会向服务器提交，或者从服务器获取。

服务器上负责处理数据的对象在GWT中叫做Service，每个Service有三个类组成：服务方法定义接口（Service），异步调用接口（ServiceAsync）和服务器方法实现类ServiceImpl。

以Login为例子说明：

 

// 服务方法定义接口

public interface LoginService extends RemoteService {
    public boolean login(LoginSO login) throws ApplicationException;
}


// 异步调用接口

public interface LoginServiceAsync {
    void login(LoginSO login, AsyncCallback async);
}


// 服务器方法实现类

 public class LoginServiceImpl extends RemoteServiceServlet implements LoginService {
    public boolean login(LoginSO login) throws ApplicationException {
        ...

        return true; 

    }
}

 

其中前两个接口在client包内部，最后一个实现在server包内部。

 

客户端调用一个服务类的方法的代码如下：

 

LoginServiceAsync ourInstance = (LoginServiceAsync) GWT.create(LoginService.class); // 
((ServiceDefTarget) ourInstance).setServiceEntryPoint(GWT.getModuleBaseURL() + "/LoginService"); // 


ourInstance.login(loginSO, new AsyncCallback() {   //

    public void onFailure(Throwable caught) {         //
        if(caught instanceof InvocationException) {
            // system exception
        } else {
            Window.alert(" " + GWTShowConstants.Messages.constants.maxQueryCount());
            // aplication exception
        }

    }

    public void onSuccess(Object result) {            //
        Window.alert("success");
    }

});

 

// 

 

 远程调用

 获得服务器方法的调用接口（skeleton）。

 设置服务位置。

 远程调用服务器上的方法，注意这里是异步调用，在和调用之前代码可能先被调用了。

 调用出错，或者调用方法抛出异常的时候调用的方法。

 调用成功返回时候调用的方法。

 

 

    参数和返回值系列化类型

这里的参数指的是Service方法调用的参数和返回值。

由于GWT的客户端代码都是JavaScript，而服务器代码都是使用Java编写的，这就涉及到JavaScript调用Java方法的时候

如何传递参数，如何取得返回值的问题。

 

 可序列化的类型包括：

（1） 原始类型，例如：char, byte, short, int, long, boolean, float, double;

（2） String，java.util.Date，或者原始类型的包装类型，例如：  Character, Byte, Short, Integer, Long, Boolean, Float, or Double;

（3） 可序列化类型数组（包含（4）和（5）定义的类型）

（4） 用户定义的可序列化类型

（5） 该类型至少有一个可序列化的子类型

 

针对上述（4）中说明的，什么是用户自定义的可序列化类型呢？必须满足以下亮点：

第一，必须直接或者间接（例如，父类型实现了这个接口）的实现了IsSerializable接口

第二，所有非transient类型都是可序列化的（final类型的属性在GWT中被视为transient类型）

 

是否支持容器类型呢？那么又如何声明呢？

支持容器类型，GWT可以使用Type 参数来表示容器类型内部的元素的类型，例如：

注意GWT暂时不支持使用 JDK 5.0 的模板容器

 

//用户自定义序列化类型

public class MyClass implements IsSerializable {


  /**
   * 这个Set中的元素的类型必须都是String类型
   * 
   * @gwt.typeArgs <java.lang.String>
   */
  public Set setOfStrings;

  /**
   * Map中的元素的Key和Value的类型都是String类型。
   * 
   * @gwt.typeArgs <java.lang.String,java.lang.String>
   */
  public Map mapOfStringToString;
}


// 服务器方法实现类
public interface MyService extends RemoteService {
  /**

   * 第一个类型参数表示方法的参数c是一个List，并且其中只能放置Integer类型。
   * 第二个类型参数表示返回值为List，并且其中的原书的类型为String类型。
   * 
   * @gwt.typeArgs c <java.lang.Integer>
   * @gwt.typeArgs <java.lang.String>
   */
  List reverseListAndConvertToStrings(List c);
}


 

 

    异常

在调用方法的时候异常怎么处理呢？

调用方法的过程中的异常可以分为两类：第一类，调用方法的过程中出现了异常，例如网络故障，服务类不存在等。

第二类，服务器方法抛出了异常。

 

 在客户端调用的过程中这两种异常都在onFailure（Throwable caught）方法中处理，但是caught的类型有所区别，

第一种情况下，caught为InvocationException的子类，第二种情况下caught为用户自定义的异常。

 

由于异常也需要在客户端（JavaScript）和服务器端（Java）传递，所以Exception的定义也要满足可序列化的要求。

但是在GWT中已经定义了一个基本的异常类型来提一个Exception类的基础类，这个类是SerializableException，例如：

public class ApplicationException extends SerializableException {
    public ApplicationException() {
        super();
    }

    public ApplicationException(String msg) {
        super(msg);
    }

    public Throwable getCause() {
        return super.getCause();
    }

    public String getMessage() {
        return super.getMessage(); 
    }

    public Throwable initCause(Throwable cause) {
        return super.initCause(cause);
    }
}

 

异常消息内容建议，服务器端的错误消息内容在服务器保存，客户端的错误消息内容在客户端保存（参看后续的国际化部分），两个地方

都需要的，出于GWT技术建议使用两份，分别放在客户端和服务器端。

为什么不能重用呢？

客户端的消息会被编译为JavaScript，所以服务器端通常无法使用。（还有另外的原因，参看后续的国际化部分）。

 

功能介绍（集成JUnit）

@TODO

 


功能介绍（国际化）

     项目开发过程中经常需要一些可配置的常量，例如查询最大条数，目录位置等。在传统的Java应用程序中这些内容通常会放在

属性文件中（Properties文件），但是使用属性文件有些弊端，第一，不支持类型，所有的内容都是String，第二是，只有在具体使用

的时候才能发现有些属性没有定义，而不能在编译的时候发现。

     那么GWT如何处理这个问题呢？GWT中有一个特殊的接口com.google.gwt.i18n.client.Constants可以使用这个接口达到

定义常量的效果，并且这些常量在编译的时候被绑定，而且可以支持类型。

    使用GWT主要有以下几步：

第一步，建立一个集成于Constants的接口，例如：

public interface NumberFormatConstants extends Constants {
  /**
   * @return the localized decimal separator
   */
  String decimalSeparator();

  /**
   * @return the localized thousands separator
   */
  String thousandsSeparator();
}


第二步，根据接口中定义的方法定义一个跟接口同名的属性文件，例如：

#NumberFormatConstants.properties

decimalSeparator = ,
thousandsSeparator = .

 

第三步，获取文件中定义的内容，例如：

public void useNumberFormatConstants() {
  NumberFormatConstants constants = (NumberFormatConstants) GWT.create(NumberFormatConstants.class);
  String decimalSep = constants.decimalSeparator();
  String thousandsSep = constants.thousandsSeparator();
  String msg = "Decimals are separated using '" + decimalSep + "'";
  msg += ", and thousands are separated using '" + thousandsSep + "'";
  showMessage(msg);
}


上述三步中在第二步和第三步中间隐含了伊特特殊的步骤，就是GWT编译器结合接口文件和属性文件编译出了一个

类，这个类实现了这个接口，每一个方法返回属性文件中的值。

其中GWT.create()方法可以获得生成的中间类的引用。

 

通常情况下，接口方法明和属性文件中的名字相同，例如：

String decimalSeparator(); 和 thousandsSeparator = .

但是也可以自定义接口方法和属性文件中内容的映射，例如：

 

 public interface NumberFormatConstantsWithAltKey extends Constants {
  /**
   * @gwt.key fmt.sep.decimal
   * @return the localized decimal separator
   */
  String decimalSeparator();

  /**
   * @gwt.key fmt.sep.decimal
   * @return the localized thousands separator
   */
  String thousandsSeparator();
}


@gwt.key fmt.sep.decimal 定义了属性文件中key的内容，所以属性文件应该为：

#NumberFormatConstants.properties

fmt.sep.decimal = .
fmt.sep.thousands = ,


Constants子接口中定义的方法必须满足如下形式：

 

T methodName()

 

这里T是一个返回值，T可以使用如下表中的所有类型：

T类型                        属性文件定义
String                       简单的字符串 
String[]                     使用逗号分割的字符串，如果某个字符串中包含逗号需要使用//作为转移字符，例如：'//,'  
int                            int值，在编译的时候做类型检查 
float                         float值，在编译的时候做类型检查 
double                      double值，在编译的时候做类型检查 
boolean                     boolean值"true" 或者 "false"), 在编译的时候做类型检查 
Map                          使用逗号分隔的字符产，每一个字符产在属性文件中有一条定义，定义了一个Key-Value值

 

Map示例：

a = X
b = Y
c = Z
someMap = a, b, c

 

Map someMap（）；方法得到的内容为：{a:X, b:Y, c:Z}

ConstantsWithLookup

ConstantsWithLookup是Constants的子接口，用法一样，只不过ConstantsWithLookup有一组通过属性名字获取属性值的方法：

getBoolean(String)        通过名字找到boolean型内容
getDouble(String)         通过名字找到double型内容
getFloat(String)            通过名字找到float型内容
getInt(String)              通过名字找到int型内容
getMap(String)            通过名字找到Map型内容
getString(String)          通过名字找到String型内容
getStringArray(String)   通过名字找到String[]型内容

效率问题：Constants效率比ConstantsWithLookup高，为什么呢？Constants在编译的时候会生成对应的JavaScript代码，

GWT Compiler会根据程序中是否使用了某些属性来决定这些内容是否会被编译为JavaScript，所以及时在Constants中声明

了某些方法，如果在代码中不使用的话，不会被编译为JavaScript代码的。

但是ConstantsWithLookup有根据属性名字查找属性内容的方法，所以，GWT Compiler不能根据上述方法确定属性是否被使用，

所以所有的属性内容都回被编译为JavaScript代码。

这是ConstantsWithLookup的优点，也是缺点！

Message类

在使用Constants（或者ConstantsWithLookup）的时候，我们只能使用预定义的消息，有些时候我们需要可变的消息。

例如：

    我们需要一个通用的消息再加上一个功能名字的参数怎么实现呢？

Message类相当于Java中的Properties，ResourceBundle和MessageFormat的联合体，例如：

 

消息文件类：


public interface GameStatusMessages extends Messages {
  /**
   * @param username the name of a player
   * @param numTurns the number of turns remaining
   * @return a message specifying the remaining turns for a player
   */
  String turnsLeft(String username, int numTurns);

  /**
   * @param numPoints the number of points
   * @return a message describing the current score for the current player
   */
  String currentScore(int numPoints);
}

 

属性文件定义：
turnsLeft = Turns left for player ''{0}'': {1}
currentScore = Current score: {0}

使用：
public void beginNewGameRound(String username) {
  GameStatusMessages messages = (GameStatusMessages) GWT.create(GameStatusMessages.class);

  // Tell the new player how many turns he or she has left.
  int turnsLeft = computeTurnsLeftForPlayer(username);
  showMessage(messages.turnsLeft(username, turnsLeft));

  // Tell the current player his or her score.
  int currentScore = computeScore(username);
  setCurrentPlayer(username);
  showMessage(messages.currentScore(currentScore));
}

我们可以看到在使用的时候基本一致，但是，可以使用参数配置原有的消息。

另外Message的方法的格式为：

    String methodName(optional-params)

从中我们也可以看出区别，Message只能使用String类型的参数。

Constants(或者ConstantsWithLookup)和Message的区别是：
Constants用来定义系统的常量，支持多种类型。
Message用来定义系统的消息，可以支持参数化消息，但是只支持String类型的内容。

在使用Constants和Message的时候，可以将属性文件的编码设置为UTF-8这样，就不用
使用Native2ascii将正常的文件转移为utf-8的替换文件了。
当然如果你觉得不麻烦也可以使用传统的Java属性文件（使用native2ascii处理过得文件）。

功能介绍（JavaScript Native Interface）
JavaScript Native Interface = JSNI
JSNI定义了在GWT环境下，Java与JavaScript交互的一种方法。


虽然GWT的一些核心的方法是用JavaScript编写的，但是这里还是不推荐使用JNI，应为这样做与GWT的初衷相悖，

并且，有一定的难度，开发调试也相对困难。


Java调用JavaScript方法：

JSNI方法定义需要使用native关键字，并且需要在参数列表之后，结尾的分号之前定义。JSNI方法的开始使用/*-{

结尾使用}-*/，例如：

public static native void alert(String msg) /*-{
  $wnd.alert(msg);
}-*/;

当上述方法在Java中调用的时候，实际上将会调用Window的alert方法，将传入的内容打印出来。

在Hosted Mode下，断点可以设置在上述方法中，可以方便的查看传入的参数。

 

JavaScript调用Java方法：

方法调用方式：


    [instance-expr.]@class-name::method-name(param-signature)(arguments)

属性访问方式：


    [instance-expr.]@class-name::field-name

[instance-expr.]

    用来区分实例方法调用还是静态方法调用。在调用实例方法的时候必须出现，在调用静态方法的时候不能出现。

class-name

    类的名字。

method-name

    方法的名字


param-signature


    方法的参数列表，这里使用的是内部形式（参考Java虚拟机Class格式），但是不需要写返回值类型。
arguments
    调用方法的实际参数。

例如：

public class JSNIExample {

  String myInstanceField;
  static int myStaticField;

  void instanceFoo(String s) {
    // use s
  }

  static void staticFoo(String s) {
    // use s
  }

 


  // 该方法被调用的时候将在JavaScript中执行，并且

  // 可以使用JavaScript中的内容。


  public native void bar(JSNIExample x, String s) /*-{
    // 调用这个实例本身的instanceFoo方法
    this.@com.google.gwt.examples.JSNIExample::instanceFoo(Ljava/lang/String;)(s);

    // 调用x实例（输入参数）上的instanceFoo实例方法
    x.@com.google.gwt.examples.JSNIExample::instanceFoo(Ljava/lang/String;)(s);

    // 调用静态方法 staticFoo()
    @com.google.gwt.examples.JSNIExample::staticFoo(Ljava/lang/String;)(s);

    // 读取这个实例的变量
    var val = this.@com.google.gwt.examples.JSNIExample::myInstanceField;

    // 设置x上的实例变量
    x.@com.google.gwt.examples.JSNIExample::myInstanceField = val + " and stuff";

    // Read static field (no qualifier)
    @com.google.gwt.examples.JSNIExample::myStaticField = val + " and stuff";
  }-*/;

}

 


Java和JavaScript之间参数的传递：

Java -> JavaScript

Java type                              JavaScript Type
numeric primitive                     a JavaScript numeric value, as in var x = 42;
String                                   a JavaScript string, as in var s = "my string";
boolean                                 a JavaScript boolean value, as in var b = true;
JavaScriptObject (see notes)    a JavaScriptObject that must have originated from JavaScript code, typically as the return value of some other JSNI method
Java array            an opaque value that can only be passed back into Java code
any other Java Object        an opaque value accessible through special syntax


 

异常
调用JSNI方法的时候会抛出一个JavaScriptException的异常，但是由于JavaScript不是一个强类型的语言，所以
无法想Java一样处理JavaScript异常。一个好的方式是在Java中处理Java异常，在JavaScript中处理JavaScript异常。

另外在JSNI方法，Java普通方法混掉的过程中，异常可以从最底层移植抛到最想的调用层，例如：

1. Java method foo() calls JSNI method bar()
2. JavaScript method bar() calls Java method baz()
3. Java method baz() throws an exception
baz()中抛出的异常可以蔓延到bar方法，可以在foo方法中捕获。

 

 

 

从Host Model到 Web Model

在Host Model方式下，GWT并不将Java代码编译为JavaScript，而是在GWT环境中直接运行Java bytecode，

但是项目正式部署之后使用的是Web Model，那么如何从Host Model迁移到Web Model呢？

 

首先需要将Java代码编译为JavaScript代码。

使用如下命令可以将Java代码编译为JavaScript代码：

java -cp "%~dp0/src;%~dp0/bin;%~dp0/../../gwt-user.jar;%~dp0/../../gwt-dev-windows.jar" com.google.gwt.dev.GWTCompiler -out "%~dp0/www" %* com.google.gwt.sample.hello.Hello

 

-cp  指定源代码目录，Class目录，和GWT的jar文件的路径

-out 指定JavaScript代码的输出路径

com.google.gwt.sample.hello.Hello 指定编译的Module，一般是gwt.xml文件中entry-point类去掉client之后的内容。

 

当代码量比较大的时候，需要指定Java使用内存的大小，否则会内存溢出。

java -Xmx512m -Xms128m -cp "%~dp0/src;%~dp0/bin;%~dp0/../../gwt-user.jar;%~dp0/../../gwt-dev-windows.jar" com.google.gwt.dev.GWTCompiler -out "%~dp0/www" %* com.google.gwt.sample.hello.Hello

 

之后将编译成的JavaScript代码拷贝到Web项目的根目录中，与WEB-INF相同层次的目录。

 

最后需要将gwt.xml文件中定义的service编程对应的Servlet。

<servlet path='/calendar' class='com.google.gwt.sample.dynatable.server.SchoolCalendarServiceImpl'/>

 

=>

 

<servlet>

     <servlet-name>Calendar</servlet-name>

     <servlet-class>com.google.gwt.sample.dynatable.server.SchoolCalendarServiceImpl</servlet-class>

</servlet>

 

<servlet-mapping>

     <servlet-name>Calendar</servlet-name>

     <url-pattern>/calendar</url-pattern>

</servlet-mapping>

 


使用数据源 
Hosted Mode 虽然开发起来很方便，但是也有缺点，例如，数据源的配置就有问题。

在GWT Hosted Mode下无法配置数据源，一种可选的方式是使用一个假的数据库链接

管理类，这个类的接口返回Connection，内部以DriverManager的方式实现，等待

后续部署之后再切换到数据源模式。

日志处理(Log4J)

回想GWT应用程序，client包内部的代码将会被编译为客户端JavaScript代码，所以这里
不需要记录日志，也不可能使用Log4j。
但是Server包内的内容在服务器上运行，需要合理的使用日志。

一个简单的Login示例

代码结构如下：

 

└─src
    └─com
        └─jpleasure
            └─gwt
                └─logon
                    │  LogonDemo.gwt.xml                      GWT配置模块文件
                    │  
                    ├─client                                         客户端代码包
                    │  │  LogonDemo.java                       GWT代码的入口点
                    │  │  LogonDemoController.java          画面迁移控制类
                    │  │  
                    │  ├─exception                                异常定义包
                    │  │      ApplicationException.java       应用程序异常
                    │  │      
                    │  ├─panel                                      页面Panel包
                    │  │      BasePanel.java                     基类Panel
                    │  │      LogonPanel.java                   Logon Panel
                    │  │      WelcomePanel.java               Welcome Panel
                    │  │      
                    │  ├─service                                   客户端服务定义包
                    │  │      LogonService.java                服务接口
                    │  │      LogonServiceAsync.java        服务异步调用接口
                    │  │      
                    │  └─so                                          Serializable Object 包
                    │          LogonSO.java                      Logon SO
                    │          
                    ├─public                                        GWT HTML包
                    │      LogonDemo.css                        CSS定义
                    │      LogonDemo.html                      主HTML页面
                    │      
                    └─server                                         服务端Service包
                        └─service
                                LogonServiceImpl.java          Logon Service

 

// ApplicationException

package com.jpleasure.gwt.logon.client.exception;

import com.google.gwt.user.client.rpc.SerializableException;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:16:17
 * To change this template use File | Settings | File Templates.
 */
public class ApplicationException extends SerializableException {
    public ApplicationException() {
        super();
    }

    public ApplicationException(String msg) {
        super(msg); 
    }
}


//BasePanel

package com.jpleasure.gwt.logon.client.panel;

import com.google.gwt.user.client.ui.VerticalPanel;
import com.jpleasure.gwt.logon.client.LogonDemoController;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:01:14
 * To change this template use File | Settings | File Templates.
 */
public class BasePanel extends VerticalPanel {
    protected LogonDemoController ldc;

    public LogonDemoController getLdc() {
        return ldc;
    }

    public void setLdc(LogonDemoController ldc) {
        this.ldc = ldc;
    }
}


// LogonPanel

package com.jpleasure.gwt.logon.client.panel;

import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.rpc.AsyncCallback;
import com.google.gwt.user.client.ui.*;
import com.jpleasure.gwt.logon.client.service.LogonService;
import com.jpleasure.gwt.logon.client.service.LogonServiceAsync;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:35:13
 * To change this template use File | Settings | File Templates.
 */
public class LogonPanel extends BasePanel {
    private TextBox name;
    private PasswordTextBox password;
    private Button logonButton;

    public LogonPanel() {
        HorizontalPanel msgPanel = new HorizontalPanel();
        msgPanel.add(new Label("Please input logon information here!"));

        HorizontalPanel namePanel = new HorizontalPanel();
        Label nameLabel = new Label("Name:");
        nameLabel.setPixelSize(100, 20);
        namePanel.add(nameLabel);
        name = new TextBox();
        namePanel.add(name);

        HorizontalPanel pwdPanel = new HorizontalPanel();
        Label passwordLabel = new Label("Password:");
        passwordLabel.setPixelSize(100, 20);
        pwdPanel.add(passwordLabel);
        password = new PasswordTextBox();
        pwdPanel.add(password);

        HorizontalPanel btnPanel = new HorizontalPanel();
        logonButton = new Button("Logon");
        logonButton.addClickListener(new ClickListener() {

            public void onClick(Widget sender) {
                LogonServiceAsync logonService = LogonService.App.getInstance();
                LogonSO logonSO = new LogonSO();
                logonSO.setName(getName());
                logonSO.setPassword(getPassword());
                logonService.logon(logonSO, new AsyncCallback() {

                    public void onFailure(Throwable caught) {
                        Window.alert(caught.getMessage());
                    }

                    public void onSuccess(Object result) {
                        boolean isLogon = ((Boolean)result).booleanValue();
                        if(isLogon) {
                            ldc.gotoWelcome();
                        }                     else {
                            Window.alert("logon failed!");
                        }
                    }
                })  ;

            }
        });
        btnPanel.add(logonButton);

        this.add(msgPanel);
        this.add(namePanel);
        this.add(pwdPanel);
        this.add(btnPanel);
    }

    public String getName() {
        return this.name.getText();
    }

    public String getPassword() {
        return this.password.getText();
    }

}


// WelcomePanel

package com.jpleasure.gwt.logon.client.panel;

import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.ClickListener;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.Widget;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:49:53
 * To change this template use File | Settings | File Templates.
 */
public class WelcomePanel extends BasePanel {
    public WelcomePanel() {

        Label welcomeLabel = new Label("Welcome to LogonDemo!");
        this.add(welcomeLabel);

        Button logoutButton = new Button("Logout");
        logoutButton.addClickListener(new ClickListener() {

            public void onClick(Widget sender) {
                ldc.gotoLogon();
            }
        });

        this.add(logoutButton);
    }
}


//LogonService

package com.jpleasure.gwt.logon.client.service;

import com.google.gwt.core.client.GWT;
import com.google.gwt.user.client.rpc.RemoteService;
import com.google.gwt.user.client.rpc.ServiceDefTarget;
import com.jpleasure.gwt.logon.client.exception.ApplicationException;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:09
 * To change this template use File | Settings | File Templates.
 */
public interface LogonService extends RemoteService {
    /**
     * Utility/Convenience class.
     * Use LogonService.App.getInstance() to access static instance of LogonServiceAsync
     */
    public static class App {
        private static LogonServiceAsync ourInstance = null;

        public static synchronized LogonServiceAsync getInstance() {
            if (ourInstance == null) {
                ourInstance = (LogonServiceAsync) GWT.create(LogonService.class);
                ((ServiceDefTarget) ourInstance).setServiceEntryPoint(GWT.getModuleBaseURL() + "com.jpleasure.gwt.logon.LogonDemo/LogonService");
            }
            return ourInstance;
        }
    }

    public boolean logon(LogonSO logonSO) throws ApplicationException;
}


//LogonServiceAsync

package com.jpleasure.gwt.logon.client.service;

import com.google.gwt.user.client.rpc.AsyncCallback;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:09
 * To change this template use File | Settings | File Templates.
 */
public interface LogonServiceAsync {
    void logon(LogonSO logonSO, AsyncCallback async);
}

//   LogonSO  

package com.jpleasure.gwt.logon.client.so;

import com.google.gwt.user.client.rpc.IsSerializable;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:52
 * To change this template use File | Settings | File Templates.
 */
public class LogonSO implements IsSerializable {
    private String name;

    private String password;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
    
}
  

//  LogonDemo                       
package com.jpleasure.gwt.logon.client;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.user.client.ui.DeckPanel;
import com.google.gwt.user.client.ui.RootPanel;
import com.jpleasure.gwt.logon.client.panel.LogonPanel;
import com.jpleasure.gwt.logon.client.panel.WelcomePanel;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:34:12
 * To change this template use File | Settings | File Templates.
 */
public class LogonDemo implements EntryPoint {
    public void onModuleLoad() {
        DeckPanel mainPanel = new DeckPanel();
        LogonDemoController ldc = new LogonDemoController(mainPanel);

        LogonPanel logonPanel = new LogonPanel();
        logonPanel.setLdc(ldc);
        mainPanel.add(logonPanel);

        WelcomePanel welcomePanel = new WelcomePanel();
        welcomePanel.setLdc(ldc);
        mainPanel.add( welcomePanel );

        mainPanel.showWidget(0);

        RootPanel.get().add(mainPanel);
    }
}


// LogonDemoController

package com.jpleasure.gwt.logon.client;

import com.google.gwt.user.client.ui.DeckPanel;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:58:02
 * To change this template use File | Settings | File Templates.
 */
public class LogonDemoController {
    private DeckPanel mainPanel;

    public LogonDemoController(DeckPanel panel) {
        this.mainPanel = panel;
    }

    public void gotoWelcome() {
        if (mainPanel != null) {

            mainPanel.showWidget(1);
        }
    }

    public void gotoLogon() {
        if (mainPanel != null) {
            mainPanel.showWidget(0);
        }
    }
}

 

// LogonServiceImpl

package com.jpleasure.gwt.logon.server.service;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import com.jpleasure.gwt.logon.client.exception.ApplicationException;
import com.jpleasure.gwt.logon.client.service.LogonService;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:10
 * To change this template use File | Settings | File Templates.
 */
public class LogonServiceImpl extends RemoteServiceServlet implements LogonService {
    public boolean logon(LogonSO logonSO) throws ApplicationException {

        if (logonSO.getName() != null && logonSO.getName().length() > 0  &&
                logonSO.getPassword() != null && logonSO.getPassword().length() > 0 &&
                logonSO.getName().equals(logonSO.getPassword())) {
            return true;
        } else if ("ex".equals(logonSO.getName())) {
            throw new ApplicationException("Logon Exception!");

        } else {
            return false;
        }

    }
}
 

//LogonDemo.gwt.xml

<module>

    <inherits name='com.google.gwt.user.User'/>

    <entry-point class='com.jpleasure.gwt.logon.client.LogonDemo'/>

    <servlet path="/com.jpleasure.gwt.logon.LogonDemo/LogonService"
             class="com.jpleasure.gwt.logon.server.service.LogonServiceImpl"/>
</module>

 

安全相关

参看：http://groups.google.com/group/Google-Web-Toolkit/web/security-for-gwt-applications

在GWT中所有的画面都是由Panel实现的，而所有的Panel都会被编译为JavaScript和Html代码，这些代码在程序运行的开始就会

下载到客户的浏览器中，虽然这些JavaScript代码很难阅读，但是毕竟以影下载到了客户的环境中，所以在本质上GWT是不安全的。（请大家讨论）

 另外由于JavaScript的灵活性，可以动态的在画面上创建链接，image等，所以数据也有可能别提交到其他的服务器，而非下载的服务器。

 

另外，由于Panel，Action等最终都编译为了JavaScript，所以关于用户权限等信息最好不要放在Panel，Action内部。最好能放在server包内部，

在客户端对Service的每次调用的开始确认用户的权限。

 

 

GWT开发使用的工具

免费

    Netbeans + gwt4nb

    参看：http://www.javapassion.com/handsonlabs/ajaxgwtintro/

    优点：直接屏蔽了GWT Shell（Hosted Mode）开发的方式，可以方便的以普通Java Web 应用程序开发的凡是进行GWT开发。

    缺点：不支持界面的拖拽编辑，同时继承了NB 5.5 的缺点，对JSP，HTML，JavaScript编辑器支持不足。

 

 

    Eclipse + Cypal Studio for GWT

    参看：http://www.ibm.com/developerworks/library/os-eclipse-ajaxcypal/index.html

    优点：可以方便的以普通Java Web 应用程序开发的凡是进行GWT开发。支持两种运行方式：GWT Shell运行和Web方式运行。

 

收费：

    Ingellij IDEA 6

    参看：http://www.jetbrains.com/idea/training/demos/GWT.html

 

    Eclipse + GWT Builder

    http://www.instantiations.com/gwtdesigner/

 

 
=====================
endof GWT(Google Web Toolkit)入门学习


getfrom 手把手教你使用Git
============
http://blog.jobbole.com/78960/

一：Git是什么？

       Git是目前世界上最先进的分布式版本控制系统。

二：SVN与Git的最主要的区别？

      SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。

      Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

三：在windows上如何安装Git？

      msysgit是 windows版的Git,如下：

     

 需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –> Git Bash”,如下：

  

会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：

 

安装完成后，还需要最后一步设置，在命令行输入如下：

 

  因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。

   注意：git config  –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。

四：如何操作？

     一：创建版本库。

     什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。

    所以创建一个版本库也非常简单，如下我是D盘 –> www下 目录下新建一个testgit版本库。

   

pwd 命令是用于显示当前的目录。

      1. 通过命令 git init 把这个目录变成git可以管理的仓库，如下：



     这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：

    

      2. 把文件添加到版本库中。

          首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。

    下面先看下demo如下演示：

     我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111

     第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：

    

   如果和上面一样，没有任何提示，说明已经添加成功了。

   第二步：用命令 git commit告诉Git，把文件提交到仓库。

   

  现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：

  

 说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：

 

上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。

接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：

git diff readme.txt 如下：

 

如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。

知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add  第二步是：git commit)。

如下：

 

二：版本回退：

     如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行

内容为33333333333333.继续执行命令如下：

   

现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：

  

    git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：

  

    现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset  –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  –hard HEAD~100 即可。未回退之前的readme.txt内容如下：

  

如果想回退到上一个版本的命令如下操作：



再来查看下 readme.txt内容如下：通过命令cat readme.txt查看



可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：



我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：

git reset  –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog  演示如下：



通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令

git reset  –hard 6fcfc89来恢复了。演示如下：



可以看到 目前已经是最新的版本了。

三：理解工作区与暂存区的区别？

     工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。

      版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。

我们前面说过使用Git提交文件到版本库有两步：

  第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。

  第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。

我们继续使用demo来演示下：

我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：



现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：



接着我们可以使用git commit一次性提交到分支上，如下：



四：Git撤销修改和删除文件操作。

一：撤销修改：

    比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：



在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：

第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。

第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset  –hard HEAD^

但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：



可以发现，Git会告诉你，git checkout  — file 可以丢弃工作区的修改，如下命令：

git checkout  —  readme.txt,如下所示：



命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：

readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。
另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。
对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：

  

注意：命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。

二：删除文件。

     假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：

  

如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，

 

只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？

可以使用如下命令 git checkout  — b.txt，如下所示：



再来看看我们testgit目录，添加了3个文件了。如下所示：



五：远程仓库。

     在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：

     第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：

ssh-keygen  -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：

 

id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。



点击 Add Key，你就应该可以看到已经添加的key。



如何添加远程库？
         现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。

   首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：



在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：



    目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。

现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：

git remote add origin https://github.com/tugenhua0707/testgit.git

所有的如下：

  

把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。

由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：



从现在起，只要本地作了提交，就可以通过如下命令：

git push origin master

把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。

2. 如何从远程库克隆？

上面我们了解了先有本地库，后有远程库时候，如何关联远程库。

现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？

首先，登录github，创建一个新的仓库，名字叫testgit2.如下：



如下，我们看到：



现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：



接着在我本地目录下 生成testgit2目录了，如下所示：



六：创建与合并分支。

在  版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

首先，我们来创建dev分支，然后切换到dev分支上。如下操作：



git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令

git branch dev

git checkout dev

git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777

首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：



现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：



现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：



git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。

注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

合并完成后，我们可以接着删除dev分支了，操作如下：



总结创建与合并分支命令如下：

   查看分支：git branch

   创建分支：git branch name

   切换分支：git checkout name

创建+切换分支：git checkout –b name

合并某分支到当前分支：git merge name

删除分支：git branch –d name

如何解决冲突？
下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：



同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：



现在我们需要在master分支上来合并fenzhi1，如下操作：



Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，其中<<<HEAD是指主分支修改的内容，>>>>>fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：



如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：



    3.分支管理策略。

      通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：

创建一个dev分支。
修改readme.txt内容。
添加到暂存区。
切换回主分支(master)。
合并dev分支，使用命令 git merge –no-ff  -m “注释” dev
查看历史记录
截图如下：

 

分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。

七：bug分支：

     在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。

比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：

 

   并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：

  

   所以现在我可以通过创建issue-404分支来修复bug了。

首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：

 

修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：



现在，我们回到dev分支上干活了。



工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：



工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：

git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。
另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。
         演示如下



八：多人协作。

当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。

要查看远程库的信息 使用 git remote
要查看远程库的详细信息 使用 git remote –v
如下演示：

 

一：推送分支：

      推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：

      使用命令 git push origin master

比如我现在的github上的readme.txt代码如下：



本地的readme.txt代码如下：

 

现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：



我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：



可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev

那么一般情况下，那些分支要推送呢？

master分支是主分支，因此要时刻与远程同步。
一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。
二：抓取分支：

多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2

但是我首先要把dev分支也要推送到远程去，如下



接着进入testgit2目录，进行克隆远程的库到本地来，如下：

 

现在目录下生成有如下所示：



现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout  –b dev origin/dev

现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。

如下：



小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：



由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。



git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：



这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：

我们可以先来看看readme.txt内容了。



现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：


因此：多人协作工作模式一般是这样的：

首先，可以试图用git push origin branch-name推送自己的修改.
如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。
如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。
Git基本常用命令如下：

   mkdir：         XX (创建一个空目录 XX指目录名)

   pwd：          显示当前目录的路径。

   git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。

   git add XX       把xx文件添加到暂存区去。

   git commit –m “XX”  提交文件 –m 后面的是注释。

   git status        查看仓库状态

   git diff  XX      查看XX文件修改了那些内容

   git log          查看历史记录

   git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本

                        (如果想回退到100个版本，使用git reset –hard HEAD~100 )

   cat XX         查看XX文件内容

   git reflog       查看历史记录的版本号id

   git checkout — XX  把XX文件在工作区的修改全部撤销。

   git rm XX          删除XX文件

   git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库

   git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库

   git clone https://github.com/tugenhua0707/testgit  从远程库中克隆

   git checkout –b dev  创建dev分支 并切换到dev分支上

   git branch  查看当前所有的分支

   git checkout master 切换回master分支

   git merge dev    在当前的分支上合并dev分支

   git branch –d dev 删除dev分支

   git branch name  创建分支

   git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作

   git stash list 查看所有被隐藏的文件列表

   git stash apply 恢复被隐藏的文件，但是内容不删除

   git stash drop 删除文件

   git stash pop 恢复文件的同时 也删除文件

   git remote 查看远程库的信息

   git remote –v 查看远程库的详细信息

   git push origin master  Git会把master分支推送到远程库对应的远程分支上
===============
endof 手把手教你使用Git
