

getfrom che-4.7.0.sh
======================

# See: https://sipb.mit.edu/doc/safe-shell/
set -e
set -u
init_logging
//
init_logging() {
  BLUE='\033[1;34m'
  GREEN='\033[0;32m'
  RED='\033[0;31m'
  NC='\033[0m'
}

check_docker
//
check_docker() {
  if ! docker ps > /dev/null 2>&1; then
    output=$(docker ps)
    error_exit "Error - Docker not installed properly: \n${output}"
  fi

  # Prep script by getting default image
  if [ "$(docker images -q alpine 2> /dev/null)" = "" ]; then
    info "ECLIPSE CHE: PULLING IMAGE alpine:latest"
    docker pull alpine > /dev/null 2>&1
  fi
}




init_global_variables
//
init_global_variables() {

  # Name used in INFO statements
  DEFAULT_CHE_PRODUCT_NAME="ECLIPSE CHE"

  # Name used in CLI statements
  DEFAULT_CHE_MINI_PRODUCT_NAME="che"

  DEFAULT_CHE_LAUNCHER_IMAGE_NAME="codenvy/che-launcher"
  DEFAULT_CHE_SERVER_IMAGE_NAME="codenvy/che-server"
  DEFAULT_CHE_DIR_IMAGE_NAME="codenvy/che-dir"
  DEFAULT_CHE_MOUNT_IMAGE_NAME="codenvy/che-mount"
  DEFAULT_CHE_ACTION_IMAGE_NAME="codenvy/che-action"
  DEFAULT_CHE_TEST_IMAGE_NAME="codenvy/che-test"
  DEFAULT_CHE_DEV_IMAGE_NAME="codenvy/che-dev"
  DEFAULT_CHE_SERVER_CONTAINER_NAME="che-server"
  DEFAULT_CHE_VERSION="latest"
  DEFAULT_CHE_CLI_ACTION="help"
  DEFAULT_IS_INTERACTIVE="true"

  CHE_PRODUCT_NAME=${CHE_PRODUCT_NAME:-${DEFAULT_CHE_PRODUCT_NAME}}
  CHE_MINI_PRODUCT_NAME=${CHE_MINI_PRODUCT_NAME:-${DEFAULT_CHE_MINI_PRODUCT_NAME}}
  CHE_LAUNCHER_IMAGE_NAME=${CHE_LAUNCHER_IMAGE_NAME:-${DEFAULT_CHE_LAUNCHER_IMAGE_NAME}}
  CHE_SERVER_IMAGE_NAME=${CHE_SERVER_IMAGE_NAME:-${DEFAULT_CHE_SERVER_IMAGE_NAME}}
  CHE_DIR_IMAGE_NAME=${CHE_DIR_IMAGE_NAME:-${DEFAULT_CHE_DIR_IMAGE_NAME}}
  CHE_MOUNT_IMAGE_NAME=${CHE_MOUNT_IMAGE_NAME:-${DEFAULT_CHE_MOUNT_IMAGE_NAME}}
  CHE_ACTION_IMAGE_NAME=${CHE_ACTION_IMAGE_NAME:-${DEFAULT_CHE_ACTION_IMAGE_NAME}}
  CHE_TEST_IMAGE_NAME=${CHE_TEST_IMAGE_NAME:-${DEFAULT_CHE_TEST_IMAGE_NAME}}
  CHE_DEV_IMAGE_NAME=${CHE_DEV_IMAGE_NAME:-${DEFAULT_CHE_DEV_IMAGE_NAME}}
  CHE_SERVER_CONTAINER_NAME=${CHE_SERVER_CONTAINER_NAME:-${DEFAULT_CHE_SERVER_CONTAINER_NAME}}
  CHE_VERSION=${CHE_VERSION:-${DEFAULT_CHE_VERSION}}
  CHE_CLI_ACTION=${CHE_CLI_ACTION:-${DEFAULT_CHE_CLI_ACTION}}
  IS_INTERACTIVE=${IS_INTERACTIVE:-${DEFAULT_IS_INTERACTIVE}}

  GLOBAL_NAME_MAP=$(docker info | grep "Name:" | cut -d" " -f2)
  GLOBAL_HOST_ARCH=$(docker version --format {{.Client}} | cut -d" " -f5)
  GLOBAL_UNAME=$(docker run --rm alpine sh -c "uname -r")
  GLOBAL_GET_DOCKER_HOST_IP=$(get_docker_host_ip)

  USAGE="
Usage: ${CHE_MINI_PRODUCT_NAME} [COMMAND]
           start                              Starts ${CHE_MINI_PRODUCT_NAME} server
           stop                               Stops ${CHE_MINI_PRODUCT_NAME} server
           restart                            Restart ${CHE_MINI_PRODUCT_NAME} server
           update                             Pulls specific version, respecting CHE_VERSION
           profile add <name>                 Add a profile to ~/.che/ 
           profile set <name>                 Set this profile as the default for ${CHE_MINI_PRODUCT_NAME} CLI
           profile unset                      Removes the default profile - leaves it unset
           profile rm <name>                  Remove this profile from ~/.che/
           profile update <name>              Update profile in ~/.che/
           profile info <name>                Print the profile configuration
           profile list                       List available profiles
           mount <local-path> <ws-ssh-port>   Synchronize workspace to a local directory
           dir init                           Initialize directory with ${CHE_MINI_PRODUCT_NAME} configuration
           dir up                             Create workspace from source in current directory
           dir down                           Stop workspace running in current directory
           dir status                         Display status of ${CHE_MINI_PRODUCT_NAME} in current directory
           action <action-name> [--help]      Start action on ${CHE_MINI_PRODUCT_NAME} instance
           compile <mvn-command>              SDK - Builds Che source code or modules
           test <test-name> [--help]          Start test on ${CHE_MINI_PRODUCT_NAME} instance
           info [ --all                       Run all debugging tests
                  --server                    Run ${CHE_MINI_PRODUCT_NAME} launcher and server debugging tests
                  --networking                Test connectivity between ${CHE_MINI_PRODUCT_NAME} sub-systems
                  --cli                       Print CLI (this program) debugging info
                  --create [<url>]            Test creating a workspace and project in ${CHE_MINI_PRODUCT_NAME}
                           [<user>] 
                           [<pass>] ]
"
}


parse_command_line "$@"
//

parse_command_line () {
  if [ $# -eq 0 ]; then 
    CHE_CLI_ACTION="help"
  else
    case $1 in
      start|stop|restart|update|info|profile|action|dir|mount|compile|test|help|-h|--help)
        CHE_CLI_ACTION=$1
      ;;
      *)
        # unknown option
        error_exit "You passed an unknown command line option."
      ;;
    esac
  fi
}


if is_boot2docker; then
//
is_boot2docker() {
  if echo "$GLOBAL_UNAME" | grep -q "boot2docker"; then
    return 0
  else
    return 1
  fi
}


  debug ""
  debug "!!! Boot2docker detected - save workspaces only in %userprofile% !!!"
  debug ""
fi

case ${CHE_CLI_ACTION} in
  start|stop|restart)
    load_profile
	//
	load_profile() {
  if has_default_profile; then
  //
  has_default_profile() {
  if [ -f ~/.che/profiles/.profile ]; then
    return 0
  else 
    return 1
  fi 
}

    source ~/.che/profiles/.profile

    if [ ! -f ~/.che/profiles/"${CHE_PROFILE}" ]; then
      error ""
      error "${CHE_MINI_PRODUCT_NAME} CLI profile set in ~/.che/profiles/.profile to '${CHE_PROFILE}' but ~/.che/profiles/${CHE_PROFILE} does not exist."
      error ""
      return
    fi

    source ~/.che//profiles/"${CHE_PROFILE}"
  fi
}

    execute_che_launcher
	//
	execute_che_launcher() {
  check_current_image_and_update_if_not_found ${CHE_LAUNCHER_IMAGE_NAME}
  //
  check_current_image_and_update_if_not_found() {

  CURRENT_IMAGE=$(docker images -q "$1":"${CHE_VERSION}")

  if [ "${CURRENT_IMAGE}" == "" ]; then
    update_che_image $1
  fi
}
  //
  docker_run_with_che_properties "${CHE_LAUNCHER_IMAGE_NAME}":"${CHE_VERSION}" "${CHE_CLI_ACTION}" || true
  //
  docker_run_with_che_properties() {
  if [ ! -z ${CHE_CONF_FOLDER+x} ]; then

    # Configuration directory set by user - this has precedence.
    docker_run_with_interactive -e "CHE_CONF_FOLDER=${CHE_CONF_FOLDER}" "$@"
	//
	docker_run_with_interactive() {
  if has_interactive; then
  //
  has_interactive() {
  if [ "${IS_INTERACTIVE}" = "true" ]; then
    return 0
  else
    return 1
  fi
}
    docker_run_with_env_file -it "$@"
	//
	docker_run_with_env_file() {
  if has_che_env_variables; then
  //
  has_che_env_variables() {
  PROPERTIES=$(env | grep CHE_)

  if [ "$PROPERTIES" = "" ]; then
    return 1
  else 
    return 0
  fi 
}
    get_list_of_che_system_environment_variables
	//
	get_list_of_che_system_environment_variables() {
  # See: http://stackoverflow.com/questions/4128235/what-is-the-exact-meaning-of-ifs-n
  IFS=$'\n'
  DOCKER_ENV="tmp"

  touch "tmp"
  
  if has_default_profile; then
  //
  has_default_profile() {
  if [ -f ~/.che/profiles/.profile ]; then
    return 0
  else 
    return 1
  fi 
}
    cat ~/.che/profiles/${CHE_PROFILE} >> $DOCKER_ENV
  else
    CHE_VARIABLES=$(env | grep CHE_)

    if [ ! -z ${CHE_VARIABLES+x} ]; then
      env | grep CHE_ >> $DOCKER_ENV
    fi

    # Add in known proxy variables
    if [ ! -z ${http_proxy+x} ]; then
      echo "http_proxy=${http_proxy}" >> $DOCKER_ENV
    fi

    if [ ! -z ${https_proxy+x} ]; then
      echo "https_proxy=${https_proxy}" >> $DOCKER_ENV
    fi

    if [ ! -z ${no_proxy+x} ]; then
      echo "no_proxy=${no_proxy}" >> $DOCKER_ENV
    fi
  fi
}

    docker_run --env-file="tmp" "$@"
	//
	docker_run() {
  docker_exec run --rm -v /var/run/docker.sock:/var/run/docker.sock "$@"
  //
  docker_exec() {
  if is_boot2docker || is_docker_for_windows; then
  //
  is_boot2docker() {
  if echo "$GLOBAL_UNAME" | grep -q "boot2docker"; then
    return 0
  else
    return 1
  fi
}
//
is_docker_for_windows() {
  if is_moby_vm && has_docker_for_windows_client; then
  //
  is_moby_vm() {
  if echo "$GLOBAL_NAME_MAP" | grep -q "moby"; then
    return 0
  else
    return 1
  fi
}
//
has_docker_for_windows_client(){
  if [ "${GLOBAL_HOST_ARCH}" = "windows" ]; then
    return 0
  else
    return 1
  fi
}
    return 0
  else
    return 1
  fi
}



    MSYS_NO_PATHCONV=1 docker.exe "$@"
  else
    "$(which docker)" "$@"
  fi
}
}

    rm -rf "tmp" > /dev/null
  else
    docker_run "$@"
  fi
}
  else
    docker_run_with_env_file -t "$@"
  fi
}

  else 
    if has_che_properties; then
	//
	has_che_properties() {
  PROPERTIES=$(env | grep CHE_PROPERTY_)

  if [ "$PROPERTIES" = "" ]; then
    return 1
  else 
    return 0
  fi 
}
      # No user configuration directory, but CHE_PROPERTY_ values set
      generate_temporary_che_properties_file
	  //
	  generate_temporary_che_properties_file() {
  if has_che_properties; then
    test -d ~/.che/conf || mkdir -p ~/.che/conf
    touch ~/.che/conf/che.properties

    # Get list of properties
    PROPERTIES_ARRAY=($(env | grep CHE_PROPERTY_))
    for PROPERTY in "${PROPERTIES_ARRAY[@]}"
    do
      # CHE_PROPERTY_NAME=value ==> NAME=value
      PROPERTY_WITHOUT_PREFIX=${PROPERTY#CHE_PROPERTY_}

      # NAME=value ==> separate name / value into different variables
      PROPERTY_NAME=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f1 -d=)
      PROPERTY_VALUE=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f2 -d=)
     
      # Replace "_" in names to periods

      # Replace "_" in names to periods
      CONVERTED_PROPERTY_NAME=$(echo "$PROPERTY_NAME" | tr _ .)

      # Replace ".." in names to "_"
      SUPER_CONVERTED_PROPERTY_NAME="${CONVERTED_PROPERTY_NAME//../_}"

      echo "$SUPER_CONVERTED_PROPERTY_NAME=$PROPERTY_VALUE" >> ~/.che/conf/che.properties
    done
  fi
}

      docker_run_with_interactive -e "CHE_CONF_FOLDER=$(get_mount_path ~/.che/conf)" "$@"
	  //
	  docker_run_with_interactive() {
  if has_interactive; then
    docker_run_with_env_file -it "$@"
  else
    docker_run_with_env_file -t "$@"
  fi
}
      rm -rf ~/.che/conf/che.properties > /dev/null
    else
      docker_run_with_interactive "$@"
    fi
  fi
}
}
//
get_mount_path() {
  FULL_PATH=$(get_full_path "${1}")
  //
  get_full_path() {
  # "/some/path" => /some/path
  OUTPUT_PATH=${1//\"}

  # create full directory path
  echo "$(cd "$(dirname "${OUTPUT_PATH}")"; pwd)/$(basename "$1")"
}



  POSIX_PATH=$(convert_windows_to_posix "${FULL_PATH}")
  //
  convert_windows_to_posix() {
  echo "/"$(echo "$1" | sed 's/\\/\//g' | sed 's/://')
}

  CLEAN_PATH=$(get_clean_path "${POSIX_PATH}")
  //get_clean_path() {
  INPUT_PATH=$1
  # \some\path => /some/path
  OUTPUT_PATH=$(echo ${INPUT_PATH} | tr '\\' '/')
  # /somepath/ => /somepath
  OUTPUT_PATH=${OUTPUT_PATH%/}
  # /some//path => /some/path
  OUTPUT_PATH=$(echo ${OUTPUT_PATH} | tr -s '/')
  # "/some/path" => /some/path
  OUTPUT_PATH=${OUTPUT_PATH//\"}
  echo ${OUTPUT_PATH}
}

  echo $CLEAN_PATH
}


  ;;
  profile)
    execute_profile "$@"
	//
	execute_profile(){

  if [ ! $# -ge 2 ]; then 
    error ""
    error "${CHE_MINI_PRODUCT_NAME} profile: Wrong number of arguments."
    error ""
    return
  fi

  case ${2} in
    add|rm|set|info|update)
    if [ ! $# -eq 3 ]; then 
      error ""
      error "${CHE_MINI_PRODUCT_NAME} profile: Wrong number of arguments."
      error ""
      return
    fi
    ;;
    unset|list)
    if [ ! $# -eq 2 ]; then 
      error ""
      error "${CHE_MINI_PRODUCT_NAME} profile: Wrong number of arguments."
      error ""
      return
    fi
    ;;
  esac

  case ${2} in
    add)
      if [ -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} already exists. Nothing to do. Exiting."
        error ""
        return
      fi

      test -d ~/.che/profiles || mkdir -p ~/.che/profiles
      touch ~/.che/profiles/"${3}"

      echo "CHE_PRODUCT_NAME=$CHE_PRODUCT_NAME" > ~/.che/profiles/"${3}"
      echo "CHE_MINI_PRODUCT_NAME=$CHE_MINI_PRODUCT_NAME" > ~/.che/profiles/"${3}"
      echo "CHE_LAUNCHER_IMAGE_NAME=$CHE_LAUNCHER_IMAGE_NAME" > ~/.che/profiles/"${3}"
      echo "CHE_SERVER_IMAGE_NAME=$CHE_SERVER_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_DIR_IMAGE_NAME=$CHE_DIR_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_MOUNT_IMAGE_NAME=$CHE_MOUNT_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_TEST_IMAGE_NAME=$CHE_TEST_IMAGE_NAME" >> ~/.che/profiles/"${3}"
      echo "CHE_SERVER_CONTAINER_NAME=$CHE_SERVER_CONTAINER_NAME" >> ~/.che/profiles/"${3}"

      # Add all other variables to the profile
      env | grep CHE_ >> ~/.che/profiles/"${3}" || true

      # Remove duplicates, if any
      cat ~/.che/profiles/"${3}" | sort | uniq > ~/.che/profiles/tmp
      mv -f ~/.che/profiles/tmp ~/.che/profiles/"${3}"


      info ""
      info "Added new ${CHE_MINI_PRODUCT_NAME} CLI profile ~/.che/profiles/${3}."
      info ""
    ;;
    update)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} does not exist. Nothing to update. Exiting."
        error ""
        return
      fi

      execute_profile profile rm "${3}"
      execute_profile profile add "${3}"
    ;;
    rm)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} does not exist. Nothing to do. Exiting."
        error ""
        return
      fi

      rm ~/.che/profiles/"${3}" > /dev/null

      info ""
      info "Removed ${CHE_MINI_PRODUCT_NAME} CLI profile ~/.che/profiles/${3}."
      info ""
    ;;
    info)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/profiles/${3} does not exist. Nothing to do. Exiting."
        error ""
        return
      fi
 

      debug "---------------------------------------"
      debug "---------   CLI PROFILE INFO   --------"
      debug "---------------------------------------"
      debug ""
      debug "Profile ~/.che/profiles/${3} contains:"
      while IFS= read line
      do
        # display $line or do somthing with $line
        debug "$line"
      done <~/.che/profiles/"${3}"
    ;;
    set)
      if [ ! -f ~/.che/profiles/"${3}" ]; then
        error ""
        error "Profile ~/.che/${3} does not exist. Nothing to do. Exiting."
        error ""
        return
      fi
      
      echo "CHE_PROFILE=${3}" > ~/.che/profiles/.profile

      info ""
      info "Set active ${CHE_MINI_PRODUCT_NAME} CLI profile to ~/.che/profiles/${3}."
      info ""
    ;;
    unset)
      if [ ! -f ~/.che/profiles/.profile ]; then
        error ""
        error "Default profile not set. Nothing to do. Exiting."
        error ""
        return
      fi
      
      rm -rf ~/.che/profiles/.profile

      info ""
      info "Unset the default ${CHE_MINI_PRODUCT_NAME} CLI profile. No profile currently set."
      info ""
    ;;
    list)
      if [ -d ~/.che ]; then
        info "Available ${CHE_MINI_PRODUCT_NAME} CLI profiles:"
		//
		info() {
  printf  "${GREEN}INFO:${NC} %s\n" "${1}"
}
        ls ~/.che/profiles
      else
        info "No ${CHE_MINI_PRODUCT_NAME} CLI profiles currently set."
      fi

      if has_default_profile; then
        info "Default profile set to:"
        get_default_profile
      else
        info "Default profile currently unset."
      fi
    ;;
  esac
}

  ;;
  dir)
    # remove "dir" arg by shifting it
    shift
    load_profile
	//
	load_profile() {
  if has_default_profile; then

    source ~/.che/profiles/.profile

    if [ ! -f ~/.che/profiles/"${CHE_PROFILE}" ]; then
      error ""
      error "${CHE_MINI_PRODUCT_NAME} CLI profile set in ~/.che/profiles/.profile to '${CHE_PROFILE}' but ~/.che/profiles/${CHE_PROFILE} does not exist."
      error ""
      return
    fi

    source ~/.che//profiles/"${CHE_PROFILE}"
  fi
}

    execute_che_dir "$@"
	//
	execute_che_dir() {
  check_current_image_and_update_if_not_found ${CHE_DIR_IMAGE_NAME}
  //
  check_current_image_and_update_if_not_found() {

  CURRENT_IMAGE=$(docker images -q "$1":"${CHE_VERSION}")

  if [ "${CURRENT_IMAGE}" == "" ]; then
    update_che_image $1
	//
	update_che_image() {
  if [ -z "${CHE_VERSION}" ]; then
    CHE_VERSION=${DEFAULT_CHE_VERSION}
  fi

  info "${CHE_PRODUCT_NAME}: Pulling image $1:${CHE_VERSION}"
  docker pull $1:${CHE_VERSION}
  echo ""
}

  fi
}

  CURRENT_DIRECTORY=$(get_mount_path "${PWD}")
  //
  get_mount_path() {
  FULL_PATH=$(get_full_path "${1}")

  POSIX_PATH=$(convert_windows_to_posix "${FULL_PATH}")

  CLEAN_PATH=$(get_clean_path "${POSIX_PATH}")
  echo $CLEAN_PATH
}

  docker_run_with_che_properties -v "$CURRENT_DIRECTORY":"$CURRENT_DIRECTORY" "${CHE_DIR_IMAGE_NAME}":"${CHE_VERSION}" "${CURRENT_DIRECTORY}" "$@"
  //
  docker_run_with_che_properties() {
  if [ ! -z ${CHE_CONF_FOLDER+x} ]; then

    # Configuration directory set by user - this has precedence.
    docker_run_with_interactive -e "CHE_CONF_FOLDER=${CHE_CONF_FOLDER}" "$@"
  else 
    if has_che_properties; then
      # No user configuration directory, but CHE_PROPERTY_ values set
      generate_temporary_che_properties_file
	  //
	  generate_temporary_che_properties_file() {
  if has_che_properties; then
    test -d ~/.che/conf || mkdir -p ~/.che/conf
    touch ~/.che/conf/che.properties

    # Get list of properties
    PROPERTIES_ARRAY=($(env | grep CHE_PROPERTY_))
    for PROPERTY in "${PROPERTIES_ARRAY[@]}"
    do
      # CHE_PROPERTY_NAME=value ==> NAME=value
      PROPERTY_WITHOUT_PREFIX=${PROPERTY#CHE_PROPERTY_}

      # NAME=value ==> separate name / value into different variables
      PROPERTY_NAME=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f1 -d=)
      PROPERTY_VALUE=$(echo $PROPERTY_WITHOUT_PREFIX | cut -f2 -d=)
     
      # Replace "_" in names to periods

      # Replace "_" in names to periods
      CONVERTED_PROPERTY_NAME=$(echo "$PROPERTY_NAME" | tr _ .)

      # Replace ".." in names to "_"
      SUPER_CONVERTED_PROPERTY_NAME="${CONVERTED_PROPERTY_NAME//../_}"

      echo "$SUPER_CONVERTED_PROPERTY_NAME=$PROPERTY_VALUE" >> ~/.che/conf/che.properties
    done
  fi
}
	  
      docker_run_with_interactive -e "CHE_CONF_FOLDER=$(get_mount_path ~/.che/conf)" "$@"
      rm -rf ~/.che/conf/che.properties > /dev/null
    else
      docker_run_with_interactive "$@"
    fi
  fi
}

}

  ;;
  action)
    # remove "action" arg by shifting it
    shift
    load_profile
    execute_che_action "$@"
	//
	execute_che_action() {
  check_current_image_and_update_if_not_found ${CHE_ACTION_IMAGE_NAME}
  docker_run_with_che_properties "${CHE_ACTION_IMAGE_NAME}":"${CHE_VERSION}" "$@"
}


  ;;
  update)
    load_profile
    update_che_image ${CHE_LAUNCHER_IMAGE_NAME}
	//
	update_che_image() {
  if [ -z "${CHE_VERSION}" ]; then
    CHE_VERSION=${DEFAULT_CHE_VERSION}
  fi

  info "${CHE_PRODUCT_NAME}: Pulling image $1:${CHE_VERSION}"
  docker pull $1:${CHE_VERSION}
  echo ""
}
    update_che_image ${CHE_MOUNT_IMAGE_NAME}
    update_che_image ${CHE_DIR_IMAGE_NAME}
    update_che_image ${CHE_ACTION_IMAGE_NAME}
    update_che_image ${CHE_TEST_IMAGE_NAME}
    update_che_image ${CHE_DEV_IMAGE_NAME}

    # Delegate updating che-server to the launcher
    execute_che_launcher
	//
	execute_che_launcher() {
  check_current_image_and_update_if_not_found ${CHE_LAUNCHER_IMAGE_NAME}
  docker_run_with_che_properties "${CHE_LAUNCHER_IMAGE_NAME}":"${CHE_VERSION}" "${CHE_CLI_ACTION}" || true
}

  ;;
  mount)
    load_profile
    execute_che_mount "$@"
	//
	execute_che_mount() {
  if [ ! $# -eq 3 ]; then 
    error "${CHE_MINI_PRODUCT_NAME} mount: Wrong number of arguments provided."
    return
  fi

  MOUNT_PATH=$(get_mount_path "${2}")

  if [ ! -e "${MOUNT_PATH}" ]; then
    error "${CHE_MINI_PRODUCT_NAME} mount: Path provided does not exist."
    return
  fi

  if [ ! -d "${MOUNT_PATH}" ]; then
    error "${CHE_MINI_PRODUCT_NAME} mount: Path provided is not a valid directory."
    return
  fi

  docker_run_with_che_properties --cap-add SYS_ADMIN \
              --device /dev/fuse \
              -v "${MOUNT_PATH}":/mnthost \
              "${CHE_MOUNT_IMAGE_NAME}":"${CHE_VERSION}" "${GLOBAL_GET_DOCKER_HOST_IP}" $3
}
  ;;
  compile)
    # remove "compile" arg by shifting it
    shift
    load_profile
    execute_che_compile "$@"
	//
	execute_che_compile() {
  if [ $# -eq 0 ]; then 
    error "${CHE_MINI_PRODUCT_NAME} compile: Missing argument - pass compilation command as paramters."
    return
  fi

  check_current_image_and_update_if_not_found ${CHE_DEV_IMAGE_NAME}
  CURRENT_DIRECTORY=$(get_mount_path "${PWD}")
  docker_run_with_che_properties -v "$CURRENT_DIRECTORY":/home/user/che-build \
                                 -v "$(get_mount_path ~/.m2):/home/user/.m2" \
                                 -w /home/user/che-build \
                                 "${CHE_DEV_IMAGE_NAME}":"${CHE_VERSION}" "$@"
}
  ;;
  test)
    # remove "test" arg by shifting it
    shift
    load_profile
    execute_che_test "$@"
	//
	execute_che_test() {
  check_current_image_and_update_if_not_found ${CHE_TEST_IMAGE_NAME}
  docker_run_with_che_properties "${CHE_TEST_IMAGE_NAME}":"${CHE_VERSION}" "$@"
}

  ;;
  info)
    load_profile
    execute_che_info "$@"
	//
	execute_che_info() {
  if [ $# -eq 1 ]; then
    TESTS="--server"
  else
    TESTS=$2
  fi
  
  case $TESTS in
    --all|-all)
      print_che_cli_debug
	  //
	  print_che_cli_debug() {
  debug "---------------------------------------"
  //
  debug() {
  printf  "${BLUE}DEBUG:${NC} %s\n" "${1}"
}
  debug "---------    CLI DEBUG INFO    --------"
  debug "---------------------------------------"
  debug ""
  debug "---------  PLATFORM INFO  -------------"
  debug "CLI DEFAULT PROFILE       = $(has_default_profile && echo $(get_default_profile) || echo "not set")"
  debug "DOCKER_INSTALL_TYPE       = $(get_docker_install_type)"
  debug "DOCKER_HOST_IP            = ${GLOBAL_GET_DOCKER_HOST_IP}"
  debug "IS_DOCKER_FOR_WINDOWS     = $(is_docker_for_windows && echo "YES" || echo "NO")"
  debug "IS_DOCKER_FOR_MAC         = $(is_docker_for_mac && echo "YES" || echo "NO")"
  debug "IS_BOOT2DOCKER            = $(is_boot2docker && echo "YES" || echo "NO")"
  debug "IS_NATIVE                 = $(is_native && echo "YES" || echo "NO")"
  debug "HAS_DOCKER_FOR_WINDOWS_IP = $(has_docker_for_windows_ip && echo "YES" || echo "NO")"
  debug "IS_MOBY_VM                = $(is_moby_vm && echo "YES" || echo "NO")"
  debug "HAS_CHE_ENV_VARIABLES     = $(has_che_env_variables && echo "YES" || echo "NO")"
  debug "HAS_TEMP_CHE_PROPERTIES   = $(has_che_properties && echo "YES" || echo "NO")"
  debug "HAS_INTERACTIVE           = $(has_interactive && echo "YES" || echo "NO")"
  debug ""
}

      execute_che_launcher
      run_connectivity_tests
	  //
	  run_connectivity_tests() {
  debug ""
  debug "---------------------------------------"
  debug "--------   CONNECTIVITY TEST   --------"
  debug "---------------------------------------"
  # Start a fake workspace agent
  docker_exec run -d -p 12345:80 --name fakeagent alpine httpd -f -p 80 -h /etc/ > /dev/null

  AGENT_INTERNAL_IP=$(docker inspect --format='{{.NetworkSettings.IPAddress}}' fakeagent)
  AGENT_INTERNAL_PORT=80
  AGENT_EXTERNAL_IP=$GLOBAL_GET_DOCKER_HOST_IP
  AGENT_EXTERNAL_PORT=12345


  ### TEST 1: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I $(get_che_hostname):${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (Hostname)   : Connection succeeded"
  else
      debug "Browser             => Workspace Agent (Hostname)   : Connection failed"
  fi

  ### TEST 1a: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Browser             => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 2: Simulate Che server ==> workspace agent (external IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")
  
  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 3: Simulate Che server ==> workspace agent (internal IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (Internal IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (Internal IP): Connection failed"
  fi

  docker rm -f fakeagent > /dev/null
}

      execute_che_test post-flight-check "$@"
    ;;
    --cli|-cli)
      print_che_cli_debug
	  //
	  print_che_cli_debug() {
  debug "---------------------------------------"
  debug "---------    CLI DEBUG INFO    --------"
  debug "---------------------------------------"
  debug ""
  debug "---------  PLATFORM INFO  -------------"
  debug "CLI DEFAULT PROFILE       = $(has_default_profile && echo $(get_default_profile) || echo "not set")"
  debug "DOCKER_INSTALL_TYPE       = $(get_docker_install_type)"
  debug "DOCKER_HOST_IP            = ${GLOBAL_GET_DOCKER_HOST_IP}"
  debug "IS_DOCKER_FOR_WINDOWS     = $(is_docker_for_windows && echo "YES" || echo "NO")"
  debug "IS_DOCKER_FOR_MAC         = $(is_docker_for_mac && echo "YES" || echo "NO")"
  debug "IS_BOOT2DOCKER            = $(is_boot2docker && echo "YES" || echo "NO")"
  debug "IS_NATIVE                 = $(is_native && echo "YES" || echo "NO")"
  debug "HAS_DOCKER_FOR_WINDOWS_IP = $(has_docker_for_windows_ip && echo "YES" || echo "NO")"
  debug "IS_MOBY_VM                = $(is_moby_vm && echo "YES" || echo "NO")"
  debug "HAS_CHE_ENV_VARIABLES     = $(has_che_env_variables && echo "YES" || echo "NO")"
  debug "HAS_TEMP_CHE_PROPERTIES   = $(has_che_properties && echo "YES" || echo "NO")"
  debug "HAS_INTERACTIVE           = $(has_interactive && echo "YES" || echo "NO")"
  debug ""
}

    ;;
    --networking|-networking)
      run_connectivity_tests
	  //
	  run_connectivity_tests() {
  debug ""
  debug "---------------------------------------"
  debug "--------   CONNECTIVITY TEST   --------"
  debug "---------------------------------------"
  # Start a fake workspace agent
  docker_exec run -d -p 12345:80 --name fakeagent alpine httpd -f -p 80 -h /etc/ > /dev/null

  AGENT_INTERNAL_IP=$(docker inspect --format='{{.NetworkSettings.IPAddress}}' fakeagent)
  AGENT_INTERNAL_PORT=80
  AGENT_EXTERNAL_IP=$GLOBAL_GET_DOCKER_HOST_IP
  AGENT_EXTERNAL_PORT=12345


  ### TEST 1: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I $(get_che_hostname):${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (Hostname)   : Connection succeeded"
  else
      debug "Browser             => Workspace Agent (Hostname)   : Connection failed"
  fi

  ### TEST 1a: Simulate browser ==> workspace agent HTTP connectivity
  HTTP_CODE=$(curl -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                          -s -o /dev/null --connect-timeout 5 \
                          --write-out "%{http_code}") || echo "28" > /dev/null

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Browser             => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Browser             => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 2: Simulate Che server ==> workspace agent (external IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")
  
  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (External IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (External IP): Connection failed"
  fi

  ### TEST 3: Simulate Che server ==> workspace agent (internal IP) connectivity 
  export HTTP_CODE=$(docker run --rm --name fakeserver \
                                --entrypoint=curl \
                                codenvy/che-server:${DEFAULT_CHE_VERSION} \
                                  -I ${AGENT_EXTERNAL_IP}:${AGENT_EXTERNAL_PORT}/alpine-release \
                                  -s -o /dev/null \
                                  --write-out "%{http_code}")

  if [ "${HTTP_CODE}" = "200" ]; then
      debug "Che Server          => Workspace Agent (Internal IP): Connection succeeded"
  else
      debug "Che Server          => Workspace Agent (Internal IP): Connection failed"
  fi

  docker rm -f fakeagent > /dev/null
}


    ;;
    --server|-server)
      print_che_cli_debug
      execute_che_launcher
    ;;
    --create|-create)
      execute_che_test "$@"
    ;;
    *)
      debug "Unknown debug flag passed: $2. Exiting."
    ;;
  esac
}
	
  ;;
  help)
    usage
	//
	usage () {
  printf "%s" "${USAGE}"
  //
  
  USAGE="
Usage: ${CHE_MINI_PRODUCT_NAME} [COMMAND]
           start                              Starts ${CHE_MINI_PRODUCT_NAME} server
           stop                               Stops ${CHE_MINI_PRODUCT_NAME} server
           restart                            Restart ${CHE_MINI_PRODUCT_NAME} server
           update                             Pulls specific version, respecting CHE_VERSION
           profile add <name>                 Add a profile to ~/.che/ 
           profile set <name>                 Set this profile as the default for ${CHE_MINI_PRODUCT_NAME} CLI
           profile unset                      Removes the default profile - leaves it unset
           profile rm <name>                  Remove this profile from ~/.che/
           profile update <name>              Update profile in ~/.che/
           profile info <name>                Print the profile configuration
           profile list                       List available profiles
           mount <local-path> <ws-ssh-port>   Synchronize workspace to a local directory
           dir init                           Initialize directory with ${CHE_MINI_PRODUCT_NAME} configuration
           dir up                             Create workspace from source in current directory
           dir down                           Stop workspace running in current directory
           dir status                         Display status of ${CHE_MINI_PRODUCT_NAME} in current directory
           action <action-name> [--help]      Start action on ${CHE_MINI_PRODUCT_NAME} instance
           compile <mvn-command>              SDK - Builds Che source code or modules
           test <test-name> [--help]          Start test on ${CHE_MINI_PRODUCT_NAME} instance
           info [ --all                       Run all debugging tests
                  --server                    Run ${CHE_MINI_PRODUCT_NAME} launcher and server debugging tests
                  --networking                Test connectivity between ${CHE_MINI_PRODUCT_NAME} sub-systems
                  --cli                       Print CLI (this program) debugging info
                  --create [<url>]            Test creating a workspace and project in ${CHE_MINI_PRODUCT_NAME}
                           [<user>] 
                           [<pass>] ]
"
}
}
  ;;
esac



=======================
endof che-4.7.0.sh


getfrom README.md_4.7.0
====================
# Eclipse Che - Eclipse Next-Generation IDE
[![Join the chat at https://gitter.im/eclipse/che](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/eclipse/che?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
[![Eclipse License](http://img.shields.io/badge/license-Eclipse-brightgreen.svg)](https://github.com/codenvy/che/blob/master/LICENSE)
[![Build Status](https://ci.codenvycorp.com/buildStatus/icon?job=che-ci-master)](https://ci.codenvycorp.com/job/che-ci-master)

https://www.eclipse.org/che/. Next-generation Eclipse platform, developer workspace server and cloud IDE. Che defines workspaces that include their dependencies including embedded containerized runtimes, Web IDE, and project code. This makes workspaces distributed, collaborative, and portable to run anywhere on a desktop or a server ... [Read More](https://www.eclipse.org/che/features/)

![Eclipse Che](https://www.eclipse.org/che/images/banner@2x.png "Eclipse Che")

### Getting Started
You can run Che in the public cloud, a private cloud, or install it on any OS. Che has been tested on Ubuntu, Linux, MacOS and Windows. The [step by step guide](http://eclipse.org/che/getting-started/) will get you going.

The `che` repository is where we do development and there are many ways you can participate, for example:

- [Submit bugs and feature requests](http://github.com/eclipse/che/issues) and help us verify them
- Review [source code changes](http://github.com/eclipse/che/pulls)
- [Review the docs](https://eclipse-che.readme.io/docs/) and make improvements for anything from typos to new content

### Customizing
There are many ways to customize Che out-of-the-box including [stacks, templates, commands, IDE extensions, server-side extensions plugins, assemblies, RESTful APIs, and editors](https://github.com/eclipse/che/blob/master/CUSTOMIZING.md). 

### Contributing
If you are interested in fixing issues and contributing directly to the code base, please see [How to Contribute](https://github.com/eclipse/che/wiki/How-To-Contribute). It covers:
- [Submitting bugs](https://github.com/eclipse/che/wiki/Submitting-Bugs-and-Suggestions)
- [Development workflow](https://github.com/eclipse/che/wiki/Development-Workflow)
- [Coding guidelines](https://github.com/eclipse/che/wiki/Coding-Guidelines)
- [Contributor license agreement](https://github.com/eclipse/che/wiki/Contributor-License-Agreement)

### Feedback
* **Support:** You can ask questions, report bugs, and request features using [GitHub issues](http://github.com/eclipse/che/issues).
* **Roadmap:** We maintain [the roadmap](https://github.com/eclipse/che/wiki/Roadmap) on the wiki. 
* **Weekly Meetings:** Join us on [a hangout](https://github.com/eclipse/che/wiki/Weekly-Planning-Meetings). 

### License
Che is open sourced under the Eclipse Public License 1.0.

=====================
endof README.md_4.7.0



getfrom CUSTOMIZING.md_4.7.0
==============
Eclipse Che is a platform for creating distributed developer tooling. There are numerous ways to extend, modify, and customize Eclipse Che. This document itemizes all of the resources available for customizing Che. We have documentation pages, tutorials, and specifications.

#### Stacks
A stack is the configuration of a runtime that can be used to power a workspace. Users choose the stack that powers a workspace within the user dashboard. Stacks have a recipe that defines how the container should be created and also meta data that defines the tags associated with the stack. 
* [Add Your Stacks to Che](https://eclipse-che.readme.io/docs/stacks#custom-stacks-for-che)
* [Stack Data Model](https://eclipse-che.readme.io/docs/stack)
* [Che Included Stacks](https://eclipse-che.readme.io/docs/stacks#section-ready-to-go-stacks)
* [Add Your Stack to Default Che Assembly](https://eclipse-che.readme.io/v4.0/docs/stacks#adding-stacks-to-the-che-default-assembly)
* * TODO: Update this link to point to wiki page that can be updated by community

#### Recipes
A recipe defines the runtime of a workspace environment.  Workspaces can have multiple environments, each with their own runtime.  Che supports different kinds of runtimes, but the default is Docker letting us make use of [Dockerfiles](https://docs.docker.com/engine/reference/builder/) as recipes. 
* [Recipes](https://eclipse-che.readme.io/docs/recipes)
* [Writing Custom Recipes](https://eclipse-che.readme.io/v4.3/docs/recipes#section-authoring-custom-recipes)
* [Che Included Recipes](https://github.com/codenvy/dockerfiles)

#### Templates
A template is a packaged set of sample code that is launched in the workspace when a user creates a new project. Users can select from a template while using the user dashboard. Templates have both sample code and a default set of commands associated with them. Templates are loaded based upon the type of stack selected. You can add your own templates to the default Che distribution.
* [Templates](https://eclipse-che.readme.io/docs/templates)
* [Add Templates](https://eclipse-che.readme.io/docs/templates#register-new-project-templates)
* [Template Data Model](https://eclipse-che.readme.io/docs/template)
* [Add Your Template to Default Che Assembly](https://eclipse-che.readme.io/docs/templates#section-add-your-template-to-default-che-assembly)

#### Commands
A command is a process that is injected into your workspace. It's outputs are streamed into the console. Commands have type and you can create, save, update and delete commands from within the IDE. You can create templates that have sample projects with default commands that are pre-populated in the IDE. Commands can reference macros that intelligently navigate the project tree or current selections.
* [Commands](https://eclipse-che.readme.io/docs/commands)
* [Macros](https://eclipse-che.readme.io/docs/commands#macros)
* [Command Data Model](https://eclipse-che.readme.io/docs/command)

#### Extension Development
An extension is a set of code and resources that are packaged into a plugin that alter the behavior of the system. Extensions can be IDE extensions, workspace extensions (they are injected into the workspace agent running within each workspace), or Che extensions (injected into the Che server). Extensions are authored in Java and maven, and then packaged into JAR / ZIP files for deployment into Eclipse Che.
* [Extension Intro](https://dash.readme.io/project/eclipse-che/docs/introduction-1)
* [Developing Extensions](https://eclipse-che.readme.io/docs/create-and-build-extensions)
* [JSON Extension Tutorial](https://eclipse-che.readme.io/docs/introduction-1#section-the-json-example)
* [Authoring Extensions in Che](https://eclipse-che.readme.io/docs/setup-che-workspace#author-extension-using-the-che-ide)
* [Authoring Extensions in Eclipse](https://eclipse-che.readme.io/docs/setup-che-workspace#author-extension-using-the-eclipse-ide)
* [Authoring Extensions in IntelliJ](https://eclipse-che.readme.io/docs/setup-che-workspace#author-extensions-using-intellij-ide)
* [Dependency Injection](https://eclipse-che.readme.io/docs/dependency-injection-basics)
* [Extensions Packaged With Che](https://github.com/eclipse/che/tree/master/plugins)
* [Extension SDK JavaDoc](https://eclipse-che.readme.io/docs/java-class-reference)

#### IDE Extensions
IDE extensions are compiled into JavaScript with other extensions to create a single, JavaScript application. You can package many extensions together into a single JavaScript application. The JavaScript application is cross-browser optimized. You can debug extensions and perform execution traces from within the browser of extension code. IDE extensions can invoke REST services that are running within the Che server or within a workspace. Che provides default workspace REST APIs or you can provide your own with workspace extensions.
* [Invoking Workspace REST APIs](https://eclipse-che.readme.io/docs/calling-workspace-apis)
* [Editors](https://eclipse-che.readme.io/docs/code-editors)
* [Project Type](https://eclipse-che.readme.io/docs/project-types)
* [Actions](https://eclipse-che.readme.io/docs/actions)
* [Services](https://eclipse-che.readme.io/docs/serverworkspace-access)
* [Parts](https://eclipse-che.readme.io/docs/parts)
* [Commands](https://github.com/benoitf/ide-plugin-demo)
* [Events](https://eclipse-che.readme.io/docs/events)
* * TODO: Panels 
* * TODO: Popups
* * TODO: Wizards

#### Server-Side Extensions
Server-side extensions are libraries that are deployed into the workspace agent when the workspace is activated. Che deploys some standard server-side extensions that expose the Workspace REST API to the outside world. You can author extensions that modify or extend this API with your own services. New workspace APIs are exposed as JAX-RS services and you use dependency injection to define the API interfaces.
* * TODO: JAX-RS Conventions
* * TODO: Adding Custom Services into Workspace Agent

#### Workspace REST API
IDE extensions have access to a default set of workspace APIs that are deployed within each workspace. These APIs are available through a Swagger configuration. 
* [Swagger](https://eclipse-che.readme.io/docs/rest-api)
* [Authentication](https://eclipse-che.readme.io/docs/authentication)
* [Workspaces](https://eclipse-che.readme.io/docs/create-workspaces-and-projects)
* [Projects](https://eclipse-che.readme.io/docs/api-projects)
* [Project Types](https://eclipse-che.readme.io/docs/custom-project-types)
* [File Access](https://eclipse-che.readme.io/docs/edit-build-and-run)
* [Events](https://eclipse-che.readme.io/docs/events)

#### Plug-Ins and Assemblies
A plugin is a set of extensions (both IDE and workspace extensions) along with their collective reosurces that are packaged into a single deployable unit, usually as a JAR or ZIP file. An assembly is a set of plug-ins combined with the Eclipse Che core that is assembled into a re-distributable set of binaries. A new assembly can fundamentally alter the Che branding. Che can create assemblies packaged as a desktop IDE or as a new Che server.
* [Plugin Development](https://eclipse-che.readme.io/docs/plug-ins)
* [Drag and Drop](https://eclipse-che.readme.io/docs/developing-plugins) - Not yet updated for 4.x
* [Assemblies](https://eclipse-che.readme.io/docs/assemblies)

==============
endof CUSTOMIZING.md_4.7.0



getfrom Dockerfile_4.7.0
=====================
# Copyright (c) 2012-2016 Codenvy, S.A., Red Hat, Inc
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#   Mario Loriedo
#   Codenvy S.A
#
# To build it, run in the repository root:
#  `docker build -t codenvy/che-server .`
#
# To run it:
#  docker run --net=host \
#             --name che \
#             -v /var/run/docker.sock:/var/run/docker.sock \
#             -v /home/user/che/lib:/home/user/che/lib-copy \
#             -v /home/user/che/workspaces:/home/user/che/workspaces \
#             -v /home/user/che/storage:/home/user/che/storage \
#             codenvy/che-server
#           
FROM alpine:3.4

ENV LANG=C.UTF-8 \
    JAVA_HOME=/usr/lib/jvm/default-jvm/jre \
    PATH=${PATH}:${JAVA_HOME}/bin \
    CHE_HOME=/home/user/che \
    DOCKER_VERSION=1.6.0 \
    DOCKER_BUCKET=get.docker.com

RUN echo "http://dl-4.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories && \
    apk upgrade --update && \
    apk add --update ca-certificates curl openssl openjdk8 sudo bash && \
    curl -sSL "https://${DOCKER_BUCKET}/builds/Linux/x86_64/docker-${DOCKER_VERSION}" -o /usr/bin/docker && \
    chmod +x /usr/bin/docker && \
    addgroup -S user -g 1000 && \
    adduser -S user -h /home/user -s /bin/bash -G root -u 1000 -D && \
    addgroup -S docker -g 101 && \
    adduser user docker && \
    adduser user user && \
    adduser user users && \
    addgroup -g 50 -S docker4mac && \
    adduser user docker4mac && \
    echo "%root ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers && \
    rm -rf /tmp/* /var/cache/apk/*

EXPOSE 8000 8080

USER user

ADD assembly/assembly-main/target/eclipse-che-*/eclipse-che-* /home/user/che/

ENV CHE_HOME /home/user/che

ENTRYPOINT [ "/home/user/che/bin/che.sh", "-c" ]

CMD [ "run" ]
==================
endof Dockerfile_4.7.0




getfrom NUMBERING.md_4.7.0
================
### Schema
```
a.b.c-d
  a = major
  b = feature
  c = bug fix
  d = development, numbered as `<rc>d`
```

### Release
```
a.b.0 - initial
a.b.c - bug fixing
```

## EXAMPLE
### Before Stable Release
```
4.0.0-rc1-SNAPSHOT - This is a build
4.0.0-rc1          - This is a release  
4.0.0-rc2-SNAPSHOT - This is a build
4.0.0-rc2          - This is a release
```

### Ship
```
4.0.0 
```

### Branch For Fixes
```
4.0.x
```

### Version For Fixes On Ship Release
```
4.0.1
4.0.2
```


=============
endof NUMBERING.md_4.7.0




getfrom Vagrantfile_4.7.0
====================
# Copyright (c) 2012-2016 Codenvy, S.A.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#   Codenvy, S.A. - initial API and implementation

# Set to "<proto>://<user>:<pass>@<host>:<port>"
$http_proxy    = ENV['HTTP_PROXY'] || ""
$https_proxy   = ENV['HTTPS_PROXY'] || ""
$no_proxy      = ENV['NO_PROXY'] || "localhost,127.0.0.1"
$che_version   = ENV['CHE_VERSION'] || "nightly"
$ip            = ENV['CHE_IP'] || "192.168.28.100"
$hostPort      = (ENV['CHE_PORT'] || 8080).to_i
$containerPort = (ENV['CHE_CONTAINER_PORT'] || ($hostPort == -1 ? 8080 : $hostPort)).to_i
$user_data     = ENV['CHE_DATA'] || "."
$vm_name       = ENV['CHE_VM_NAME'] || "eclipse-che-vm"
$provisionProgress = ENV['PROVISION_PROGRESS'] || "basic"

Vagrant.configure(2) do |config|
  puts ("ECLIPSE CHE: VAGRANT INSTALLER")
  puts ("ECLIPSE CHE: REQUIRED: VIRTUALBOX 5.x")
  puts ("ECLIPSE CHE: REQUIRED: VAGRANT 1.8.x")
  puts ("")
  if ($http_proxy.to_s != '' || $https_proxy.to_s != '') && !Vagrant.has_plugin?("vagrant-proxyconf")
    puts ("You configured a proxy, but Vagrant's proxy plugin not detected.")
    puts ("Install the plugin with: vagrant plugin install vagrant-proxyconf")
    Process.kill 9, Process.pid
  end

  if Vagrant.has_plugin?("vagrant-proxyconf")
    config.proxy.http = $http_proxy
    config.proxy.https = $https_proxy
    config.proxy.no_proxy = $no_proxy
  end

  config.vm.box = "boxcutter/centos72-docker"
  config.vm.box_download_insecure = true
  config.ssh.insert_key = false
  if $ip.to_s.downcase == "dhcp"
    config.vm.network :private_network, type: "dhcp"
  else
    config.vm.network :private_network, ip: $ip
  end
  if $hostPort != -1
    config.vm.network "forwarded_port", guest: $containerPort, host: $hostPort
  end
  config.vm.synced_folder $user_data, "/home/user/che"
  config.vm.define "che" do |che|
  end

  config.vm.provider "virtualbox" do |vb|
    vb.memory = "4096"
    vb.name = $vm_name
  end

  $script = <<-'SHELL'
    HTTP_PROXY=$1
    HTTPS_PROXY=$2
    NO_PROXY=$3
    CHE_VERSION=$4
    IP=$5
    PORT=$6
    PROVISION_PROGRESS=$7

    if [ "${IP,,}" = "dhcp" ]; then
       echo "----------------------------------------"
       echo "ECLIPSE CHE: CHECKING DYNAMIC IP ADDRESS"
       echo "----------------------------------------"
       DEV=$(grep -l "VAGRANT-BEGIN" /etc/sysconfig/network-scripts/ifcfg-*|xargs grep "DEVICE="|sort|tail -1|cut -d "=" -f 2)
       if [ -z "${DEV}" ]; then
          >&2 echo "Unable to find DHCP network device"
          exit 1
       fi
       IP=$(ip addr show dev ${DEV} | sed -r -e '/inet [0-9]/!d;s/^[[:space:]]*inet ([^[:space:]/]+).*$/\1/')
       if [ -z "${IP}" ]; then
          >&2 echo "Unable to find DHCP network ip"
          exit 1
       fi
       echo "IP: ${IP}"
       echo
    fi

    if [ -n "$HTTP_PROXY" ] || [ -n "$HTTPS_PROXY" ]; then
      echo "-------------------------------------"
      echo "."
      echo "ECLIPSE CHE: CONFIGURING SYSTEM PROXY"
      echo "."
      echo "-------------------------------------"
      echo 'export HTTP_PROXY="'$HTTP_PROXY'"' >> /home/vagrant/.bashrc
      echo 'export HTTPS_PROXY="'$HTTPS_PROXY'"' >> /home/vagrant/.bashrc
      source /home/vagrant/.bashrc

      # Configuring the Che properties file - mounted into Che container when it starts
      echo 'http.proxy="'$HTTP_PROXY'"' >> /home/user/che/conf/che.properties
      echo 'https.proxy="'$HTTPS_PROXY'"' >> /home/user/che/conf/che.properties

      echo "HTTP PROXY set to: $HTTP_PROXY"
      echo "HTTPS PROXY set to: $HTTPS_PROXY"
    fi

    function perform
    {
      local progress=$1
      local command=$2
      shift 2

      local pid=""

      case "$progress" in
        extended)
          # simulate tty environment to get full output of progress bars and percentages
          printf "set timeout -1\nspawn %s\nexpect eof" "$command $*" | expect -f -
          ;;
        basic|*)
          $command "$@" &>/dev/null &
          pid=$!
          while kill -0 "$pid" >/dev/null 2>&1; do
            printf "#"
            sleep 10
          done
          wait $pid # return pid's exit code
          ;;
      esac
    }

    echo "------------------------------------"
    echo "ECLIPSE CHE: UPGRADING DOCKER ENGINE"
    echo "------------------------------------"
    if [ "$PROVISION_PROGRESS" = "extended" ]; then
       # we sacrifice a few seconds of additional install time for much better progress afterwards
       perform basic yum -y install expect
    fi
    perform $PROVISION_PROGRESS sudo yum -y update docker-engine

    echo $(docker --version)

    # Add the 'vagrant' user to the 'docker' group
    usermod -aG docker vagrant &>/dev/null

    # We need write access to this file to enable Che container to create other containers
    sudo chmod 777 /var/run/docker.sock &>/dev/null

    # Setup the overlay storage driver to eliminate errors
    #sudo sed -i '/ExecStart=\/usr\/bin\/dockerd/c\ExecStart=\/usr\/bin\/dockerd --storage-driver=overlay' /lib/systemd/system/docker.service

    # Configure Docker daemon with the proxy
    if [ -n "$HTTP_PROXY" ] || [ -n "$HTTPS_PROXY" ]; then
        mkdir /etc/systemd/system/docker.service.d
    fi
    if [ -n "$HTTP_PROXY" ]; then
        printf "[Service]\nEnvironment=\"HTTP_PROXY=${HTTP_PROXY}\"" > /etc/systemd/system/docker.service.d/http-proxy.conf
        printf ""
    fi
    if [ -n "$HTTPS_PROXY" ]; then
        printf "[Service]\nEnvironment=\"HTTPS_PROXY=${HTTPS_PROXY}\"" > /etc/systemd/system/docker.service.d/https-proxy.conf
    fi
    if [ -n "$HTTP_PROXY" ] || [ -n "$HTTPS_PROXY" ]; then
        printf "[Service]\nEnvironment=\"NO_PROXY=${NO_PROXY}\"" > /etc/systemd/system/docker.service.d/no-proxy.conf
    fi

    systemctl daemon-reload
    systemctl restart docker

    echo "--------------------------------------------------"
    echo "ECLIPSE CHE: DOWNLOADING ECLIPSE CHE DOCKER IMAGES"
    echo "--------------------------------------------------"
#    perform $PROVISION_PROGRESS docker pull codenvy/che-launcher:${CHE_VERSION}
#    perform $PROVISION_PROGRESS docker pull codenvy/che-server:${CHE_VERSION}
    docker pull alpine:latest
    docker pull codenvy/che-launcher:${CHE_VERSION}
    docker pull codenvy/che-server:${CHE_VERSION}

    curl -sL https://raw.githubusercontent.com/eclipse/che/master/che.sh | tr -d '\15\32' > /home/vagrant/che.sh
    chmod +x /home/vagrant/che.sh
    
    echo "export CHE_PORT=${PORT}" >> /etc/profile.d/vars.sh
    echo "export CHE_VERSION=${CHE_VERSION}" >> /etc/profile.d/vars.sh
    echo "export CHE_HOST_IP=172.17.0.1" >> /etc/profile.d/vars.sh
    echo "export CHE_HOSTNAME=${IP}" >> /etc/profile.d/vars.sh

  SHELL

  config.vm.provision "shell" do |s|
    s.inline = $script
    s.args = [$http_proxy, $https_proxy, $no_proxy, $che_version, $ip, $containerPort, $provisionProgress]
  end

  $script2 = <<-'SHELL'
    IP=$1
    PORT=$2
    MAPPED_PORT=$3

    echo "--------------------------------"
    echo "ECLIPSE CHE: BOOTING ECLIPSE CHE"
    echo "--------------------------------"

    docker run --rm -t -v /var/run/docker.sock:/var/run/docker.sock \
               -e "CHE_PORT=${CHE_PORT}" \
               -e "CHE_RESTART_POLICY=always" \
               -e "CHE_HOST_IP=${CHE_HOST_IP}" \
               -e "CHE_HOSTNAME=${CHE_HOSTNAME}" \
               codenvy/che-launcher:${CHE_VERSION} start


    if [ "${IP,,}" = "dhcp" ]; then
       DEV=$(grep -l "VAGRANT-BEGIN" /etc/sysconfig/network-scripts/ifcfg-*|xargs grep "DEVICE="|sort|tail -1|cut -d "=" -f 2)
       IP=$(ip addr show dev ${DEV} | sed -r -e '/inet [0-9]/!d;s/^[[:space:]]*inet ([^[:space:]/]+).*$/\1/')
    fi

    rm -f /home/user/che/.che_url
    rm -f /home/user/che/.che_host_port
    CHE_URL="http://${IP}:${PORT}"

    echo "${CHE_URL}" > /home/user/che/.che_url
    echo "${MAPPED_PORT}" > /home/user/che/.che_host_port
    echo ""
    echo "ECLIPSE CHE READY AT: ${CHE_URL}"

  SHELL

  config.vm.provision "shell", run: "always" do |s|
    s.inline = $script2
    s.args = [$ip, $containerPort, $hostPort]
  end

end

=====================
endof Vagrantfile_4.7.0



getfrom CODE_OF_CONDUCT.md_4.7.0
====================
# Contributor Code of Conduct

As contributors and maintainers of this project, and in the interest of
fostering an open and welcoming community, we pledge to respect all people who
contribute through reporting issues, posting feature requests, updating
documentation, submitting pull requests or patches, and other activities.

We are committed to making participation in this project a harassment-free
experience for everyone, regardless of level of experience, gender, gender
identity and expression, sexual orientation, disability, personal appearance,
body size, race, ethnicity, age, religion, or nationality.

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery
* Personal attacks
* Trolling or insulting/derogatory comments
* Public or private harassment
* Publishing other's private information, such as physical or electronic
  addresses, without explicit permission
* Other unethical or unprofessional conduct

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

By adopting this Code of Conduct, project maintainers commit themselves to
fairly and consistently applying these principles to every aspect of managing
this project. Project maintainers who do not follow or enforce the Code of
Conduct may be permanently removed from the project team.

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community.

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting a project maintainer at info@codenvy.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. Maintainers are
obligated to maintain confidentiality with regard to the reporter of an
incident.


This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 1.3.0, available at
[http://contributor-covenant.org/version/1/3/0/][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/3/0/
=====================
endof CODE_OF_CONDUCT.md_4.7.0


getfrom CONTRIBUTING.md_4.7.0
================
Contributing to Eclipse Che
=====================

Before Submitting an Issue
--------------------------
Check that [our issue database](https://github.com/eclipse/che/issues)
doesn't already include that problem or suggestion before submitting an issue.
If you find a match, you can use the "subscribe" button to get notified on
updates. Do *not* leave random "+1" or "I have this too" comments, as they
only clutter the discussion, and don't help resolving it. However, if you
have ways to reproduce the issue or have additional information that may help
resolving the issue, please leave a comment.

Writing Good Bug Reports and Feature Requests
---------------------------------------------
Please file a single issue per problem and feature request. Do not file combo issues.

The more information you can provide, the more likley someone will be successful reproducing the issue and finding a fix. Therefore:
* Provide reproducibule steps, what the result of the steps was, and what you would have expected.
* A detailed description of the behavior that you expect.
* Animated GIFs are a tremendous help.
* Version information of Eclipse Che and Docker.
* Error outputs that may exist in your browser console.

Contributing Improvements
-------------------------
If you are interested in fixing issues and contributing directly to the code base, please the document [How to Contribute](https://github.com/eclipse/che/wiki/How-To-Contribute).
===================
endof CONTRIBUTING.md_4.7.0



getfrom AUTHORING EXTENSIONS
================
\\Introduction
Introduction
This part of the documentation describes how to extend Eclipse Che with custom plugins, e.g. to provide support for new languages. It covers various aspects from adding new file types, extending the code editor, adding intellisense features, defining a specific project-type, and accessing the workspace. Before you start to extend Che, we recommend to get a general technical overview as provided here.

In general, Che can be extended in its three different components, the IDE running in the Browser, the Che Server, and the Workspace (see diagram below).

First, the IDE running in the Browser can be extended by new local features, such as simple actions, new editors, and views, or immediate syntax highlighting. Some of these extensions can run completely local, some will use the Che server API.

Second, the Che Server can be extended by new plugins. Those extensions will also affect the IDE, e.g. defining a new project type in a plugin, which is done on the server, will create a menu entry in the New dialog of the IDE. Server plugins might provide new APIs to be consumed by IDE plugins, e.g. to provide new IntelliSense features. Finally, server plugins can also access the current workspace, e.g. to access files, projects or even the current target machine. Again, there is existing API provided by the workspace agent to be used.

Third, the Workspace can also be extended to provide new API to be consumed by the Che server.


Therefore, typical extensions of Che are deployed to up to three different components, depending on the use case. However, as many extensions include plugin parts for the IDE, the server and even the Workspace, the extension documentation is not organized by Che components, but by extension use cases (e.g. adding a new file type or implementing a client server communication accessing the workspace).

Technically, client and server extensions are different components, however, as they conceptually belong together, they are organized in one plugin containing several sub-components.

This tutorial starts with an introduction on the following prerequisites to build a custom extensions. If you want to follow the tutorial hands-on, you should read those sections, if you are just interested in learning about a specific extension use case, you might skip them for now.

How to set-up a workspace for developing a Che extension.
How to create and build extensions including a description of the general plugin structure used in Che
A brief introduction on dependency injection and its usage in Che, on the client and on the server side. (If you are already familiar with Guice and Gin, you might want to skip this part)
The remaining tutorial is structured along extension use cases. For every extension capability, we provide a general introduction containing code examples.

The tutorial often refers to a continuous example: The implementation of simple JSON support in Eclipse Che. If you are interested in learning about a certain extension use case, please directly navigate to the respective part of the tutorial. If you are interested in getting an overview about the most important extension features, please have a look at the introduction of the JSON example in the following section. It provides a use case oriented overview of the contents of this tutorial and contains links to the detailed parts.

THE JSON EXAMPLE
In this section, we give a functional overview of the continuous example that we use in most parts of this tutorial, the JSON Example. It provides simple support for creating, modifying and validating JSON files within Eclipse Che. Please note that the JSON example is not designed to provide perfect JSON support in Che. In fact, it is designed to cover most aspects of providing support for a custom language in Eclipse Che while remaining as simple as possible. This section shall provide an overview about the example and at the same time about Ches various extension use cases.

The source code for the JSON example is part of the Eclipse Che project itself, you can find it here:
https://github.com/eclipse/che/tree/master/samples/sample-plugin-json

The example includes the following parts, which can be found in the respective parts of this tutorial.

File Type and Code Editor
The example provides a custom file type for JSON including a custom icon. For this file type it includes a custom code editor for JSON files. The code editor provides syntax highlighting for JSON files.


Additionally, the example implements code completion based on a list of suggestions. There are two sources for the list of suggestions, the first and simple one is directly calculated on the client, it can therefore only operate on information available in the context (e.g. the current file opened). The second one is calculated on the server and can therefore access the complete workspace to calculate the suggestions.


Project Type
There is a custom project type for working with JSON files. The example provides a custom project creation wizard which allows to enter project specific data. In case of the JSON example, it allows to specify a URL pointing to a JSON schema, which is later used to validate the JSON files within the project. The project wizard is available in the standard Create New Project dialog of Che:


The JSON example wizard will initialize a new project with two existing JSON files and a directory to contain custom ones:


Actions
The JSON example register two project-specific actions for the custom project type. The first one implements a simple Hello World. The second one calls a custom service on the server which will access the workspace and count the number of lines of all JSON files within the project. It thereby also includes a template for client/server communication and for accessing source files (e.g. for validation or compilation).


\\\\\\\\\\\\\\\\\IDE Setup
IDE Setup
This page explains how to setup a developer workspace for Che using various IDEs. This includes checking out the sources. If you want to build an extension for Che, you should also follow these instructions.

Setting up your environment consist of three steps, (1) Getting the source code, (2), setting up your IDE for development, (3) and configuring the maven build.


Che is IDE agnostic. We provide configuration instructions for:

Eclipse (using the Eclipse Installer)
IntelliJ
Che IDE (coming soon)
After setting up a workspace, you find documentation about how to setup your build and run environment for Che in the following guide: Developing Extensions.

Pre-requisites
Dependencies

Docker 1.8+
Maven 3.3.1+
Oracle or OpenJDK Java 1.8
The M2_HOME and M2 variables should be set correctly.

To build the user dashboard submodule, you will need npm, bower, gulp, and python.

Python v2.7.x (v3.x.x is currently not supported)
Node.js v4.x.x (v5.x.x / v6.x.x are currently not supported)
npm
Bower
gulp
Installation instructions for Node.js and npm can be found on the following link. Bower and gulp are CLI utilities which are installed via npm:

Shell
$ npm install --global bower gulp
Developers on Windows
To build the Che core, you will need the maven-patch-plugin. Windows does not support this plugin, and we give instructions on how to skip this plugin when building. You can also optionally modify your build to download the patch tool and then add the patch tool to your PATH.

If you are a developer on Windows you'll not be able to do a complete build of Che by doing a mvn clean install. There are certain modules that require additional libraries and are OS specific. (dashboard and svn plugin)

In this situation, we recommend to build Che sources using the "che-dev" Docker image. This image has the dependencies necessary to build Che. You'll mount Che source code from your host to the container and then compile the code within the container.

Shell
# For Windows, replace $HOME with maven repo directory.
# For Windows, replace $PWD with Che source code directory.

docker run -it --rm --name build-che 
           -v "$HOME/.m2:/home/user/.m2" 
           -v "$PWD":/home/user/che-build 
           -w /home/user/che-build 
           eclipse/che-dev 
           mvn -DskipTests=true 
               -Dfindbugs.skip=true
               -Dgwt.compiler.localWorkers=2 -T 1C 
               -Dskip-validate-sources 
               -Dmdep.analyze.skip=true 
               -Dlicense.skip=true
               clean install

# For Mac + Linux - replace $PWD with the root path to build:
Alternatively you can also skip building certain submodules:

Shell
# Each submodule may require additional software to build properly.
# You can skip a submodule to avoid installing additional software.
# For example, to skip building the dashboard:
mvn -pl '!dashboard' clean install
Eclipse IDE - Yatta Installer
The Yatta Installer for Eclipse Che installs Eclipse, the necessary plugins, checkout the Che source code, and configure a Che workspace. There is a lot going on, so this installation can take a few minutes.

 The Yatta Installer Requires JavaFX

In case you use OpenJDK, you will need to install openjfx first.



OPTIONAL
You can consider to deactivate automatic builds in eclipse as this will run maven in places you may not want it to. Rebuilding some Che modules is not necessary unless you modify the code in that module. Otherwise, maven will grab the latest versioned module from Nexus.

If you plan to update files outside the workbench, then you can add a native update hook refresh.

Eclipse IDE - Neon Installer
If you install Eclipse manually, you will need to use the Eclipse Installer. Please get the Eclipse IDE for Java configured with the maven plugin.

Download Eclipse Neon from https://www.eclipse.org/downloads/eclipse-packages/ and select Eclipse IDE for Java EE Developers

Clone Eclipse Che sources on your local computer (repository URL: https://github.com/eclipse/che)

Once Eclipse installed, do Import > Maven > Existing Maven Projects


You will then be asked to select the existing projects to imported. Select them all.

The projects will be imported and you will see them in the explorer.

While the workspace will be built for the first time, you'll be asked to install the missing Eclipse plugins corresponding to the maven goals:




Define the Maven command to build Che. Create a new "Run Configuration"

Double click on "Maven Build"

Choose "che-parent" or "assembly-main" to be the base directory:


Add the following goal clean install

Check the checkmark for skipping tests:


Build the workspace by executing the command you defined:

This will create an assembly in {workspace-path}\che\assembly\assembly-main\target\eclipse-che-<version>\eclipse-che-<version>

 Tips

You might have Eclipse not discovering properly your environment variables. In this case, configure your environment variables with the custom command.
It happens sometimes, that 'npm' is not having the right permissions to complete the build. In this case, remove your npm repository (.npm folder)
Fixing the error marks
There are certains Maven goals that are not completed by Eclipse at once.
The idea is to require Eclipse to rebuild the workspace and update the project's dependencies. You can do that by doing right click on the projects (probably all the first time you are setupping the workspace).


To start Che from the custom assembly you just built, you can refer to this Usage: Docker Launcher. Remind your custom assembly is located in {workspace-path}\che\assembly\assembly-main\target\eclipse-che-<version>\eclipse-che-<version>
GWT Super Dev Mode for Eclipse
GWT Super Dev Mode allows you to perform incremental compilations of Che's Java IDE into JavaScript. This makes redeploys nearly instant and allows for a natural style of IDE development.

You do not need GWT Super Dev Mode if you are building Che server-side or workspace extensions. This is only needed for customizations to the Java IDE which is transpiled into JavaScript.

INSTALL GOOGLE PLUGIN FOR ECLIPSE
This is a general purpose plugin that orchestrates integrating and configuring other Google software within Eclipse. The plugin is downloaded by entering a plugin URL in Help > Install New Software. The plugin URL is on [Google's Eclipse page]


(https://developers.google.com/eclipse/docs/getting_started). You will be asked to install software for Google App Engine and other Google utilities. You only need the Eclipse plugin package.

DOWNLOAD GWT SDK
Download the GWT SDK 2.7.0 zip from Google's site. You will need to explode it and save in a directory on your compuer.

In Eclipse, go to Window > Preferences > Google > Web Toolkit > SDKs > Add. You will need to specify the directory where GWT is installed. The GWT zip has a few different sub-layers, so choose the directory where all of the JAR files are installed.

SETUP RUN CONFIGURATION
In Eclipse, go to Run > Run Configurations, select Java Application, right click and select New.

In the Main tab, add the project assembly-ide-war with main class as com.google.gwt.dev.codeserver.CodeServer.


In the same panel, select the Arguments tab. We will add some content to Program arguments. Some of the parameters are mandatory, and you must add a -src parameter for each plugin that you have authored.

Shell
-noincremental -src target/generated-sources/gen -src {path-to-your-extension}/src/main/java org.eclipse.che.ide.IDE

In the Classpath tab, go to User Entries > Add External Jars. Add:

gwt-codeserver.jar (in the directory where you unzipped GWT zip),
gwt-dev.jar, (also in the same directory)
The JAR file for any extensions or plugins that you have built. You can find this JAR file in two locations. First, you can find it in the /target folder where you compiled the plugin. Second, you can also find it in your maven's local repository, typically in its .m2 folder.

In the Source tab, remove any non-existent source folders. This is uncommon, but if you see something like src/text/java then these folders should be removed.

LAUNCH SUPER DEV MODE
Run super dev mode in Eclipse by Run > Run Configurations. Select the run configuration that you just created and select Run. The first boot can take a few minutes as GWT is recompiling the application with development mode hooks.

In the Eclipse console output, you will see a special URL - http://localhost:9876/. Launch a browser with this page. There will be two bookmarklets to drag onto your browsers bookmark bar - Dev Mode On and Dev Mode Off.


LAUNCH CHE WITH SUPER DEV MODE
Run Che normally. You can use the CLI, the Che launcher, or Eclipse. Within your browser create a workspace and then identify the workspace name. Open the workspace with the workspace name or ID that you captured, so this would be http://<che-url>/che/<ws-name>`.

Click the Dev Mode On bookmark on your booksmark bar. A message will appear asking you to recompile the application. Select the _app and compile it.


The compilation will likely take 5 to 10 Minutes:


Che is now running in Super Dev Mode. You can now make incremental Java source file changes within your IDE and then have the browser trigger an incremental rebuild and reload.

DEBUGGING GWT APPS IN THE CHROME BROWSER
Google Chrome has an ability where you can set breakpoints for your Java GWT apps from within the Chrome browser itself, even though Chrome has loaded your GWT app as JavaScript!

For this to work, you will need to enable source maps in the Chrome developer console. Open the developer console and navigate to the Sources tab.


You will see the Java classes that make up your IDE plugin. You can open individual classes to set breakpoints. To set a breakpoint, right click on the line of code.


The chrome debugger panel.
The app will pause in a chrome debugger on any breakpoint. You will see traces with exceptions if any. You can also step over, into and out of function calls. If you modify any of the Java source code in Eclipse, click on the Dev Mode On bookmark to recompile the application.

GWT Super Dev Mode for IntelliJ
The steps to configure Super Dev Mode for IntelliJ are largely similar to what you do for Eclipse.

DOWNLOAD GWT SDK
Download the GWT SDK 2.7.0 zip from Google's site. You will need to explode it and save in a directory on your compuer.

CONFIGURE INTELLIJ FOR GWT
JetBrains has a helpful page. There is just a single step.

MODIFY THE CHE ASSEMBLY
There are a few additional modifications to /che/assembly/assembly-ide-war/pom.xml. First, add a gwt-dev dependency and delete all 'provided' scopes.

/che/assembly/assembly-ide-war/pom.xml
<dependency>
    <groupId>com.google.gwt</groupId>
    <artifactId>gwt-dev</artifactId>
    <version>${com.google.gwt.version}</version>
</dependency>

<!-- delete me -->
<scope>provided</scope>
SETUP RUN CONFIGURATION
In Run > Edit Configurations > GWT Configuration, add a new configuration. You must add Dev Mode parameters to include the items listed in the graphic below.


RUN SUPER DEV MODE
Follow the remaining steps for running a configuration to launch Super Dev Mode, running Che in Super Dev Mode, and then debugging your application within Chrome.

Setup the Che IDE
 Building Che Extensions in Che Coming Soon

This is currently disabled in the Che beta. It will be added shortly. To build and run Che within Che, we start getting into some Docker inception, so there is some additional engineering we must complete to enable this.

You can create, build and run client-side Che extensions using the Che IDE.

Start Che.
Select File > New > Project.
Choose Empty Extension Project from the list of samples.
Enter a name for the project and click Create.
Run the extension to compile it and package into the existing assembly.
Che will launch another Che instance with your assembly.
In this mode, you can make updates to your extension source code without restarting the Che server. After you have made changes, press Update Extension. Your extensions will be recompiled and relaunched within the existing runner.



\\\\\\\\\\\\\\\\\Building Extensions
Building Extensions
This section describes, how to create, build and run a new extension to Che. It is focused on the infrastructural part only. To set-up a workspace, you should first refer to the Contributor Setup: Che Workspace

Build and Run Che
We document how to build and run Che from source in the GitHub repository wiki. You should get familiar with this development workflow and be able to compile and run Che before you start to build an extension.

In order to build Che, you need to properly set the dependencies, they are listed in the GitHub repository wiki.
Similarly, to build the Dashboard submodule, you'll find the dependencies and instructions in the following wiki readme.md of the GitHub repository.

To simplify this we build a Docker image with all the dependencies needed to build Che and all its submodules. Please follow theses instructions build Che using the Docker image.

If you want to work with an IDE, please follow this guideline: IDE Setup.

Sample Extensions
There are a set of sample extensions that are included in the Che source code. They are in the /samples directory. The examples below reference once of those samples, named sample-plugin-embedjs.

The Che sample plugins are not packaged with Che. You need to add each one to Che to test its capabilities. Most of the documentation provides instructions on how to create, build and link extensions manually.

Usually, most developers will copy an existing extension into a new directory and then build that. The linking process is one-time and can be cumbersome the first time that you do it. Che provides a utility in the source code (in a built assembly) called bin/che-install-plugin that automates the linking of your extensions into Che and the rebuilding of an assembly. While this utility is helpful, it's best if you go through the linking exercise once manually to understand the various relationships of what is linked where and why.

Extension Structure
The typical structure of a Che extension is composed of the following:

File	Details
/extension/pom.xml
/extension/src/
/extension/target/

Your extension source and build files. The pom.xml is a build file that compiles your extension and creates a JAR packaging of it. Your JAR is placed in the /target directory and installed into your local maven repository.

Depending on the complexity of your extension, you might build the structure of your plugin with multiple modules. Each module is independently buildable, and they each would have their own pom.xml, src, and target entries.

File	Details
/extension/extension-ide

Your extension module for the IDE client.

/extension/extension-server

Your extension module for the server part.

/extension/extension-shared

Your extension module for the shared code between the server and the client.

Each module has a directory structure that is based upon maven and will include source code and a target where artifacts are placed.

Shell
pom.xml
src/main/java/{package-name}/{extensionName}.java
Depending on the extension, you may also need to include:

Text
# Required for client-side extensions
src/main/resources/{package-name}/{extensionName}.gwt.xml

# Optional, required if you use GIN injection (in client-side extensions)
# GIN injection causes configuration & invocation during IDE activation
src/main/java/{package-name}/{extensionName}GinModule.java

# Optional, required if you use Guice injection (in server-side extensions)
# Guice injection causes configuration & invocation during Che server activation
src/main/java/{package-name}/{extensionName}GuiceModule.java

# Optional, required if you want to include static JavaScript or CSS files (in client-side extensions)
src/main/resources/{full-qualified-extension-name}/your-javascript.js
Generally you can give Gin and Guice modules any file name, but for the sake of simplicity we suggest sticking to the naming convention above.

See the following example for an advanced sample extension.

Compiling Extensions
POM.XML
Each extension has a root pom.xml file. When configuring an extension pom.xml file, you must define an <artifactId> tag which will be the unique name identifier given to this extension. This identifier tag will be referenced by the Che assembly to declare that your extension is part of Che. You can override the groupId and version parameters from the parent, or if not specified, it will inherit the values set by the <parent> tag reference.

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>che-parent</artifactId>
        <groupId>org.eclipse.che</groupId>
        <version>!!! REPLACE_WITH_CHE_VERSION !!!</version>
    </parent>
    <artifactId>che-examples-service</artifactId>
    <packaging>jar</packaging>
    <name>Che :: Examples :: Service</name>
    <dependencies>
        <dependency>
            <groupId>com.google.inject</groupId>
            <artifactId>guice</artifactId>
        </dependency>
        <dependency>
            <groupId>javax.ws.rs</groupId>
            <artifactId>javax.ws.rs-api</artifactId>
        </dependency>
        <dependency>
            <groupId>org.eclipse.che.core</groupId>
            <artifactId>che-core-commons-inject</artifactId>
        </dependency>
        <dependency>
            <groupId>com.google.gwt</groupId>
            <artifactId>gwt-user</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    <repositories>
        <repository>
            <id>codenvy-public-repo</id>
            <name>codenvy public</name>
            <url>https://maven.codenvycorp.com/content/groups/public/</url>
        </repository>
        <repository>
            <id>codenvy-public-snapshots-repo</id>
            <name>codenvy public snapshots</name>
            <url>https://maven.codenvycorp.com/content/repositories/codenvy-public-snapshots/</url>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository>
            <id>codenvy-public-repo</id>
            <name>codenvy public</name>
            <url>https://maven.codenvycorp.com/content/groups/public/</url>
        </pluginRepository>
        <pluginRepository>
            <id>codenvy-public-snapshots-repo</id>
            <name>codenvy public snapshots</name>
            <url>https://maven.codenvycorp.com/content/repositories/codenvy-public-snapshots/</url>
        </pluginRepository>
    </pluginRepositories>
    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
            </resource>
        </resources>
    </build>
</project>
Extensions can choose to reference the Che maven dependency management pom.xml which enforces coding standards incorporated throughout Che. It will also set dependencies version automatically. The <repositories> tag provides a reference to Che's maven repository hosted by Codenvy.

Please notice the <version> tag. Make sure you alter the version reference so it points to the correct version of Che that you installed (or merely the Git tag/branch you checked out). You can find out the correct Che version by looking at the che parent pom /che/pom.xml.

We do not require you to use this parent configuration file. Therefore you can bypass the default Che parent configuration and use a custom maven configuration according to your needs.

LICENSING
Referencing the Che parent pom.xml enforces the Eclipse Che license header to be in place for all source files. You can execute mvn license:format to add license headers to your files. Or, to skip the license check add:

pom.xml
<plugin>
  <groupId>com.mycila</groupId>
  <artifactId>license-maven-plugin</artifactId>
  <configuration>
    <skip>true</skip>
  </configuration>
</plugin>
If you modify the pom.xml it needs to be sorted. Run mvn sortpom:sort to sort the pom.xml.

BUILD YOUR EXTENSION
In your extension directory, run mvn clean install. This will build JAR files that bundle your extension.

Text
/target
  {your-extension-name}-{version}-sources.jar
  {your-extension-name}-{version}.jar
Linking Extensions
After you compile your extension, they will be packaged as JAR files. Those JAR files will need to be included into Che and then you can create a custom assembly of Che that includes the JAR files of your extensions.

CHE FILES FOR LINKING
File	Details
/che/assembly/pom.xml

Both server-side and client-side extensions. Due to a temporary limitation in version management, your dependency must also be added to the root Che build artifact.

/che/assembly/assembly-ide-war/pom.xml

Client-side (IDE) extensions. Build file for main Che assembly.client side components, extension dependency should be added to this pom.xml.

/che/assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml

Client-side (IDE) extensions. Client-side extensions are authored in GWT. Add your extension GWT module as an inheritance to this IDE GWT module.

/che/assembly/assembly-wsagent-war/pom.xml

Server-side workspace extensions. Build file that generates the Che web application agent that is deployed inside of a running workspace. You can add your extension to be included with this agent by adding it as a dependency in this file. Update this if your extension brings a new server-side service or component, or extends an existing API deployed with a workspace agent.

/che/assembly/assembly-wsmaster-war/pom.xml

Server-side Che server extensions. Add your extension as a dependency here if you want your server-side APIs to be accessible as part of the Che server. We call the workspace master (Che server) the location where master functions are provide like add / remove workspace. But if you just want server-side functionality that is available to the IDE, it must go into the workspace, which we call a workspace agent.

che/assembly/assembly-wsagent-server/pom.xml

Optional This assembly constructs all of the pieces to create a Che agent server that will be packaged and deployed into any running workspace that has the dev-agent deployed into it. This Che agent server runs a Tomcat server that deploys any of your server-side workspace extensions along with other APIs required by Che to manage the workspace.

YOUR EXTENSION IDENTIFIER
Every extension has a unique maven identifier. You will need to reference this identifier as a dependency. You can define your own identifiers for extensions or pull the identifier out of the pom.xml of the extension you are working with. For example, in the samples that are provided with che the samples/sample-plugin-embedjs/ has a single module for the IDE, and the identifier for the IDE extension is located in sample/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/pom.xml.

/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/pom.xml
<parent>
  <artifactId>che-sample-plugin-embedjs-parent</artifactId>
  <groupId>org.eclipse.che.sample</groupId>
  <version>5.0.0-M6-SNAPSHOT</version>
</parent>
<artifactId>che-sample-plugin-embedjs-ide</artifactId>
And the identifier of this extension is the artifactId, groupId, and version tags combined together. Tags can inherit values from parents if they are not explicitly defined in the pom.xml. So this extension has the identifier of.

XML
<artifactId>che-sample-plugin-embedjs-ide</artifactId>
<groupId>org.eclipse.che.sample</groupId>
<version>5.0.0-M6-SNAPSHOT</version>
ADD EXTENSION TO ROOT CHE POM
In order to allow your extension to be visible from the root level of Che, add your extension as a dependency in the list of <dependencies> from the <dependencyManagement>block. There are a lot of them in the root pom.xml. To avoid transitive dependencies, we require every dependency to be explicitly listed and added. While this may seem like a pain in the arse, this will save you a lot of pain in the future from having circular references.

/pom.xml
<dependencyManagement>
  <dependencies>
    ...
    <dependency>
      <groupId>org.eclipse.che.sample</groupId>
      <artifactId>che-sample-plugin-embedjs-ide</artifactId>
      <version>${che.version}</version>
    </dependency>
    ...
  </dependencies>
</dependencyManagement>
You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.

Optional: Skip Enforcement
By default, Che has the Maven enforcer plug-in activated. When this plugin is activated, your dependency must be declared in the root pom.xml. You can skip enforcement, which will not require your extension to be in the root pom.xml. You skip enforcement by building -Denforcer.skip=true.

IDE EXTENSION: LINK TO ASSEMBLY
To include your jar files within the Che assemblies you have to introduce your extension as a dependency in /che/assembly/assembly-ide-war/pom.xml and also have it added as a dependency to the GWT application. First add the dependency:

/che/assembly/assembly-ide-war/pom.xml
<dependency>
  <groupId>org.eclipse.che.sample</groupId>
  <artifactId>che-sample-plugin-embedjs-ide</artifactId>
</dependency>
You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.

Second, link your GUI extension into the GWT app. You will add an <inherits> tag to the module definition. The name of the extension is derived from the direction + package structure that you have given your extension. For example:

/che/assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml
<inherits name='org.eclipse.che.plugin.embedjsexample.EmbedJSExample'/>
And this means that in our embed sample, there is a file with a *.gwt.xml extension in a folder structure identical to the name above.

Shell
# This name was derived from the package structure in your sample:
/che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/resources/org/eclipse/che/plugin/embedjsexample/EmbedJSExample.gwt.xml
Once you have added the IDE extension to both locations, you need to rebuild the IDE.

Shell
# Build a new IDE.war
# This IDE web app will be bundled into the assembly
cd che/assembly/assembly-ide-war
mvn clean install

# Create a new Che assembly that includes all new server- and client-side extensions
cd assembly/assembly-main
mvn clean install

# Start Che natively
cd che/assembly/assembly-main/target/eclipse-*/eclipse-*/bin
che run

# Or start Che using the CLI with your new assembly
# Replace <version> with the actual directory name
export CHE_LOCAL_BINARY=path_to_che_sources/assembly/assembly-main/target/eclipse-che-<version>/eclipse-che-<version>
che start
SERVER SIDE WORKSPACE EXTENSIONS: LINK TO ASSEMBLY
To include your jar files within the Che assemblies you have to introduce your extension as a dependency in /che/assembly/assembly-wsagent-war/pom.xml and then rebuild the agent server.

/che/assembly/assembly-wsagent-war/pom.xml
<dependency>
  <groupId>org.eclipse.che</groupId>
  <artifactId>che-examples-service</artifactId>
</dependency>
Once you have added the server-side extension as a dependency, you need to rebuild the agent that is deployed into the workspace.

Shell
# Create a new web-app that includes your server-side extension
cd che/assembly/assembly-wsagent-war
mvn clean install

# Creates a new agent that includes your server web app that will deploy into workspace
cd che/assembly/assembly-wsagent-server
mvn clean install

# Create a new Che assembly that includes all new server- and client-side extensions
cd assembly/assembly-main
mvn clean install

# Start Che natively
cd che/assembly/assembly-main/target/eclipse-*/eclipse-*/bin
che run

# Or start Che using the CLI with your new assembly
# Replace <version> with the actual directory name
export CHE_LOCAL_BINARY=/assembly/assembly-main/target/eclipse-che-<version>/eclipse-che-<version>
che start
SERVER SIDE CHE SERVER EXTENSIONS: LINK TO ASSEMBLY
To include your jar files within the Che assemblies you have to introduce your extension as a dependency in /che/assembly/assembly-wsmaster-war/pom.xml and then rebuild the Che server, which we call master.

XML
<dependency>
  <groupId>org.eclipse.che</groupId>
  <artifactId>che-examples-service</artifactId>
</dependency>
Once you have added the extension to the Che server, you need to rebuild the Che server.

Shell
# Create a new Che server web app that includes your Che server extension
cd che/assembly/assembly-wsmaster-war
mvn clean install

# Create a new Che assembly that includes all new server- and client-side extensions
cd assembly/assembly-main
mvn clean install

# Start Che natively
cd che/assembly/assembly-main/target/eclipse-*/eclipse-*/bin
che run

# Or start Che using the CLI with your new assembly
# Replace <version> with the actual directory name
export CHE_LOCAL_BINARY=/assembly/assembly-main/target/eclipse-che-<version>/eclipse-che-<version>
che start
Loading Sequence
There are three ways your extension code is invoked:

Compiled into the Che IDE application.
When the Che IDE application is activated your GIN modules are invoked.
When the Che server boots your Guice modules are invoked.
Text
CHE ASSEMBLY                              YOUR PLUGIN (title: YourExtension)
------------                              ----------------------------------
IDE.gwt.xml  ------>  references  ----->  YourExtension.gwt.xml
pom.xml  ---------->  builds  --------->  YourExtension.java
  |
  | builds
  |
  
  Che IDE  -------->  injects  -------->  YourGinModule.java      (optional)


CHE RUNTIME                              
-----------                              
@boot  ------------>  injects  -------->  YourGuiceModule.java    (optional)

The Che assembly is the root Che project that builds a number of assemblies from a set of system plug-ins together with your custom plug-in. The Che assembly has a master configuration file, /assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml which defines the modules to compile into the application.

To manually add your plug-in to the Che assembly, you update the IDE.gwt.xml file and the assembly pom.xml with information about your plug-in. When the Che assembly is built, it will download your extension as a dependency and compile it into the Che IDE application. The Che IDE application will use dependency injection to load any Gin modules. When you boot Che within tomcat or another application server, Che uses Guice to load any server-side modules for dependency injection.

Your extension may require access to types provides by Che or the Che API, i.e. if you are implemenenting a custom project type or wizard. Che objects can be injected with Gin and Guice which enables your extension to make use of them.

Improving Incremental Builds
There are a number of tweaks you can use to speed up the various stages of development. One possibility to speed up the initial build and packaging process is by disabling tests and skipping certain maven plugins.

Shell
# Add flags to skip the testing and code analysis phases of maven
mvn clean install -DskipTests -Dskip-validate-sources -Dgwt.compiler.localWorkers=4 -Dfindbugs.skip=true
XML
<!-- In /assembly/assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml -->

<!-- Tell Che to only build one type of browser JavaScript -->
<!-- Values can be 'safari' or 'firefox'.  Safari builds for chrome -->
<set-property name="user.agent" value="safari"/>

<!-- Reduces compiler permutations through some GWT magic. -->
<!-- See https://code.google.com/p/google-web-toolkit/wiki/SoftPermutations. -->
<collapse-all-properties />
If you intend to develop an IDE extension, incremental deployments of compiled changes can safe a lot of time. To enable incremental deployments use the so called "super development mode" provided by GWT. Setup instructions are provided on IDE Configuration.

\\\\\\\\\\\\\\\\\\\\Assemblies
Assemblies
An assembly is a packaging of Che libraries and plug-ins distributable as a desktop IDE or workspace server.

The assemblies generated by Che can be packaged and distributed as a new desktop IDE or workspace server. You can reuse this infrastructure to customize how assemblies and installers are generated. To do so, you must learn about the assembly module and dependency hierarchy.

Che Layout
A Che assembly has the following directory structure after it is installed.

Text
/bin             # Scripts to start, stop, and manage Che
/conf            # Configuration files
/lib             # Workspace agent, terminal and other resources a workspace may require
/plugins         # Staging for Che plugins that you author
/sdk             # Che packaging with SDK tools required to compile custom Che assemblies
/templates       # Project samples that appear in dashboard or IDE
/tomcat          # App server used as a runner for Che extensions, packaged with war and jar artifacts
Modules
The purpose of the http://github.com/eclipse/che/assembly module is to generate Che assemblies. It has five sub-modules.

Text
assembly-main            # Contains the base structure of a Che assembly
assembly-ide-war         # Generates the IDE web app (ide.war) loaded by Che server (client side)
assembly-wsagent-server  # Contains the base structure of a workspaces server 

assembly-wsagent-war     # Generates a machine web app (ide.war) used by workspace agent (server side APIs)
assembly-wsmaster-war    # Generates IDE web app with server side components
Run mvn clean install in the /assembly module to build the project and generate an assembly. The output of the mvn clean install command generates a new assembly and places the resulting files in the target folder. The assembly-ide-war module is the longest operation as it uses a GWT compilation operation to generate cross-browser JavaScript from numerous Java libraries. You can speed the assembly generation process by building assembly-main, which will download the latest IDE web application from Che's nexus repositories.

Text
/assembly-main
  /target
    /archive-tmp
    /eclipse-che-{version}               # Exploded tree of assembly
    /dependency                          # Copied into /lib folder of assembly
    /dependency-maven-plugin-markers
    /findbugs
    eclipse-che-{version}.tar.gz         # TAR file of assembly
    eclipse-che-{version}.zip            # ZIP file of assembly
Custom Assemblies
You can generate assemblies that include custom plug-ins and extensions. Custom assemblies can be distributed as ZIP or TGZ packages.

Shell
che-install-plugin [OPTIONS]         
     -a            --assembly          Creates new distributable Che assembly with your plugins 
     -s:deps,      --skip:deps         Skips automatic injection of POM dependencies of your plugins 
     -s:maven,     --skip:maven        Skips running maven to inject your plugins into local repository
     -s:update,    --skip:update       Skips updating this assembly; leaves packages in /temp build dir 
     -s:wsagent,   --skip:wsagent      Skips creating new ws agent 
     -s:wsmaster,  --skip:wsmaster     Skips creating new ws master, which contains IDE & ws manager
     -d,           --debug             Additional verbose logging for this program
     -h,           --help              This help message
This utility will create new web application packages with your custom plugins and optionally create new assemblies. Custom plug-ins are placed into the /plugins directory. Che packages extensions and plug-ins into Web application packages that are then deployed by Che. The location of your plug-ins determines how your plug-ins will be packaged and deployed.

Place plug-in JARs & ZIPs:

PlugIn_Location>>>>>>	What Is Built
/plugins/ide

IDE extension, compiled with GWT & packaged into new ws-master Web application.

/plugins/ws-master

Server-side extension & packaged into new ws-master Web application with IDE.

/plugins/ws-agent

Server-side extension that runs in workspace machine & packaged into new ws-agent Web application.

/

Packaged in both ws-master and ws-agent Web applications. (Not Recommended)

You extension is compiled into one of two Web applications:

Workspace Master.
Workspace Agent.
The workspace master is deployed into the core Che server. The workspace agent is deployed into the machine powering each workspace created by your users. Each workspace agent is unique to the workspace that created it. While you can deploy plug-ins into both locations, this is costly at compile and runtime.

The Che assembly is generated by Che utility in stages.

Text
1. Install your plug-ins to a local maven repository.

2. Create a staging module to build new Web applications
   `/sdk/assembly-ide-war/temp`     --> Where ws-master web app will be generated
   `/sdk/assembly-machine-war/temp` --> Where ws-agent web app will generated

3. Your plug-ins are added as dependencies to the maven pom.xml in each staging module. 

4. The new Web application packages are compiled and packaged in the staging directory.
    `mvn sortpom:sort`
    `mvn -Denforcer.skip=true clean package install -Dskip-validate-sources=true`

5. If your plug-ins are added into a workspace agent Web app, we then create a new ws-agent.zip.
   `/sdk/assembly-machine-server`          --> Packages ws agent Web app w/ Tomcat into ws-agent.zip.
   `mvn -Denforcer.skip=true clean package install` 

6. The new Web applications are copied into your core Che assembly, overwriting old version. 
   `/sdk/assembly-ide-war/temp/target/*.war`          --> /tomcat/webapps
   `/sdk/assembly-machine-server/target/*.zip`        --> /lib/ws-agent.zip
   Use `--skip:update` to avoid overwriting existing files.
   
7. If `--assembly`, then we create a new distributable package of Che.
   `/sdk/assembly-main`
   `mvn clean package`
Runtime Deployment
When Che is running, the embedded assets are deployed into different locations.

Text
BROWSER CLIENT                           CHE SERVER                                 WORKSPACE (DOCKER)

                                         launches ws-agent.zip in workspace ----->  /webapps/ide.war
                                         launches terminal in workspace     ----->  /webapps/terminal

JS / CSS / HTML -- download from ---->   /tomcat/webapps/ide.war
JS / CSS / HTML -- download from ---->   /tomcat/webapps/dashboard.war

JS / CSS / HTML -- download from ------------------------------------------------>  /webapps/ide.war
JS / CSS / HTML -- download from ------------------------------------------------>  /webapps/terminal
Your browser clients download JavaScript, HTML, and CSS resources from two different locations, both from the Che server and from a second Che server that is running within the workspace. Each workspace has its own ws-agent.zip that is injected into the workspace at runtime by Che. The ws-agent.zip contains a second application server that is booted when the workspace is activated.

While both the Che server and the ws-agent.zip each have an ide.war web application within them, they are not identical. There are numerous common libraries between the two, but the Che server hosts the primary IDE files that are shared by clients across all workspace development, and the ws-agent.zip deployment contains additional libraries for plug-ins that perform workspace modification (such as doing local JDT intellisense) along with additional Che classes that make it possible for the workspace agent to communicate over REST to the Che server.

The dashboard.war web application is an Angular JS application that provides the user dashboard that is booted when Che launches. It is used for managing workspaces, projects and user preferences.

Assembly Dependency Hierarchy
There are two servers that are deployed when Che is started:

The Che server, and:
The workspace agent, which is a server running in each workspace
The Che assembly, packaged as eclipse-che-{version}.zip contains both servers. The following charts layout which assembly modules build each of the assets.

Text
eclipse-che-{version}.zip                              ==> Generated by assembly-main
-> ide.war           ==> Placed in /tomcat/webapps     ==> Generated by assembly-ide-war
-> dashboard.war     ==> Placed in /tomcat/webapps     ==> Generated by che-dashboard repo
-> wsmaster.war           ==> Placed in /tomcat/webapps     ==> Generated by assembly-wsmaster-war
-> ws-agent.zip      ==> Placed in /lib                ==> Generated by assembly-machine-server
-> terminal          ==> Placed in /lib                ==> Generated by che-websocket-terminal repo
Text
ws-agent.zip                                           ==> Generated by assembly-wsagent-server
-> tomcat            ==> Placed in /                   ==> Downloaded from Che maven repo
-> ide.war           ==> Placed in /webapps            ==> Generated by assembly-wsagent-war
   -> che-core-*.jar                                   ==> Downloaded from Che maven repo
   -> che-plugins-*.jar                                ==> Downloaded from Che maven repo
   -> ws-agent specialized classes                     ==> Built by assembly-machine-war
Note that the ide.war web application generated for the workspace agent is not identical to the one generated for the Che application server, even though they have the same name. The workspace agent does not include many of the IDE libraries and adds in additional libraries for communicating to the Che server and running plug-ins within the workspace itself.

Che Repositories
The ide.war, ws-agent.zip, and other assembly files depend upon a wide range of libraries. Many of these resources and libraries are stored in other Che repositories.

These are the repositories that are stored at http://github.com/eclipse organization. Each repository is referenced by its first entry, ie: http://github.com/eclipse/che or http://github.com/eclipse/che-dependencies.

Shell
/che
/che/assembly                             # Generates binary assemblies of Che
/che/assembly/assembly-main               # Final packaging phase
/che/assembly/assembly-ide-war            # Creates the IDE.war from plug-ins & core
/che/assembly/assembly-wsmaster-war       
/che/assembly/assembly-wsagent-war        # Creates the agent WAR from plug-ins & core
/che/assembly/assembly-wsagent-server     # Creates the agent server that goes into ws
/che/core                                 # Platform APIs
/che/dashboard                            # AngularJS app for managing Che
/che/plugins                              # IDE & agent plug-ins
/che/wsmaster                             # Libraries used by the Che server
/che/wsagent                              # Libraries used by agents installed into workspaces

/che-lib                                  # Forked dependencies that require mods
/che-lib/swagger
/che-lib/terminal
/che-lib/websocket
/che-lib/pty
/che-lib/che-tomcat8-slf4j-logback

# All modules in /che and /che-lib depend upon /che-dependencies
/che-dependencies                         # Maven dependencies used by che
/che-dev                                  # Code style and license header

# /che-dependencies and /che-dev depends upon /che-parent
/che-parent                               # Maven plugins and profiles
You can build individual directories of Che, or any of its sub-modules. These modules will generate JARs, WARs or other artifacts. The same happens if you build plug-ins of your own. These are artifacts are installed into a local maven repository that /che/assembly uses when creating a combined assembly. It is also possible for you to copy the JAR files of plug-ins you author to an assembly staging area instead of installing them into a nexus repository.

If you build Che locally and if the necessary artifact dependencies are not locally installed into your maven repository, then Che will look in Codenvy's hosted nexus for packages. Codenvy maintains tagged versions of packages for the current SNAPSHOT and older versions.

You can see the reference to Codenvy's repositories in the che-dependencies repository at the end of the pom.xml.

XML
<repositories>
    <repository>
        <id>codenvy-public-repo</id>
        <name>codenvy public</name>
        <url>https://maven.codenvycorp.com/content/groups/public/</url>
    </repository>
    <repository>
        <id>codenvy-public-snapshots-repo</id>
        <name>codenvy public snapshots</name>
        <url>https://maven.codenvycorp.com/content/repositories/codenvy-public-snapshots/</url>
    </repository>
</repositories>
 Installers

Currently, the installers are generated from the http://github.com/codenvy/che-installer repository. This repository contains an Innosetup package for creating the Windows bundle and IZPack for creating a universal installer.

Codenvy Assemblies
It is possible to package Che plug-ins into assemblies for Codenvy On-Prem, which will make those services available in an elastically scalable, highly available cloud infrastructure.

\\\\\\\\\\\\\\\\\\\\\\\\\Dependency Injection
Dependency Injection
In this section, we briefly introduce the usage of dependency injection in Che, on the client and on the server side. If you are already familiar with Guice and Gin, you might want to skip this part.

Che uses dependency injection to wire the different components, in order to create objects as well as register and retrieve extensions. Therefore, dependency injection is technically the core mechanism of communicating with the framework and connecting custom extensions. This includes accessing framework services and objects (e.g. a file type or a file type registry) and providing custom objects to the framework (e.g. a custom wizard).

Che uses the existing dependency injection framework Guice on the server-side and the GWT version of Guice, Gin, on the client-side.

In general, there are two use cases for dependency injection: consuming objects and providing objects.


Please note that when extending Che, DI consumer and provider can be either in your custom extension or within the Che framework. As an example, if you want to provide a new wizard to be used in the IDE, you will create an object provider, which provides the wizard. Che implements an object consumer, which picks up the wizard class and uses it. In turn, if you want to access a service provided by Che, your extension will be the object consumer.

The main goal of using dependency injection is to decouple object provider and object consumer. Both parties just need to know about the object they consume/provide. The object is identified by its type (typically a Java interface) and optionally an additional key.
In the following, we first describe how to consume objects (in Guice and Gin) and subsequently, how to provide objects.

CONSUMING OBJECTS
Required objects can be injected in any class that is instantiated by the framework. If a custom component requires objects, e.g. a service, it can be injected as a parameter. This can be done in the constructor or in methods of a class. If the parameter is required for a class to operate, we recommend using the constructor for injection. To get parameters injected in a method or constructor, it is marked with the annotation @Inject (see code example below). By adding the annotation, all parameters of a constructor/method will be resolved by the framework and passed in through the initialization of the class.

The dependency injection framework needs to know how to identify the correct object to be used as a parameter. There are two essential ways of specifying the parameters as a consumer

First, if you just specify a parameter of a certain type (in the example SomeService), the framework will search for an object of that type. This will only work, if there is exactly one object of this type in the context, which is typically true for services.

Second, if there can be several objects of the required type and you want a specific object out of those, you can additionally specify a key using the annotation @Named.

In the following example, for the second parameter, the framework will look for an object which is of type MyClass has been explicitly registered with the key MyID. Please see the following section how to provide objects to be consumed that way.

Java
public class MyClass {

  private MyOtherClass myOtherClass;

  @Inject
  public MyClass(final SomeService someService,
                            final @Named("MyID") MyClass myClass) {
    someService.someMethod(myClass);
    this.other = new MyOtherClass(myClass);
  }

  // do somehting with myOtherClass;
}
Please note, that dependency injection is only available for objects which are instantiated by the dependency injection framework. In the example above, the class MyOtherClass is instantiated using plain Java, therefore it is not possible to use @Inject in its constructor.

PROVIDING OBJECTS
Implementing an object provider serves two purposes when writing an extension:

First, you can consume the objects that you provide from within other custom classes.

Second, the provided classes can be consumed by the Che framework.

As an example, if you provide a wizard class, it will be integrated by the Che IDE. Therefore, dependency injection is a core extension mechanism of Che.

To provide custom objects, you implement a module class. It is responsible to create the objects to be injected as well as register them using the type and optionally a key. Depending on the general structure of your extension, you could add as many modules as you like, however, most extensions use only one module for the client (Gin) and one for the server part (Guice).

The following code example shows a simple Guice module. All Guice modules inherit from AbstractModule and are marked with the annotation @DynaModule, which registers the module itself to be executed by Guice. The mandatory method #configure is responsible for the registration of objects. We will not go into detail about all the different options of Guice/Gin, but focus on relevant use cases in Che. In the following code example, we register a custom object (CustomObject), which implements an existing Che type (ExistingCheType). The Che type defines an extension point for Che, e.g. a wizard.

Java
public class CustomObject implements ExistingCheType {
  // ...
}
Now, we register our custom object using the type and therefore make it available for the Che framework. To register and to retrieve the object, the type ExistingCheType is used as an identifier. In the example, there can be an arbitrary number of objects implementing ExistingCheType, so Che will retrieve a set of objects. To register the object, we create a new Set Binder for the type ExistingCheType. Then, we add a binding and register the custom object. The CustomObject will be instantiated by the framework using dependency injection. Therefore, the @Inject annotation can be used in the constructor of CustomObject.

Java
import org.eclipse.che.inject.DynaModule;
import com.google.inject.AbstractModule;
import com.google.inject.multibindings.Multibinder;

@DynaModule
public class MyGuiceModule extends AbstractModule {

    @Override
    protected void configure() {
        Multibinder.newSetBinder(binder(), ExistingCheType.class)
                   .addBinding()
                   .to(CustomObject.class);
    }
}
Gin modules inherit from AbstractGinModule and use the @ExtensionGinModule annotation. Gin has a different binding mechanism than Guice, however, for the typical use case, the code would look the same:

Java
import org.eclipse.che.ide.api.extension.ExtensionGinModule;
import com.google.gwt.inject.client.AbstractGinModule;
import com.google.gwt.inject.client.multibindings.GinMultibinder;

@ExtensionGinModule
public class MyGinModule extends AbstractGinModule {

    @Override
    protected void configure() {
        GinMultibinder.newSetBinder(binder(), ExistingCheType.class)
                      .addBinding()
                      .to(CustomObject.class);
    }
}
As an alternative to the registration above, objects can also be registered using methods marked with the @Provides annotation. The following example provides a simple object, which only needs to be instantiated once (@Singleton). In this example, the registration additionally contains a key specified by the @Named annotation. Please note that in this case, the CustomObject is created manually, so no dependency injection can be used within it. The following method is placed in your custom Gin/Guice module.

Java
@Provides
@Singleton
@Named("MyID")
protected FileType provideMyClass() {
      return new MyClass();
}
The examples of dependency injection cover all basic use cases to understand the following extension tutorial. If you want to learn more about the different types of Guice bindings, please refer to this page.

EXTENSION CLASSES
Besides the extensibility using dependency injections, many custom extensions need to call some Che services or registries on start-up. Therefore, most extensions contain a central class called Extension. To register those classes, Che provides the custom annotation @Extension, which also allows to define a title for the extension. A common example for a class which gets instantiated by Che and which requires parameters is the Extension class.

Extension classes will automatically be picked-up by Che on start-up and all methods will be executed using dependency injection. In the following example, the extension class connects SomeParameter to SomeService.

Java
@Extension(title = "My Extension")
public class MyExtension {

  @Inject
  private void myInitialization(
          final SomeService someService,
          final SomeParameter someParameter) {
        someService.doSth(someParameter);
  }
}
Please note that there is typically only one extension class in every extension.


\\\\\\\\\\\\\\\\\\\\\Editors
Editors
This part of the tutorial describes how to extend the Eclipse Che code editor to support a new language. It starts with defining a custom file type and associating it with the specific editor to be opened. Subsequently, we describe how to adapt and enhance the syntax highlighting as well as the code completion of the code editor.

FILE TYPES
In this part of the tutorial, we describe, how new file types can be defined in Che and how those file types can be associated with a specific editor to be opened with. File types can be anything, from a source file to a configuration or properties file. By defining a new file type, it will be displayed in the project explorer using a specific icon. Further, it can be opened and modified with the associated editor. Please note, that Che already provides support for many common file types, so before defining a new one, you should check whether it is already supported.

Defining a new file type consists of three basic steps:

Define the file type itself, including specifying a name, a file extension and an icon
Register the new file type in the file type registry
Optional: Register the file type in the editor registry and thereby associate it with a specific editor to be opened with
A simplified version of a registration of a new file type with the extension .my covering exactly these three necessary steps in correct order looks like this:

Java
FileType myFileType = new FileType("My FileType", anIcon, "my");
fileTypeRegistry.registerFileType(myFileType);
editorRegistry.registerDefaultEditor(myFileType, defaultTextEditorProvider);
In the first line, the new FileType is defined, the parameters of its constructor define a name (visible in the UI), an icon, the mime type and a file extension. 
In line 2, the new file type is registered in Ches FileTypeRegistry. 
In line 3 the file type is added to Ches editor registry and thereby associated with Ches default editor. 
Please note that step three is optional, as Che will associate all file types with the default text editor by itself. However, this step is necessary, if you later want to implement a custom editor provider.

Following a modular design, and following the guideline for the structure of Che plugins, the creation of the file type and the registration should be kept in two separate components (Java Classes).
The following diagram shows all components of a typical file type registration. 
The three classes highlighted in dark grey are to be implemented or adapted for the extension.
The class MyGinModule is responsible for creating the new file type. The icon for the new file type will go to a GWT resource class (MyRessources). Finally, the class MyExtension creates a FileTypeRegistration in Che's FileTypeRegistry.


If you havent used Gin or dependency injection before, we recommend you have a look at our brief dependency injection introduction.

First, we define a new class GinModule for the instantiation of the custom FileType. It enables other classes to access the new file type using dependency injection. When adding more extensions later, the GinModule class can also create other components and mappings. So we will not call it FileTypeGinModule, but more generically MyGinModule. For now, the GinModule just provides the custom file type using the ID MyFileType. This makes the custom file type available for injection for other components using the annotation @Named(MyFileType).

The creation of the file type defines a name, a custom icon and the file extension. If Strings, such as the file extension, are used at other places later, they should be externalized to a common place, for simpler reading, we keep them inlined for now. If those Strings also need to be consumed by a server component later, it should go to a shared module, for now, it is kept in the IDE (client) module.

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/inject/MyGinModule.java
org.eclipse.che.plugin.myextension.ide.inject.MyGinModule
@ExtensionGinModule
public class MyGinModule extends AbstractGinModule {

  @Override
  protected void configure() {
    //Nothing to do here, yet
  }

  @Provides
  @Singleton
  @Named("MyFileType")
  protected FileType provideMyFile() {
     return new FileType(MyResources.INSTANCE.icon(), "my");
  }
}
The custom file type consumes an icon, which is retrieved from a GWT resource:

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/MyResources.java
org.eclipse.che.plugin.myextension.ide.MyResources
public interface MyResources extends ClientBundle {
   MyResources INSTANCE = GWT.create(MyResources.class);
  
   @Source("icons/my.svg")
   SVGResource icon();
}
The icon itself is a svg image located in the resources of the extension:
https://github.com/eclipse/che/tree/master/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/resources/org/eclipse/che/plugin/jsonexample

To register the custom file type at Ches Editor registry, we create another class called MyExtension. Again, we name this class more generically, as it will additionally contain other extensions to the IDE. The extension gets the new file type and the FileTypeRegistry injected and creates the file type registration.

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/MyFileTypeExtension.java
org.eclipse.che.plugin.myextension.ide.MyExtension
@Extension(title = "My FileType Extension")
public class MyFileTypeExtension {

  @Inject
  private void registerFileType(
          final FileTypeRegistry fileTypeRegistry,
          final @Named("MyFileType") FileType myFileType) {
    /...
    fileTypeRegistry.registerFileType(myFileType);
  }
}
After registering the file type, Che can map the extension to the definition of the file type. Therefore, Che will use the defined icon, if you create a file with the new extension my (as shown in the following screenshot). As we have not yet defined any editor type, Che will open the new file type in the default text editor and it will assume, that the content type is plain text.


As you can see in the screenshot above, Che will open any new file type in the default editor. This even works without defining any editor extension. You might want to contribute another editor type for the new file type later. This is done by adding an editor extension and associating the file type with an editor provider. We will cover this more in detail in the section Code Completion. As we do not have a custom editor provider, yet, the following example code associates the example file type with the default text editor. Please note, this step is redundant in this example, as Che will associate any unknown file type with the default editor anyways.

Since we might want to add more extensions to the editor, again, we use a more generic name for the extension class. As we extend the Che default editor, written in JavaScript and internally referred to a JSEditor, we follow the convention of other existing plugins and call the extension MyJsEditorExtension. The following extension class gets the EditorRegistry, the file type and the DefaultTextEditorProvider injected and creates the editor registration. As mentioned, this will have no visible effect in the example. However, if we would replace the Default Text Editor Provider with our own provider (CustomEditorProvider), we could extend or replace the editor used for our new file type.

Java
org.eclipse.che.plugin.myextension.ide.MyJsEditorExtension
@Extension(title = "My JS Editor Extension")
public class MyJsEditorExtension {

  @Inject
  public MyJsEditorExtension(final EditorRegistry editorRegistry,
                            final @Named("MyFileType") FileType myFile,
                            final CustomEditorProvider editorProvider) {
     editorRegistry.registerDefaultEditor(myFile, editorProvider);
  }

}
So far, we have defined a new file type, which can be opened with the default text editor. Currently, the text editor provides no syntax highlighting and code completion, as it knows nothing about the format or grammar of our new language. The syntax highlighting of the default editor is actually provided by the embedded orion editor (referred to as JSEditor). Please refer to the section syntax highlighting to learn how to extend it and add syntax highlighting for the new file type.

Further, the new file type can only be created using the generic New action and enter the extension manually. If you want to define a custom action, visible in the New menu, please refer to the section New File Actions.

JSON File Type (already supported by Che)
The continuous JSON example, which is used throughout this tutorial uses the file type ".json". As Che already registeres a JSON file type out of the box, that means, the necessary registrations, described above for the "my" file type example are already existing in the Che core framework. For reference, the corresponding registrations can be found in the following classes and can be used as another example.

File Type Definition
che/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/filetypes/FileTypeModule.java
core/ide/che-core-ide-app/src/main/java/org.eclipse.che.ide.filetypes.FileTypeModule (alongside with other file types)

@Provides
@Singleton
@Named("JsonFileType")
protected FileType provideJsonFile(Resources resources) {
   return new FileType(resources.jsonFile(), "json");
}
File Type Registration
che/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/core/StandardComponent.java
core/ide/che-core-ide-app/src/main/java/org.eclipse.che.ide.core.StandardComponentInitializer

fileTypeRegistry.registerFileType(jsonFile);
Resources
che/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/Resources.java
core/ide/che-core-ide-app/src/main/java/org.eclipse.che.ide.Resources

@Source("defaulticons/json.svg")
SVGResource jsonFile();
Based on these existing registrations, Che will show the JSON file type as shown in the following screenshot. As JSON is a known format to the embedded Orion editor, it will also already provide syntax highlighting.


CODE COMPLETION
This part of the tutorial describes how the code-completion of Ches default code editor can be extended through new suggestions. This also enables you to add code-completion for completely new languages. The following diagram shows all components of a typical file type registration. The classes highlighted in dark grey are to be implemented for the extension.


First, we need to register a custom editor provider, MyEditorProvider, which plugs in our custom code completion. If you did not register a custom editor provider before, Che will use the DefaultEditorProvider, which we now replace. This is done in a class JsEditorExtension which contains all potential extensions for the JSEditor (see also here).

An editor provider is responsible for configuring a specific editor type. Therefore, it provides an EditorConfiguration, which is responsible for editor features such as code completion, quick assist or code formatting. To provide custom code completion, the EditorConfiguration needs to create a custom CodeAssistProcessor.

In the following example, we will describe how to provide a custom code completion to the existing JSON example editor. For simplicity, the code completion will just return a static list of keywords, however, the example can be extended to provide more sophisticated completion processing.

As a first step, we register a custom JsonExampleEditorProvider:

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/JsonExampleEditorExtension.java
org.eclipse.che.plugin.jsonexample.ide.JsonExampleJsEditorExtension
@Extension(title = "JSON Example Editor")
public class JsonExampleJsEditorExtension {

@Inject
public JsonExampleJsEditorExtension(
final EditorRegistry editorRegistry,
final @Named("JsonFileType") FileType jsonFile,
final JsonExampleEditorProvider editorProvider) {
      editorRegistry.registerDefaultEditor(jsonFile, editorProvider);
   }
}
An Editor Provider needs to implement the interface EditorProvider. If you want to use the default editor configuration, you can inherit from AbstractTextEditorProvider, in this case, you just need to define an ID and a description. Additionally, you can optionally create a custom EditorPartPresenter by implementing the method getEditor. If you do not implement getEditor, the default editor will be created by AbstractTextEditorProvider.
In this tutorial, we create an extension for the existing DefaultTextEditor. Therefore, we first retrieve the existing editor from the DefaultEditorProvider and initialize it with our new custom editor configuration JsonExampleEditorConfiguration, which will add the custom auto-completion to the editor.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleEditorProvider.java
org.eclipse.che.plugin.jsonexample.ide.editor.JsonExampleEditorProvider
/**
 * The JSON Example specific {@link EditorProvider}.
 */
public class JsonExampleEditorProvider extends AbstractTextEditorProvider {

  private JsonExampleEditorConfigurationFactory editorConfigurationFactory;

  /**
  * Constructor.
  *
  * @param editorConfigurationFactory
  * the JSON Example Editor configuration factory
  */
  @Inject
  public JsonExampleEditorProvider(
         final JsonExampleEditorConfigurationFactory                    editorConfigurationFactory) {
        this.editorConfigurationFactory = editorConfigurationFactory;
  }

  @Override
  public String getId() {
     return "JsonExampleEditor";
  }

  @Override
  public String getDescription() {
      return "JSON Example Editor";
  }

  @Override
    public TextEditor getEditor() {
      TextEditor editor = super.getEditor();
      TextEditorConfiguration configuration = this.editorConfigurationFactory.create(editor);
      editor.initialize(configuration);
      return editor;
    }
}
As we just want to adapt the code completion, the example implementation of the editor configuration inherits from the existing DefaultTextEditorConfiguration. The method getContentAssistantProcessors is expected to return a mapping from content types to CodeAssistProcessors. In our case, if this mapping has exactly one entry registering the custom JsonExampleCodeAssistProcessor for the default content type.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleEditorConfiguration.java
org.eclipse.che.plugin.jsonexample.ide.editor.JsonExampleEditorConfiguration
public class JsonExampleEditorConfiguration extends AutoSaveTextEditorConfiguration {

  private Map<String, CodeAssistProcessor> codeAssist;

  public JsonExampleEditorConfiguration() {
    codeAssist = new LinkedHashMap<>();
    codeAssist.put(DEFAULT_CONTENT_TYPE, new JsonExampleCodeAssistProcessor());
  }

  @Override
  public Map<String, CodeAssistProcessor> getContentAssistantProcessors() {
    return codeAssist;
  }
}
A CodeAssistProcessor is responsible for calculating CompletionProposals. Therefore, it gets the editor, from which the completion was triggered, the current offset in this editor and a callback to be filled with completion proposals. In this example, we fill the list of proposals with three SimpleCompletionProposals (see below) containing static Strings (firstName, lastName and age). In a real completion use case, this simple and static example is to be replaced with a more advanced proposal calculation. If any exception occurs during the computation of the completion proposals, e.g. the server is not reachable, a corresponding message should be returned in #getErrorMessage.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleCodeAssistProcessor.java
public  class JsonExampleCodeAssistProcessor implements CodeAssistProcessor {

  @Override
  public void computeCompletionProposals(TextEditor editor, 
                                         int offset, 
                                         CodeAssistCallback callback) {

      List<CompletionProposal> proposals = new ArrayList<>();

      proposals.addAll(Arrays.asList(
         new SimpleCompletionProposal("firstName"),
         new SimpleCompletionProposal("lastName"),
         new SimpleCompletionProposal("age")
      ));

      callback.proposalComputed(proposals);
    }

    @Override
    public String getErrorMessage() {
       return null;
    } 
}
A CompletionProposal represents a completion option to be displayed when the users trigger auto-completion in the editor. Therefore, it shows all necessary information for the user and allows to select the right proposal to be applied. The following example shows a code proposal based on a static String, which is retrieved as a parameter in the constructor. This String is used as the displayed name and, along with the defined icon, will be shown to the user in the proposal list. Finally, once the user has selected a proposal which should be applied, the CompletionProposal returns the Completion (using a callback) in the #getCompletion method.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/JsonExampleCodeAssistProcessor.java
org.eclipse.che.plugin.jsonexample.ide.editor.SimpleCompletionProposal
public class SimpleCompletionProposal implements CompletionProposal {

  private String proposal;

  public SimpleCompletionProposal(String proposal) {
     this.proposal = proposal;
  }

  @Override
  public Widget getAdditionalProposalInfo() {
     return null;
  }

  @Override
  public String getDisplayString() {
     return proposal;
  }

  @Override
  public Icon getIcon() {
     return new Icon("", JsonExampleResources.INSTANCE.completion());
  }

  @Override
  public void getCompletion(CompletionCallback callback) {
     callback.onCompletion(new SimpleCompletion(proposal));
  }
}

A Completion is finally responsible for applying a proposal, once the user has selected one. Therefore, after accessing the Document it can apply any text change necessary. In the following example, we append the static String of the Completion at the current offset. The #getSelection method can optionally set a new selection in the editor after the proposal has been applied. This is done in absolute document coordinates. Returning null (as in the example) will not set any new selection.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/editor/SimpleCompletion.java
org.eclipse.che.plugin.jsonexample.ide.editor.SimpleCompletion
public class SimpleCompletion implements Completion {

  private final String proposal;

  public SimpleCompletion(String proposal) {
     this.proposal = proposal;
  }

  @Override
  public void apply(Document document) {
    document.replace(
        document.getCursorOffset(),
        proposal.length(),
        proposal
     );
  }

  @Override
  public LinearRange getSelection(Document document) {
     return null;
  }
}
In the example, we have shown, how to extend the code completion and used a static list of Strings. However, in a real world example, the calculation of the available proposals might, of course, be more complex. Furthermore, our example completion happens entirely on the client-site, without accessing the server or the workspace. If you need to access dependencies or other resources of a project, please see here to learn how to implement server site services to be used for more advanced code completion.

SYNTAX HIGHLIGHTING
Syntax highlighting allows you to mark characters and keywords in certain colors, based on a given grammar. To enable syntax highlighting in the browser IDE, Che embeds the existing Orion Editor. It already provides a wide range of supported grammars to be used. Please refer to the section contentType parameter within this document for a list of supported types.

If the orion editor already knows the language you want to support, you need to associate the file extension with the content type defined by orion. As an example, we could associate our a custom file type .my (see here for its definition) with the existing content type Json, which is already supported by the Orion editor. Therefore, we add the following line to org.eclipse.che.ide.jseditor.client.filetype.ExtensionFileTypeIdentifier:

che/core/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/filetype/ExtensionFileTypeIdentifier.java
org.eclipse.che.ide.jseditor.client.filetype.ExtensionFileTypeIdentifier
  //...
      this.mappings.put("my", makeList("application/json"));
  //...
By adding this mapping, the embedded Orion editor will now provide the JSON syntax highlighting for our custom file type.


To adapt or extend the syntax highlighting of the orion editor, please have a look at the Orion Documentation.

Add syntax highlighting for your own language
There are two options how you can add a syntax highlighting for your own language:

Add the highlighting of content type, supported by Orion, but not by IDE.
Add extension with mime type to File Extension Registry. For example:
/che/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/editor/filetype/ExtensionFileTypeIdentifier.java
//...
this.mappings.put("ino", makeList("text/x-c++src"));
...//
You can configure arbitrary new contentTypes and corresponding highlight configuration.
Usage example:
Java
@Inject
    protected void configureContentType(final OrionContentTypeRegistrant contentTypeRegistrant) {
        // register content type and configure orion
        final String contentTypeId = "text/x-testlang";

        OrionContentTypeOverlay contentType = OrionContentTypeOverlay.create();
        contentType.setId(contentTypeId);
        contentType.setName("Test Language");
        contentType.setExtension("testlang");
        contentType.setExtends("text/plain");

        // highlighting
        OrionHighlightingConfigurationOverlay config = OrionHighlightingConfigurationOverlay.create();
        config.setId("testlang.highlighting");
        config.setContentTypes(contentTypeId);
        config.setPatterns(
                "[\n" + 
                        "  {include: \"orion.lib#string_doubleQuote\"},\n" + 
                        "  {include: \"orion.lib#string_singleQuote\"},\n" + 
                        "  {include: \"orion.lib#brace_open\"},\n" + 
                        "  {include: \"orion.lib#brace_close\"},\n" + 
                        "  {include: \"orion.lib#bracket_open\"},\n" + 
                        "  {include: \"orion.lib#bracket_close\"},\n" + 
                        "  {include: \"orion.lib#parenthesis_open\"},\n" + 
                        "  {include: \"orion.lib#parenthesis_close\"},\n" + 
                        "  {include: \"orion.lib#number_decimal\"},\n" + 
                        "  {include: \"orion.lib#number_hex\"},\n" + 
                        "  {\n" + 
                        "    match: \"\\\\b(?:false|true)\\\\b\",\n" + 
                        "    name: \"keyword.json\"\n" + 
                        "  }\n" + 
                "]");

        contentTypeRegistrant.registerFileType(contentType, config);
    }
	
	
	\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Project Types
	Project Types
Project types allow you to provide custom project behavior for a certain language. Additionally, they allow you to specify specific project templates, which can be instantiated and already contain language specific content. Further, they allow the user to specify language specific properties for a project, e.g. compiler settings or dependencies. Finally, specific actions, e.g. in the context menu, can be associated with a project type.

In this part of the tutorial, we describe how to define a custom project type, how to provide a custom creation wizard, and how to add project-specific actions.

CUSTOM PROJECT TYPE
In this part of the tutorial, we describe how to define a new custom project type including a project initialization (e.g. to add default content). The following diagram shows all components of a project type registration. The classes highlighted in dark grey are to be implemented for the extension.


The custom ProjectTypeDef implementation defines the actual project type. Therefore, it defines an ID, a name and some configuration options. As the ID is referenced from other classes, it is retrieved from a shared constant class MyConstants.
A custom ProjectCreateHandler is responsible for creating a new project of the custom type. As an example, it can create some default files on project creation.
ProjectCreateHandler is a subtype of ProjectHandler, other sub types, e.g. PostImportProjectHandler and ProjectInitHandler provide further hooks to configure projects.

Both, the custom ProjectTypeDef as well as the custom ProjectCreateHandler are bound by a GuiceModule to make them available for the Che Framework. Please note that all these components are part of a server plugin. Necessary adaptations within the IDE, e.g. the extension of the New menu are done automatically by Che.

As an example, we will describe in the following how to add a simple project type for managing JSON files, although in a real use case JSON files are usually embedded into other projects (e.g. a JavaScript project). We will also add a default initialization to the project type, which already creates a new JSON file in any created project.
As a first step, we implement a custom subclass of ProjectTypeDef (see code example below). Its constructor calls the default super constructor to define the ID and the name for the custom project type.
Further, it specifies with the remaining three boolean parameters:

primary=true: That the project can be a top-level project, meaning that it can be created on the root level of a workspace
mixin=false: That the project cannot be embedded into other projects (as sub-projects)
After specifying the project, we add a constant and a variable definition to the project type. Constants can not be changed, once they are defined and therefore contain static information about the project type. In our example, we add the information, that the projects language is json. The first parameter specifies a key, the second a description of the Constant, and the third the corresponding value.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/projecttype/JsonExampleProjectType.java
Server-side: org.eclipse.che.plugin.jsonexample.projecttype.JsonExampleProjectType 
public class JsonExampleProjectType extends ProjectTypeDef {

  @Inject
  public JsonExampleProjectType() {
    super(JSON_EXAMPLE_PROJECT_TYPE_ID, "JSON Example", true, false);
    addConstantDefinition(LANGUAGE, LANGUAGE, JSON_EXAMPLE_PROJECT_TYPE_ID);
    addVariableDefinition("json-schema-ref", "Referenced base schema", /*required*/ true);
  }
}
Variables can be changed, e.g. to store values that the user enters on project creation. In the example, we define a custom variable to store a reference to a JSON schema. We will allow the user to set this variable in a custom project wizard in the corresponding part of this tutorial. You can define your own variables to store project specific properties. All String constants of the following code example are defined in a shared constant class, which is listed below.

che/samples/sample-plugin-json/che-sample-plugin-json-shared/src/main/java/org/eclipse/che/plugin/jsonexample/shared/Constants.java
org.eclipse.che.plugin.jsonexample.shared.Constants 
public final class Constants {

  /**
  * Language attribute name.
  */
  public static final String LANGUAGE             = "language";

  /**
  * Language attribute value.
  */
  public static final String JSON_EXAMPLE_LANG    = "json";

  /**
  * JSON Example Project Type ID.
  */
  public static final String JSON_EXAMPLE_PROJECT_TYPE_ID = "json-example";

  /**
  * JSON Example Category.
  */
  public static final String JSON_EXAMPLE_CATEGORY    = "JSON Example";

  /**
  * JSON Schema reference attribute name.
  */
  public static final String JSON_EXAMPLE_SCHEMA_REF_ATTRIBUTE = "json-schem-ref";

  private Constants() {

  }
}
To make our new project type available in Che, we need to register it using Guice. The following example code registers the JsonExampleProjectType from above as a ProjectTypeDef. Che will automatically pick up all bound ProjectTypeDefs. Please see our [Dependency Injection Basics] (doc:dependency-injection-basics) section for a general introduction of this mechanism.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/inject/JsonExampleGuiceModule.java
org.eclipse.che.plugin.jsonexample.inject.JsonExampleGuiceModule 
@DynaModule
public class JsonExampleGuiceModule extends AbstractModule {

  @Override
  protected void configure() {
    Multibinder<ProjectTypeDef> projectTypeDefMultibinder = newSetBinder(binder(),
    ProjectTypeDef.class);
    projectTypeDefMultibinder.addBinding().to(JsonExampleProjectType.class);
  }
}
By defining the new project type, Che will add a new entry in the New menu of the IDE and allow us to create a new and empty project:


Typical project types often need to be initialized with some default content, e.g. some files. This can be done by implementing a CreateProjectHandler (subtype of ProjectHandler). In the method #onProjectCreate, you can access the base folder, as well as the attributes and options of the project.

In the following example, we will create the following files: a "person.json" file with some default content that will be stored in a folder named "myJsonFiles" as well as a "package.json" file, which well need later on. The method #getProjectType needs to provide the project type ID to allow Che to map the ProjectHandler to the correct type.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/inject/JsonExampleGuiceModule.java
org.eclipse.che.plugin.jsonexample.generator.JsonExampleProjectGenerator 
public class JsonExampleCreateProjectHandler implements CreateProjectHandler {

  private static final String FILE_NAME = "package.json";

  @Override
  public void onCreateProject(FolderEntry baseFolder, 
                              Map<String, AttributeValue> attributes,
                              Map<String, String> options) throws /.../ 
  {
    InputStream packageJson = null;
    InputStream personJson = null;
    try {
      FolderEntry myJsonFiles = baseFolder.createFolder("myJsonFiles");
      packageJson = getClass().getClassLoader()
                .getResourceAsStream("files/default_package");
      personJson = getClass().getClassLoader()
                .getResourceAsStream("files/default_person");
      baseFolder.createFile(FILE_NAME, packageJson);
      myJsonFiles.createFile("person.json", personJson);
    } finally {
      Closeables.closeQuietly(packageJson);
      Closeables.closeQuietly(personJson);
    }
  }

  @Override
  public String getProjectType() {
    return Constants.JSON_EXAMPLE_PROJECT_TYPE_ID;
  }
}
Finally, the ProjectHandler needs to be bound using Guice just as the project type was bound before:

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/inject/JsonExampleGuiceModule.java
org.eclipse.che.plugin.jsonexample.inject.JsonExampleGuiceModule 

/...
Multibinder<ProjectHandler> projectHandlerMultibinder = newSetBinder(binder(), 
     ProjectHandler.class);
projectHandlerMultibinder.addBinding().to(JsonExampleCreateProjectHandler.class);
/...
Once the ProjectHandler has been added and executed, the example project will already contain the files in the IDE:


PROJECT CREATION WIZARD
Project creation wizards are executed once the user creates a new project. They allow you to enter general properties (such as a name and a description), but also project-specific properties (e.g. a compiler option, a project dependency, etc.). Without providing a specific project creation wizard, Che already allows you to enter the general properties available for all projects as shown in the following screenshot for the JSON example project type we have defined in the previous section of the tutorial:


In this section, we will describe how to extend the default project creation wizard with a new page allowing it to enter an additional property. As part of the JSON example, we will allow the user to enter the URL of a JSON Schema. We will later use the schema to validate JSON files on the server.
Therefore, we will add a new page to the JSON project creation wizard allowing to enter the schema url property:


This page serves as a simple example, it can be adapted for any other project specific property.

The following diagram shows all components for the extension of the project wizard. The classes highlighted in dark grey are to be implemented for the project wizards extension.


Before we look at the detailed implementations, we will first give an overview of all participating components.
As a first step, we need to implement a ProjectWizardRegistrar. It holds a set of AbstractWizardPages. These pages are added to the default wizard and displayed during project creation. Our implementation of a ProjectWizardRegistrar is in JsonExampleProjectWizardRegistrar and contributes one wizard page (see its method #getWizardPages) which will contain exactly one field for entering a JSON schema URL.

The page itself is implemented in SchemaUrlWizardPage. To actually display a UI, it configures a GWT view defined in SchemaUrlPageViewImpl and its corresponding SchemaUrlPageViewImpl.ui.xml. Furthermore, the wizard page will create and configure a handler for URL changes called SchemaUrlChangedDelegate.

Now all required classes are set up and the actual runtime behavior can be performed. Whenever the user performs a change in the textbox for the schema URL, GWT will trigger the method #onSchemaUrlChanged in SchemaUrlPageViewImpl since it is annotated as a handler for changes on this textbox. The method will then notify the SchemaUrlChangedDelegate. The SchemaUrlChangedDelegate will in turn write the changed URL into a ProjectConfigDto owned by the SchemaUrlWizardPage.

Finally, to wire everything up with Gin, all we need to do is to define a module to register our class JsonExampleProjectWizardRegistrar as an implementation of ProjectWizardRegistrar:

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/inject/JsonExampleModule.java
org.eclipse.che.plugin.jsonexample.ide.inject.JsonExampleModule
@ExtensionGinModule
public class JsonExampleModule extends AbstractGinModule {

  @Override
  protected void configure() {
      GinMultibinder
              .newSetBinder(binder(), ProjectWizardRegistrar.class)
              .addBinding()
              .to(JsonExampleProjectWizardRegistrar.class);
       }
      //... 
}

Now let us look at the implementation of all required classes in more detail.
The JsonExampleProjectWizardRegistrar is responsible for setting up the SchemaUrlWizardPage as one of its wizard pages. To do this, it requests a provider for a SchemaUrlWizardPage injected in its constructor. The provider is just a wrapper around the actual wizard page which is required by the Che framework. In the method #getWizardPages we can then just return a list of providers for wizard pages containing only the injected provider.

In addition to setting up the wizard page we need to declare the project type and category for which the project wizard is responsible for.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/JsonExampleProjectWizardRegistrar.java
org.eclipse.che.plugin.jsonexample.ide.project.JsonExampleProjectWizardRegistrar 
public class JsonExampleProjectWizardRegistrar implements ProjectWizardRegistrar {
  private final List<Provider<? extends WizardPage<ProjectConfigDto>>> wizardPages;

  @Inject
  public JsonExampleProjectWizardRegistrar(
         Provider<SchemaUrlWizardPage> wizardPage) {
    wizardPages = new ArrayList<>();
    wizardPages.add(provider);
  }

  @NotNull
  public String getProjectTypeId() {
    return Constants.JSON_EXAMPLE_PROJECT_TYPE_ID;
  }

  @NotNull
  public String getCategory() {
    return JSON_EXAMPLE_CATEGORY;
  }

  @NotNull
  public List<Provider<? extends WizardPage<ProjectConfigDto>>> getWizardPages()  {
    return wizardPages;
  }
}
The SchemaUrlWizardPage class defines the actual wizard page for entering a schema URL. In the constructor it requires the injection of a view for displaying the UI of the page called SchemaUrlPageViewImpl. In the method #go, which is called when the page is about to be displayed, it will set this view as the only widget on the page and pass a new SchemaUrlChangedDelegate to the view. The view will later use this delegate to trigger changes on the page's ProjectConfigDto whenever something is entered into the schema URL text box on the view.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlWizardPage.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlWizardPage 
public class SchemaUrlWizardPage extends AbstractWizardPage<ProjectConfigDto> {

  private final SchemaUrlChangedDelegate view;

  @Inject
  public SchemaUrlWizardPage(SchemaUrlPageViewImpl view) {
    this.view = view;
  }

  @Override
  public void go(AcceptsOneWidget container) {
    container.setWidget(view);
    view.setDelegate(new SchemaUrlChangedDelegate (this.dataObject));   
  }

}

The SchemaUrlChangedDelegate receives a ProjectConfigDto in its constructor which holds all the values that are defined during project creation including the schema URL. Whenever its #schemaUrlChanged method is fired, it will write the new value into the ProjectConfigDto.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlChangedDelegate.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlChangedDelegate   
public class SchemaUrlChangedDelegate {

  private ProjectConfigDto dataObject;

  public SchemaUrlChangedDelegate(ProjectConfigDto dataObject) {
    this.dataObject = dataObject;
  }

  public void schemaUrlChanged(String value) {
    dataObject.getAttributes().put("json-schema-ref", 
           Collections.singletonList(value));
  }
}

SchemaUrlPageView is just a marker interface required by the framework to declare that our SchemaUrlPageViewImpl is an implementation of a view with a SchemaUrlChangedDelegate.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlPageView.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlPageView   
public interface SchemaUrlPageView extends View<SchemaUrlChangedDelegate> {}
SchemaUrlPageViewImpl is the class which will actually create the UI with a TextBox for entering the schema URL. It is a GWT Composite with its contents defined in SchemaUrlPageViewImpl.ui.xml.
To receive all changes of the schema URL in the UI it declares a method #onSchemaUrlChanged with an annotation @UiHandler("schemaUrl"). This annotation defines that the method is to be called whenever the text in the schemaUrl text box as defined in SchemaUrlPageViewImpl.ui.xml is changed.
The method will just forward any call to the SchemaUrlChangedDelegate which was configured earlier by the SchemaUrlWizardPage.
In its constructor the view gets a JsonExamplePageViewUiBinder injected which is used to create and bind the UI defined in SchemaUrlPageViewImpl.ui.xml.
This requires you to define JsonExamplePageViewUiBinder as a marker interface extending UiBinder<DockLayoutPanel, SchemaUrlPageViewImpl>.

More about declarative UIs with GWT UI binder can be found on the GWT homepage.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlPageViewImpl.java
org.eclipse.che.plugin.jsonexample.ide.project.SchemaUrlPageViewImpl
class SchemaUrlPageViewImpl extends Composite implements SchemaUrlPageView {

  interface JsonExamplePageViewUiBinder extends UiBinder<DockLayoutPanel, SchemaUrlPageViewImpl> {
  }

  @UiField
  TextBox schemaUrl;

  private SchemaUrlChangedDelegate delegate;

  @Inject
  public SchemaUrlPageViewImpl(JsonExamplePageViewUiBinder uiBinder) {
    initWidget(uiBinder.createAndBindUi(this));
  }

  /** {@inheritDoc} */
  @Override
  public void setDelegate(SchemaUrlChangedDelegate delegate) {
    this.delegate = delegate;
  }

  @UiHandler("schemaUrl")
  void onSchemaUrlChanged(KeyUpEvent event) {
    delegate.schemaUrlChanged(schemaUrl.getValue());
  }
}
che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/project/SchemaUrlPageViewImpl.ui.xml
SchemaUrlPageViewImpl.ui.xml
<ui:UiBinder xmlns:ui='urn:ui:com.google.gwt.uibinder'
          xmlns:g='urn:import:com.google.gwt.user.client.ui'
          xmlns:ide='urn:import:org.eclipse.che.ide.ui'>
  <g:DockLayoutPanel unit="PX" >
      <g:north size="200">
          <g:FlowPanel ui:field="panel">
              <g:FlowPanel height="90px" >
                  <g:Label text="JSON Schema URL" />
                  <ide:TextBox ui:field="schemaUrl"
                              tabIndex="0"
                              debugId="file-createProject-schemaUrl"/>
                  <g:Label ui:field="labelUrlError" width="100%"    wordWrap="true"/>
              </g:FlowPanel>
          </g:FlowPanel>
      </g:north>
  </g:DockLayoutPanel>
</ui:UiBinder>
By adapting the SchemaUrlPageViewImpl.ui.xml you can customize the layout of the final wizard page. The example page will look like this:


PROJECT-SPECIFIC ACTIONS
Actions allow you to add custom behavior to the Che IDE. They can be placed in menus, toolbars or context menus. Some actions shall only be available on a specific project type. In the JSON example, we place two actions in the context menu of the defined project type. The screenshot shows a project-specific HelloWorldAction, as well as another project specific action implemented in the section Server/Workspace Access.


Please see the general section Actions how to define actions and the section Project/Perspective-specific Actions for a more detailled description on how the actions for the JSON project type are defined.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Actions
Actions
Action API

Actions allow you to add custom behavior to the Che IDE. They can be placed in menus, toolbars or context menus. An Action is a Java class, which implements the behavior to be executed. Additionally, it defines a text to be shown, a tooltip and an icon. In the following section, we describe the implementation of Actions more in detail.
To make Actions available in the Che IDE, they need to be registered and placed into ActionGroups. Thereby, you specify the location (e.g. a menu or toolbar), where the actions is shown. The registration of actions is described in the subsequent section Registering Actions.

AUTHORING ACTIONS
Simple Actions directly inherit from org.eclipse.che.ide.api.action.Action. In the constructor, we use the super class to configure our action with the following parameters:

text (String): The name of the action shown in the UI, in our case defined by concrete Actions (sub classes).
Optional: description (String): The description of the action shown in the UI, in our case defined by concrete Actions (sub classes).
In the example action below, the constructor also gets the NotificationManager injected, which is used to display a "Hello World" message.
A custom Action need to implement the #actionPerformed method, which is called when it is invoked. Actions can be associated with a variety of triggers within the system such as buttons, menu item selections, or user input (see following section).

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/action/HelloWorld.java
@Singleton
public class HelloWorldAction extends Action {

  private NotificationManager notificationManager;

  @Inject
  public HelloWorldAction(NotificationManager notificationManager) {
      super("Say Hello World", "Say Hello World Action");
      this.notificationManager = notificationManager;
  }

  @Override
  public void actionPerformed(ActionEvent e) {
      this.notificationManager.notify("Hello World", StatusNotification.Status.SUCCESS,                       StatusNotification.DisplayMode.FLOAT_MODE);
  }
}
Additionally, you can optionally define an icon for an Action. This is done by calling an alternative constructor including the following two parameters:

imageResource: An icon for the action shown in the UI, in our case defined by concrete Actions, we pass in null, as we alternatively use svgResource.
svgResource (SVGResource): An Icon for the the action shown in the UI, in our case defined by concrete Actions (sub classes).
The following code example defines another "Hello World" action including a corresponding icon:

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/action/HelloWorldActionWithIcon.java
@Singleton
public class HelloWorldActionWithIcon extends Action {

    private NotificationManager notificationManager;

    @Inject
    public HelloWorldActionWithIcon(
            NotificationManager notificationManager) {
        super("Say Hello World", "Say Hello World Action", null, SampleActionsResources.INSTANCE.icon());
        this.notificationManager = notificationManager;
    }

    /...
}
REGISTERING ACTIONS
Once we have implemented a custom action, we must register it. This is done in the custom Extension class , which is used for other extensions, too (see Dependency Injection Basics ).

As a first step, we register the HelloWorldAction itself at the ActionManager. Thereby, Che is aware of the action to be executed. Along with the registration, an action must be associated with a unique ID, which allows to reference the Action.

Second, to define a place in the IDE where the Action is visible to the user, we place the Action in an existing ActionGroup. Actions are organized into groups, which, in turn, can contain other groups. A group of actions can form a toolbar or a menu. Subgroups of the group can form submenus of the menu. You can directly place an Action into an existing group. Alternatively, you can create a custom group containing your action and add this group into Che.
In the following example, a custom group is created (SampleGroup), the HelloWorldAction is added to it and the Group is placed in the main menu of Che.
Additionally, the HelloWorldActionWithIcon is directly placed into the main menu.
Please see the following section on more details about existing action locations (i.e. groups) in Che and how to specify the order of actions within those groups.

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/SampleActionsExtensions.java
@Extension(title = "Sample Actions Extension", version = "1.0.0")
public class SampleActionsExtensions { 
    @Inject 
    public SampleActionsExtensions(HelloWorldAction helloWorldAction, ActionManager actionManager) { 
      
      actionManager.registerAction("helloWorldAction", helloWorldAction);
      actionManager.registerAction("helloWorldActionWithIcon", helloWorldActionWithIcon);
      /...
        
      DefaultActionGroup sampleGroup = new DefaultActionGroup("Sample actions", true, actionManager);

      sampleGroup.add(helloWorldAction);
      
      // add sample group after help menu entry
      DefaultActionGroup mainMenu = (DefaultActionGroup)actionManager.getAction(GROUP_MAIN_MENU);
        mainMenu.add(sampleGroup);
      
      // add the sample group to the beginning of the toolbar as well
      DefaultActionGroup toolbar = (DefaultActionGroup)actionManager.getAction(IdeActions.GROUP_MAIN_TOOLBAR);
      toolbar.add(helloWorldActionWithIcon);
      /...
    }
}
ACTION LOCATIONS
In this section, we describe more in detail, how actions can be placed at specific locations within Che and how the order within toolbars and menus can be specified. Both, the location and the order is specified along with the registration of an action.

Every action and action group in Che has a unique identifier. This allows to reference existing groups and actions when registering a new element and thereby specify its location. In the example registration in the previous section, we have used the ID of the Che main menu to place our custom action group and action in it. All existing identifiers for existing che action groups can be found in org.eclipse.che.ide.api.action.IdeActions.
Additionally, you can find a collection of examples within the example extension for actions (che/samples/sample-plugin-actions/che-sample-plugin-actions-ide).

In addition to placing actions in groups, you can define a relative order for actions and groups within their parent container. Therefore, a constraint needs to be specified when adding an element to a group. The constraint defines an anchor (ID of an existing element) and a relation to it (BEFORE or AFTER). Alternatively, you can use Constraints.FIRST and Constraints.LAST (default) to add an element at the beginning or at the end, respectively.

The following code example shows the registration of the group containing HelloWorldAction after the existing help menu, as well as the action itself at the beginning of the main toolbar.

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/SampleActionsExtensions.java
DefaultActionGroup sampleGroup = new DefaultActionGroup("Sample actions", true, actionManager);
sampleGroup.add(helloWorldAction);

// add sample group after help menu entry
DefaultActionGroup mainMenu = (DefaultActionGroup)actionManager.getAction(GROUP_MAIN_MENU);
mainMenu.add(sampleGroup, new Constraints(AFTER, GROUP_HELP));

// add the sample group to the beginning of the toolbar as well
DefaultActionGroup toolbar = (DefaultActionGroup)actionManager.getAction(IdeActions.GROUP_MAIN_TOOLBAR);
toolbar.add(helloWorldActionWithIcon, Constraints.FIRST);
VISIBILITY AND ENABLEMENT
By default, actions will always be visible to the user and enabled. However, certain actions shall only be visible or enabled based on the current state of Che. The implementation of an action is responsible for managing its visibility and enabled state.

Therefore, you need to implement the method Action.update() in a custom action. The method is periodically called by the IDE for updating the state. The object of type ActionEvent passed to this method carries the information about the current context for the action, e.g. the current perspective of the current selection. Additional information about the current state of the IDE can be retrieved form the service AppContext (see here for an example).

The ActionEvent allows access to the specific presentation which needs to be updated. As every action can be included in multiple groups and appear in multiple places within the IDE user interface, the visibility and enabled state can not centrally be controlled for an action. For every place where the action appears, a new Presentation is created on which the visibility and enabled state is set alternatively. Please note, that the ActionEvent instance is also passed to the actionPerformed() method, when the action is executed.

The following example shows the OnProjectHelloWorldAction, which is placed in the main menu of Che. It controls its visibility based on the state and is only visible if a project is selected in the navigator.

che/samples/sample-plugin-actions/che-sample-plugin-actions-ide/src/main/java/org/eclipse/che/plugin/sampleactions/ide/action/OnProjectHelloWorldAction.java
public class OnProjectHelloWorldAction extends Action {

    private AppContext appContext;
    private final NotificationManager notificationManager;

    /**
     * Constructor.
     * @param appContext
     *           the application context
     * @param notificationManager
     *           the notification manager
     */
    @Inject
    public OnProjectHelloWorldAction(
            final AppContext appContext,
            final NotificationManager notificationManager) {
        super("Project specific Hello World", "We have a project");
        this.appContext = appContext;
        this.notificationManager = notificationManager;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        this.notificationManager.notify(
                "Hello World in the context of a project",
                StatusNotification.Status.SUCCESS,
                StatusNotification.DisplayMode.FLOAT_MODE);
    }

    @Override
    public void update(ActionEvent e) {
        e.getPresentation().setEnabledAndVisible(appContext.getRootProject() != null);
    }
}
REUSABLE ACTIONS
For common operations such as creating files, Che provides reusable default actions. Custom implementations can inherit from those and thereby only need to specify their specifics, while reusing most of the default behavior. In this section, we provide an overview of the most common reusable actions in Che.

Create File Actions
Che provides a template implementation for actions to create new resources (i.e. files). When using the template, you only need to specify the name of the action as well as the file extension to be created (as shown in the following code example).

che/samples/sample-plugin-filetype/che-sample-plugin-filetype-ide/src/main/java/org/eclipse/che/plugin/filetype/ide/action/CreateMyFileAction.java
org.eclipse.che.plugin.myextension.ide.action.CreateMyFileAction 
public class CreateMyFileAction extends AbstractNewResourceAction {

  @Inject
  public CreateMyFileAction(MyResources myResources) {
    super("Create my File", "Create a new file ", myResources.icon());
  }

  @Override
  protected String getExtension() {
    return "my";
  }
}
PROJECT/PERSPECTIVE-SPECIFIC ACTIONS (JSON EXAMPLE)
In this part of the tutorial, as part of the JSON example we describe how to add project- and perspective-specific actions, meaning actions that are only available for a specific project type and within specific perspectives. As we want to define several actions of this type, we will create a template implementation and then inherit from it for the implementation of several actions.

These example actions will be placed in the context menu on the specific JSON project type defined before. The following diagram shows all components of a project type registration. The classes highlighted in dark grey are to be implemented for the extension.

First, our actions must determine whether they are available based on the current app context, in our case, based on the current project type. As we want to add several project specific actions, it makes sense to extract this behavior into an abstract class, in our case MyAbstractProjectSpecificAction. By inheriting from this abstract base class, we can now easily add project specific actions implementing the actual behavior to be executed.

As described before, to make an action available in Che, it needs to be registered at the ActionManager. This is done in an Extension.


In the following example, we first define the perspective- and project specific template action. Then, we define a simple action for the JSON example and register it in the context menu of the JSON project type. The action itself will trigger a simple notification once executed. However, the action could be adapted to execute any kind of behavior.

To make our abstract template action perspective-specific, we inherit from a reusable action implementation AbstractPerspectiveAction provided by Che. Compared to the basic Action its constructor allows the definition of a list of perspectives, in which the action is visible, referenced by ID. Null or empty list means the action is enabled everywhere. In the example, the project perspective, only.

The constructor also gets the AppContext injected, which is used in the following to control the project-specific visiblity of the action (see description below).

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/JsonExampleProjectAction.java
org.eclipse.che.plug.plugin.jsonexample.ide.action.JsonExampleProjectAction
public abstract class JsonExampleProjectAction extends AbstractPerspectiveAction {

  private AppContext appContext;

  public JsonExampleProjectAction(AppContext appContext,
                                  @NotNull String text,
                                  @NotNull String description,
                                  @Nullable SVGResource svgResource) {
    
    super(Collections.singletonList(ProjectPerspective.PROJECT_PERSPECTIVE_ID),
              text,
              description,
              null,
              svgResource);
    this.appContext = appContext;
  }

  @Override
  public void updateInPerspective(@NotNull ActionEvent event) {
    CurrentProject currentProject = appContext.getCurrentProject();
    event.getPresentation().setEnabledAndVisible(
                  isJsonExampleProjectType(currentProject));
  }

  private static boolean isJsonExampleProjectType(CurrentProject currentProject)  {
    if (currentProject == null) {
      return false;
    }
    return Constants.JSON_EXAMPLE_PROJECT_TYPE_ID.equals(
              currentProject.getProjectConfig().getType());
  }
  
}

The #updateInPerspective method is responsible for updating the enablement and the visibility of the action. In this example, we only want to show the action, if the current project is a JSON project. Therefore, we retrieve the current project from the AppContext, check whether there is a current project and if so, whether it has the expected project type.
Calling event.getPresentation().setEnabledAndVisible(true/false) will set the enablement and the visibility accordingly.

After defining a project specific action, we can now define an arbitrary number of concrete implementations to add custom behavior. The example below inherits from our JsonExampleProjectAction and uses the super constructor to configure the specificity of the action. Further, the constructor gets the NotificationManager injected, which is used in the implementation of the action below. The method #actionPerformed will be called once the user has clicked on an action.

In the example, we trigger a simple notification. However, this simple behavior could be replaced with any custom operation.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/HelloWorldAction.java
org.eclipse.che.plug.plugin.jsonexample.ide.action.HelloAction
@Singleton
public class HelloWorldAction extends JsonExampleProjectAction {

  private NotificationManager notificationManager;

  @Inject
  public HelloWorldAction(AppContext appContext,
                          NotificationManager notificationManager) {
        super(appContext,
              "Say Hello World",
              "Say Hello World Action",
              null);
        this.notificationManager = notificationManager;
  }


   @Override
  public void actionPerformed(ActionEvent e) {
        this.notificationManager.notify(
              "Hello World",
              StatusNotification.Status.SUCCESS,
              StatusNotification.DisplayMode.FLOAT_MODE
        );
  }
}
Once we have implemented a custom action, we must register it. This is done in the custom extension class JsonExampleExtension, which has been used for other extensions before (see Dependency Injection Basics ).

To keep all JSON example related actions together, we define a new ActionGroup called JSON Example. The second parameter defines that the group is displayed as a popup. After registering the new group at the ActionManager, we add our custom HelloWorldAction to it.

To define a place in the IDE where the Action is visible to the user, we further place the Action in an existing ActionGroup, in our case, the context menu of a project.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/JsonExampleExtension.java
org.eclipse.che.plugin.jsonexample.ide.JsonExampleExtension
@Extension(title = "JSON Example Extension", version = "0.0.1")
public class JsonExampleExtension {
  @Inject
  public JsonExampleExtension(
          ActionManager actionManager,
          HelloWorldAction helloWorldAction,
          JsonExampleResources jsonExampleResources,
          IconRegistry iconRegistry) {

    actionManager.registerAction("helloWorldAction", helloWorldAction);

    DefaultActionGroup jsonGroup = new DefaultActionGroup("JSON Example", 
         true, actionManager);
    actionManager.registerAction("jsonExample", jsonGroup);
    jsonGroup.add(helloWorldAction);

    DefaultActionGroup mainContextMenuGroup = (DefaultActionGroup) actionManager.getAction("resourceOperation");
    mainContextMenuGroup.add(jsonGroup);
      
  }
}

Finally, we can open the context menu on our custom project type and trigger the example action, the screenshot show the HelloWorldAction, as well as another project specific action defined in the section Server/Workspace Access.


FURTHER EXAMPLE ACTIONS
In this section, we provide a collection of existing example actions to demonstrate the variety of possible locations and behavior to be executed.

The following example creates a RedirectToDashboardWorkspacesAction which is the behavior that redirects the IDE back into the user dashboard application.

https://github.com/eclipse/che/blob/master/core/ide/che-core-ide-app/src/main/java/org/eclipse/che/ide/actions/RedirectToDashboardWorkspacesAction.java
package org.eclipse.che.ide.actions;

import com.google.gwt.user.client.Window;
import com.google.inject.Inject;

import org.eclipse.che.ide.CoreLocalizationConstant;
import org.eclipse.che.ide.api.action.Action;
import org.eclipse.che.ide.api.action.ActionEvent;

public class RedirectToDashboardWorkspacesAction extends Action {

    private static final String REDIRECT_URL = "/dashboard/#/workspaces";

    @Inject
    public RedirectToDashboardWorkspacesAction(CoreLocalizationConstant localization) {
        super(localization.actionRedirectToDashboardWorkspacesTitle(),
              localization.actionRedirectToDashboardWorkspacesDescription(), 
              null, 
              null);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Window.open(REDIRECT_URL, "_blank", "");
    }
}
The following example (from the JSON example) executes a server call to retrieve and display the number of lines of code from all JSON files within a project:

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/CountLinesAction.java
/**
 * Action for counting lines of code of all JSON files within the current project.
 * Line counting is implemented by consuming a RESTful service.
 */
@Singleton
public class CountLinesAction extends JsonExampleProjectAction {

    private final AppContext            appContext;
    private final StringMapUnmarshaller unmarshaller;
    private final AsyncRequestFactory   asyncRequestFactory;
    private final NotificationManager   notificationManager;

    /**
     * Constructor
     *
     * @param appContext
     *         the IDE application context
     * @param resources
     *         the JSON Example resources that contain the action icon
     * @param asyncRequestFactory
     *         asynchronous request factory for creating the server request
     * @param notificationManager
     *         the notification manager used to display the lines of code per file
     */
    @Inject
    public CountLinesAction(AppContext appContext,
                            JsonExampleResources resources,
                            AsyncRequestFactory asyncRequestFactory,
                            NotificationManager notificationManager) {

        super(appContext,
              "Count JSON Lines of Code",
              "Counts lines of code for all JSON Files in the project",
              resources.icon());

        this.appContext = appContext;
        this.asyncRequestFactory = asyncRequestFactory;
        this.notificationManager = notificationManager;
        this.unmarshaller = new StringMapUnmarshaller();
    }

    @Override
    public void actionPerformed(ActionEvent e) {

      String url = this.appContext.getDevMachine().getWsAgentBaseUrl() + "/json-example/" + this.appContext.getWorkspaceId() +
this.appContext.getCurrentProject().getRootProject().getPath();

      asyncRequestFactory.createGetRequest(url, false).send(
        new AsyncRequestCallback<Map<String, String>>(unmarshaller) {
          
        @Override
        protected void onSuccess(Map<String, String> linesPerFile) {
          for (Map.Entry<String, String> entry : linesPerFile.entrySet()) {
            String fileName = entry.getKey();
            String loc = entry.getValue();
            notificationManager.notify("File " + fileName + " has " + loc + " lines.", StatusNotification.Status.SUCCESS,                                   StatusNotification.DisplayMode.FLOAT_MODE);
          }
         }

         @Override
         protected void onFailure(Throwable exception) {
          notificationManager.notify(exception.getMessage(), StatusNotification.Status.FAIL, StatusNotification.DisplayMode.FLOAT_MODE);
         }
       });
    }
}
The following example shows how Che registers all of the actions for the Git menu.

https://github.com/eclipse/che/blob/master/plugins/plugin-git/che-plugin-git-ext-git/src/main/java/org/eclipse/che/ide/ext/git/client/GitExtension.java
DefaultActionGroup git = new DefaultActionGroup(GIT_GROUP_MAIN_MENU, true, actionManager);
actionManager.registerAction("git", git);
mainMenu.add(git, new Constraints(BEFORE, GROUP_HELP));

DefaultActionGroup commandGroup = new DefaultActionGroup(COMMAND_GROUP_MAIN_MENU, false, actionManager);
actionManager.registerAction("gitCommandGroup", commandGroup);
git.add(commandGroup);
git.addSeparator();



\\\\\\\\\\\\\\\\\\\\\\\\\\\Services
Services
Many simple extensions to Che are directly implemented in the IDE running in the browser. This has the advantage that the execution of simple actions do not require any server round-trips and are therefore typically very fast.
However, more complex operations, especially when accessing resources from a project or the workspace require you to run on the server or within the workspace. Examples for such operations are validating files, compiling code, providing auto-completion or creating workspaces. All those operations are implemented as REST services and can be consumed by the client IDE.

Services can either be deployed on the server or directly in a workspace. Server services provide generic features which are not depending on the Workspace or its content, e.g. user management. Workspace services can access the contents of a project (e.g. source files) and also trigger operations in the workspace (such as compilation).
In the following, we will describe how to create server and workspace services and how they are consumed from the client IDE. As the specification of workspace services is a special case of specifying server services, we will start with a simple server service, including an introduction of general basics about services.
Based on that, in the subsequent section Workspace Services, we will describe a more complex example, which accesses the files of a specific project.
Server and Workspace services need to be deployed differently, please refer to the section Create and build extensions to learn how.

SERVER SERVICES
The following diagram shows all components of server services. The classes highlighted in dark grey are to be implemented for the extension. The ServerService offers a REST service to be consumed.
The IDE plugin implements a client class (MyClient), which calls the REST service using Che helper classes. The result is made available by a Java API, which is to be defined based on the result type. By calling the client class, different components of the IDE, such as Actions or CodeCompletionProcessors, can consume the ServerService without having to deal with the REST API itself.


In the following, we will describe how to build a simple example server service that accepts a String {name} and responds with "Hello {name} !".
Further, we will demonstrate how this service can be consumed from within the client IDE.

Every REST service defines the path under which it is reachable. In the following code example, the path consists of two parts. The first one identifies the service itself and is specified with the @Path annotation of the class itself, in this case hello.
The second part of the path defines a parameter for the @GET method to be called and is specified with the @Path annotation at the method #sayHello itself, in this case name.
In combination, this example will register a service that will listen to localhost:8080/api/hello/{name}, where {name} is an arbitrary String to be passed by the client.
As specified using the @PathParam annotation, the {name} parameter will be passed as an input and then be used in the return statement.

che/samples/sample-serverservice/che-sample-plugin-serverservice-server/src/main/java/org/eclipse/che/plugin/serverservice/MyService.java
@Path("hello")
public class MyService {
    
  @GET
  @Path("{name}")
  public String sayHello(@PathParam("name") String name) {
    return "Hello " + name + " !";
  }
}
To make the server service consumable within the IDE, we implement a client encapsulating the REST call (see following code example).
Therefore, the client will offer a method #getHello, which can be called by any IDE component with a parameter name. To send an asynchronous REST request, the client uses two Che utilities, the AsyncRequestFactory and the LoaderFactory, which both get injected into the constructor.

The AsyncRequestFactory simplifies the creation of REST calls by providing a method #createGetRequest which will create a request using the provided parameter as a path. It will automatically prefix this path with the current server URL used by the IDE, so the parameter hello would be bound to http://serveradress/hello.

The request is sent by passing in an Unmarshaller. It is responsible for unmarshalling the response from the transport format (JSON) to a Java type, e.g. a String. Che already provides a collection of Unmarshallers, please see the section Calling Workspace APIs for details.

Finally, the send method returns a Promise, which can be consumed by callers on MyClient (see below) to retrieve the answer from the server.

che/samples/sample-serverservice/che-sample-plugin-serverservice-ide/src/main/java/org/eclipse/che/plugin/serverservice/ide/MyServiceClient.java
/che-ide-extension/src/main/java/examples/MyServiceClient.java
public class MyServiceClient {
    private final AsyncRequestFactory asyncRequestFactory;
    private final String helloPath;
    private final LoaderFactory loaderFactory;

    @Inject
    public MyServiceClient(AsyncRequestFactory asyncRequestFactory,
                           LoaderFactory loaderFactory) {
      this.asyncRequestFactory = asyncRequestFactory;
      this.loaderFactory = loaderFactory;
    }

    //Can be invoked by consumers
    public Promise<String> getHello(String name) {
      return asyncRequestFactory.createGetRequest(hello + "/" + name)
          .loader(loaderFactory.newLoader("Waiting for hello..."))
          .send(new StringUnmarshaller());
    }

}
Now, MyClient can be consumed from any other component in the IDE without having to deal with the REST call itself.
The following example action gets the MyServiceClient injected and calls the #getHello method to retrieve the Promise.
On the Promise you can pass in an operation to be executed if the server call has been successful using the #then method. As we have used a StringUnmarshaller before, the parameter will be the String created by the server service.
In the example, it is passed to the Che NotificationManager. Using the #catchError method on the Promise, you can define an operation to be executed on an error during the server call.

che/samples/sample-serverservice/che-sample-plugin-serverservice-ide/src/main/java/org/eclipse/che/plugin/serverservice/ide/action/MyAction.java

public class MyAction extends Action {

    private final NotificationManager notificationManager;
    private final MyServiceClient serviceClient;

    @Inject
    public MyAction(MyResources resources, NotificationManager
                    notificationManager, MyServiceClient serviceClient) {
      
      super("My Action", "My Action Description", null, 
            resources.MyProjectTypeIcon());
      this.notificationManager = notificationManager;
      this.serviceClient = serviceClient;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        // This calls the service in the workspace.
        // This method is in our MyServiceClient class
        // This is a Promise, so the .then() method is invoked after the response is made
        
      serviceClient.getHello("CheTheAllPowerful!").then(new Operation<String>()
      {
        
        @Override
        public void apply(String arg) throws OperationException {
          // This passes the response String to the notification manager.
          notificationManager.notify(arg, StatusNotification.Status.SUCCESS, StatusNotification.DisplayMode.FLOAT_MODE);
        }
        
       }).catchError(new Operation<PromiseError>() {
       
          @Override
          public void apply(PromiseError arg) throws OperationException {
            notificationManager.notify("Fail", StatusNotification.Status.FAIL, StatusNotification.DisplayMode.FLOAT_MODE);
          }
        
       });
    }

WORKSPACE SERVICES
Workspace services are special types of server services, they are deployed directly within the workspace agent. Therefore, they can access the content of a workspace, e.g. projects, source files, etc. Furthermore, they can trigger native operations in the running workspace.
Besides their different scope, workspace services are developed like standard server services using REST. Therefore, we recommend to first cover the previous section about server services. The main difference between workspace and server services is where they are actually deployed to. Please refer to the section Create and build extensions to learn how to deploy services correctly.

In the following, we describe an example workspace service from the JSON example, which accesses a selected project and counts the number of lines in all JSON files. This demonstrates how to access files and their content. In a custom use case, this could be adapted to do any kind of file operation, e.g. parsing contents for auto completion. After introducing the service, we demonstrate how it can be consumed by an action from within the IDE.

Like a server service, workspace services need to define the path in which they are reachable at. As they are running for a specific workspace, the path includes the variable {ws-id}, which identifies the workspace the service is running in (see @Path annotation in the following code example). The example service gets the Che ProjectManager injected in the constructor. It allows to access projects and their contents. Please note that this service is not available for server services.

The method #countLinesPerFile receives a projectPath as a parameter for which it should count the number of lines. It uses the ProjectManager to retrieve the project. Using the project, it then navigates over all JSON files in the project and accesses the contents of those files to count the lines. Finally, it returns the result as a map.

che/samples/sample-plugin-json/che-sample-plugin-json-server/src/main/java/org/eclipse/che/plugin/jsonexample/JsonLocService.java
org.eclipse.che.plugin.jsonexample.JsonLocService
@Path("json-example/{ws-id}")
public class JsonLocService {

  private ProjectManager projectManager;

  @Inject
  public JsonLocService(ProjectManager projectManager) {
    this.projectManager = projectManager;
  }

  
  @GET
  @Path("{projectPath}")
  public Map<String, String> countLinesPerFile(
         @PathParam("projectPath") String projectPath)
          throws ServerException, NotFoundException, ForbiddenException {
    
    Map<String, String> linesPerFile = new LinkedHashMap<>();
    RegisteredProject project = projectManager.getProject(projectPath);

    for (FileEntry child : project.getBaseFolder().getChildFiles()) {
      if (isJsonFile(child)) {
        linesPerFile.put(child.getName(), Integer.toString(countLines(child)));
      }
    }
    
    return linesPerFile;
  }

  private static int countLines(FileEntry fileEntry) 
         throws ServerException, ForbiddenException {
    String content = fileEntry.getVirtualFile().getContentAsString();
    String[] lines = content.split("\r\n|\r|\n");
    return lines.length;
  }

  private static boolean isJsonFile(FileEntry fileEntry) {
    return fileEntry.getName().endsWith("json");
  }

}
To access workspace services on the client-side, the path needs to include the workspace ID as well as the project ID. Both can be retrieved using the AppContext. Furthermore, all services running within the workspace have a basic context path which can be retrieved from the AppContext.

The following example creates a path, which would access the service above with the current project as a parameter:

Java
String url = this.appContext.getDevMachine().getWsAgentBaseUrl() 
  + "/json-example/"
  + appContext.getWorkspaceId()
  + appContext.getCurrentProject().getProjectConfig().getPath();
Besides the specific path, workspace services can be consumed like any other server service using the REST utilities of Che. Please have a look at the sections Server Services and Client Server Communication for more details.

The following example action consumes the workspace service defined above and shows the result using the notification manager.

che/samples/sample-plugin-json/che-sample-plugin-json-ide/src/main/java/org/eclipse/che/plugin/jsonexample/ide/action/CountLinesAction.java
org.eclipse.che.plugin.jsonexample.ide.action.CountLocAction

@Singleton
public class CountLinesAction extends JsonExampleProjectAction {

  private final AppContext appContext;
  private final StringMapUnmarshaller unmarshaller;
  private AsyncRequestFactory asyncRequestFactory;
  private NotificationManager notificationManager;

  @Inject
  public CountLinesAction(AppContext appContext,
                        JsonExampleResources resources,
                        AsyncRequestFactory asyncRequestFactory,
                        NotificationManager notificationManager) {

    super(appContext,
              "Count JSON Lines of Code",
              "Counts lines of code for all JSON Files in the project",
              resources.icon());

    this.appContext = appContext;
    this.asyncRequestFactory = asyncRequestFactory;
    this.notificationManager = notificationManager;
    this.unmarshaller = new StringMapUnmarshaller();
  }

  @Override
  public void actionPerformed(ActionEvent e) {
    String url = this.appContext.getDevMachine().getWsAgentBaseUrl()
      + "/json-example/"
      + this.appContext.getWorkspaceId()
      + this.appContext.getCurrentProject().getProjectConfig().getPath();

      asyncRequestFactory.createGetRequest(url, false).send(
        new AsyncRequestCallback<Map<String, String>>(unmarshaller) {
  
          @Override
          protected void onSuccess(Map<String, String> linesPerFile) {
          
            for (Map.Entry<String, String> entry : linesPerFile.entrySet()) {
              String fileName = entry.getKey();
              String loc = entry.getValue();
              notificationManager.notify(
                "File " + fileName + " has " + loc + " lines.",
                StatusNotification.Status.SUCCESS,
                StatusNotification.DisplayMode.FLOAT_MODE
              );
             }
           }

           @Override
           protected void onFailure(Throwable exception) {
            notificationManager.notify(
              exception.getMessage(),
              StatusNotification.Status.FAIL,
              StatusNotification.DisplayMode.FLOAT_MODE
              );
           }
        });

  }
}


\\\\\\\\\\\\\\\\\\\\\\\\Parts
Parts
Part API

Parts represent the content of the Che workbench, i.e. views and editors within the IDE. Che already provides various parts such as the project explorer, the output console, the build result view, file outline and the code editor. In this part of the tutorial, we describe how to implement a custom view and embed it into the Che IDE. Furthermore, we demonstrate how to open and hide views.

CREATE A CUSTOM PART
Creating a part in Che consists of two four components, which are marked in grey in the diagram below. In this section, we provide a general overview, in the following sections, we describe the concrete implementation more in detail.
The central component is the implementation of the view itself (MyViewImpl). It will create all the UI widgets, which are shown within a part. MyViewImpl inherits from BaseView, a base implementation of common functionality for all views provided by Che. If the view needs to be accessed by other components, e.g. to set a selection, public methods should be extracted to an interface (MyView). To allow other components to get an instance of MyView, the interface is bound to the implementation within MyGinModule. See the section Dependency Injection Basics for more details about this.
As mentioned before, the view implementation is responsible for the content of a view. The integration into the Che IDE, including configuring the tab (title, icon, etc.) is done by a part presenter (MyPartPresenter), which inherits from BasePresenter. Part presenter are called by Che or a custom action to interact with a part, e.g. to open it or to fill it with content. The part presenter forwards relevant calls to the implementation of a view (encapsulated by the interface).


In the following sections, we describe the implementation of the mentioned components more in detail. As an example, we create a part displaying "Hello World" and define an action to open it.

Implementing a View
In this section, we describe the implementation of a simple "Hello World" view. The implementation is shown in the following listing. All views in Che inherit from org.eclipse.che.ide.api.parts.base.BaseView, which implements basic features for views embedded into the Che IDE. The super constructor requires the PartStackUIResources which we get injected as a parameter.
Views in Che are implemented using GWT. Therefore, we can use any GWT widgets or framework capabilities to actually implement the views. In the following example, we simply create a label and set its text. To implement more complex views and use other GWT features, such as describing the UI using XML, please refer to the GWT project page.

In the last line of the example, we call the method #setContenWidget of the base class to specifiy the root widget to be shown in the view. In our case, this is the Label, if you create a more complex layout of widgets, this would be the root container of the view.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldViewImpl.java
package org.eclipse.che.plugin.parts.ide.helloworldview;

import com.google.gwt.user.client.ui.Label;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.eclipse.che.ide.api.parts.PartStackUIResources;
import org.eclipse.che.ide.api.parts.base.BaseView;

public class HelloWorldViewImpl extends BaseView<HelloWorldView.ActionDelegate> implements HelloWorldView {

    @Inject
    public HelloWorldViewImpl(PartStackUIResources resources){
        super(resources);
        Label label = new Label("Hello World");
        setContentWidget(label);
    }


}
As mentioned in the introduction of this section, an explicit interface should defined, when implementing a view, encapsulating all interaction with other components (see following listing). Therefore, the interface contains all methods, which shall be accessible by other components. In the following example, the interface defines a method #setVisible to allow controlling the visibility of the view. This method is already implemented by BaseView so we do not need to implement it in HelloWorldViewImpl. If you need to provide any other methods for a view, e.g. to pass in some input parameters to be shown, you should extend the view interface accordingly.

Following the GWT pattern, the view interface also defines an ActionDelegate. This interface can be implemented by components, which want to listen to events triggered with the view, e.g. a button click. Our HelloWorldViewis currently not triggering any actions, so the interface is empty. Please see the section "Interacting from within views" below for more details.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldView.java
package org.eclipse.che.plugin.parts.ide.helloworldview;

import org.eclipse.che.ide.api.mvp.View;
import org.eclipse.che.ide.api.parts.base.BaseActionDelegate;

public interface HelloWorldView extends View<HelloWorldView.ActionDelegate> {


    void setVisible(boolean visible);

    interface ActionDelegate extends BaseActionDelegate {

    }
}
Finally, we have to make our view available for other components, using dependency injection. This is done in MyGinModule, which can contain other bindings, too. Please see the section Dependency Injection Basics for more details about this binding.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/inject/MyGinModule.java
package org.eclipse.che.plugin.parts.ide.inject;

import com.google.gwt.inject.client.AbstractGinModule;
import org.eclipse.che.ide.api.extension.ExtensionGinModule;
import org.eclipse.che.plugin.parts.ide.helloworldview.HelloWorldView;
import org.eclipse.che.plugin.parts.ide.helloworldview.HelloWorldViewImpl;

@ExtensionGinModule
public class MyGinModule extends AbstractGinModule {

    @Override
    protected void configure() {
        bind(HelloWorldView.class).to(HelloWorldViewImpl.class);
    }

}
Implementing a Part Presenter
To connect the view implementation to the Che workbench, we need to implement a part presenter. It defines, how a view is embedded into Che (e.g. a title and an icon). Furthermore, it handles all interactions with the view. This goes in both directions. As a first example, if you want to hide a view, you will call the presenter. As a second example, if you click a button within a view, which should trigger something in Che, the presenter will receive this event and trigger the specified action.

The following listing shows the HelloWorldPresenter for the previous example view. It retrieves the HelloWorldview using dependency injection in its constructor. The following methods define, how the view is presented as a tab in Che: a title, an icon and a tooltip. The method #setVisible delegates to the view itself.
The method #go is called, when a view is opened. As a parameter, it receives a callback, which expects a view implementation to be set. With this call, the view implementation is wired to the Che workbench.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldPresenter.java
package org.eclipse.che.plugin.parts.ide.helloworldview;
import com.google.gwt.user.client.ui.AcceptsOneWidget;
import com.google.gwt.user.client.ui.IsWidget;
import com.google.inject.Inject;
import org.eclipse.che.ide.api.parts.base.BasePresenter;
import org.eclipse.che.plugin.parts.ide.SamplePartsResources;
import org.vectomatic.dom.svg.ui.SVGResource;

/**
 * Presenter for the sample Hello World View.
 */
@Singelton
public class HelloWorldPresenter extends BasePresenter {

    private HelloWorldView view;

    @Inject
    public HelloWorldPresenter(HelloWorldView view){
        this.view = view;
    }

    @Override
    public String getTitle() {
        return "Hello World View";
    }
  
    @Override
    public SVGResource getTitleImage() {
        return (SamplePartsResources.INSTANCE.icon());
    }
  
    @Override
    public String getTitleToolTip() {
        return "Hello World Tooltip";
    }

    @Override
    public IsWidget getView() {
        return view;
    }

    @Override
    public void setVisible(boolean visible) {
        view.setVisible(visible);
    }

    @Override
    public void go(AcceptsOneWidget container) {
        container.setWidget(view);
    }
}
Interacting from within a view
To trigger any behavior from with views, the ActionDelegate is used as a receiver of events following the GWT MVP pattern. Therefore, you extend the interface by the required methods, in the following listing a method #onButtonClicked.

Java
/** Required for delegating functions in view. */ 
public interface ActionDelegate extends BaseActionDelegate { 
  /** Performs some actions in response to a user's clicking on Button */ 
  void onButtonClicked(); 
}
The ActionDelegate interface has to be implemented and provided to the view. For a part, the part presenter is a good component to do both, especially, if the relevant operations to be triggered are related to the Che workbench or to Che services. Therefore, the part presenter implements the interface MyView.ActionDelegate, implements the defined method and sets itself as a delegate (see listing below).

Java
@Singelton
public class MyPartPresenter extends BasePresenter implements MyView.ActionDelegate {

    private MyView view;

    @Inject
    public MyPartPresenter(MyView view){
        this.view = view;
        view.setDelegate(this);
    }
  
    public void onButtonClicked(){
      //Do sth.
    }
Finally, the action delegate can be called from within the view implementation, as shown below.

Java
public class MyViewImpl extends BaseView<HelloWorldView.ActionDelegate> implements MyView {

/...

public void onButtonClicked(ClickEvent event) { 
    delegate.onButtonClicked(); 
}
OPENING PARTS
To open parts, the service WorkspaceAgent is used. It provides a method #openPart which accepts two parameters:

The part presenter of the part to be opened
The location, where the part is to be opened
The following locations are supported by Che:

EDITING: area just above the editor, like a file tab
NAVIGATION: area on the left to project explorer
TOOLING: area to the right of the editor
INFORMATION: area under the editor, 'console' area
After a pat has been opened, it must be activated to ensure that it gets visible and receives the focus. This is done using WorkspaceAgent#setActivePart.
The following code example shows an action, which opens the "Hello World" part defined before. Please see the section Actions for more details about the implementation of actions.

che/samples/sample-plugin-parts/che-sample-plugin-parts-ide/src/main/java/org/eclipse/che/plugin/parts/ide/helloworldview/HelloWorldViewAction.java
package org.eclipse.che.plugin.parts.ide.helloworldview;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.eclipse.che.ide.api.action.Action;
import org.eclipse.che.ide.api.action.ActionEvent;
import org.eclipse.che.ide.api.parts.PartStackType;
import org.eclipse.che.ide.api.parts.WorkspaceAgent;

/**
 * Action for showing a the Hello World View.
 */
@Singleton
public class HelloWorldViewAction extends Action {

    private WorkspaceAgent workspaceAgent;
    private HelloWorldPresenter helloWorldPresenter;

    /**
     * Constructor.
     *
     */
    @Inject
    public HelloWorldViewAction(WorkspaceAgent workspaceAgent, HelloWorldPresenter helloWorldPresenter) {
        super("Show Hello World View");
        this.workspaceAgent = workspaceAgent;
        this.helloWorldPresenter = helloWorldPresenter;
    }


    @Override
    public void actionPerformed(ActionEvent e) {
        workspaceAgent.openPart(helloWorldPresenter, PartStackType.INFORMATION);
        workspaceAgent.setActivePart(helloWorldPresenter);
    }
}

\\\\\\\\\\\\\\\\\\\\\\\\\REST APIs
REST APIs
Many of the IDE components that you build into your extension will need to communicate directly with the Che server or to the workspace the IDE is currently bound to. Che provides helper utilities to make REST calls simpler. Che's REST library is built on top of Google's HTTP Java client libraries.

In your extension code, you can create an AsyncRequestFactory object, which has helper methods for creating requests that will have responses.

che/core/ide/che-core-ide-api/src/main/java/org/eclipse/che/ide/api/project/ProjectTypeServiceClientImpl.java
private void getProjectType(@NotNull String workspaceId, 
                            @NotNull String id, 
                            @NotNull AsyncCallback<ProjectTypeDto> callback) {
  
    final String url = extPath + "/project-type/" + workspaceId + '/' + id;
    asyncRequestFactory.createGetRequest(url)
                       .header(ACCEPT, APPLICATION_JSON)
                       .loader(loaderFactory.newLoader("Getting info about project type..."))
                       .send(newCallback(callback, 
                                         dtoUnmarshallerFactory.newUnmarshaller(ProjectTypeDto.class)));

}
This example comes from the class used by the IDE to ask the server to provide a response on what the current project type is within the currently active workspace. The asyncRequestFactory object was instantiated by the system as an input parameter. Calling the createGetRequest() method with the GET REST URL as an input will generate a request and a response. The .loader() method is an optional display component that will appear on the screen while the contents of the response are loading. The send() method takes a callback object which will be invoked by the system when a response is delivered.

In the debugger implementation class, you can see a range of REST calls for different individual functions such as step into, step over, and so forth.

In the Java content assist class, you can see the sequence of REST calls that are made for generating requests for information from the server about intellisense features that can only be processed on the server side.

Callbacks
In Che, you will frequently see AsyncRequestCallback<T> objects passed into an AsyncRequestFactory object. Callbacks will be invoked by the system when a response is returned. This class inherits from com.google.gwt.http.client.RequestCallback and we add in a few additional objects:

Unmarshallable<T> which is logic to convert the response payload from data into a Java object.
AsyncRequestLoader which is a visual loader to display while downloading data.
AsyncRequest which is the original request.
Che provides different types of Unmarshallable objects including StringUnmarshaller, StringMapUnmarshaller, StringMapListUnmarshaller, DtoUnmarshaller, and LocationUnmarshaller. These different marshallers represent the most common types of JSON to Java payload conversions.

For example, this logic comes from the git plugin and is the method that is called when a user asks to delete the local git repository contained within the project.

che/plugins/plugin-git/che-plugin-git-ext-git/src/main/java/org/eclipse/che/ide/ext/git/client/delete/DeleteRepositoryPresenter.java
public void deleteRepository() {
    final CurrentProject project = appContext.getCurrentProject();
    final GitOutputConsole console = gitOutputConsoleFactory.create(DELETE_REPO_COMMAND_NAME);

     service.deleteRepository(workspaceId, project.getRootProject(), 
                              new AsyncRequestCallback<Void>() {
        @Override
        protected void onSuccess(Void result) {
            console.print(constant.deleteGitRepositorySuccess());
            consolesPanelPresenter.addCommandOutput(appContext.getDevMachineId(), console);
            notificationManager.notify(constant.deleteGitRepositorySuccess(), project.getRootProject());
            getRootProject(project.getRootProject());
        }

        @Override
        protected void onFailure(Throwable exception) {
            // The logic for what to do if the response generated a failure message
        }
    });
}
In this example, the service.deleteRepository(...) is a method that will generate the AsyncRequestFactory object for calling the server. This object requires a AsyncRequestCallback<T>. This method creates a new instance inline with a callback that expects the response to send data of Void type, which basically means that there is no response payload. In this case, either the server tells us there is success or there is failure. The AsyncRequestCallback instance needs to implement two methods onSuccess(<T>) and onFailure(Throwable), which will be called by the AsyncRequestFactory when the response arrives on the wire. It is within these methods that the logic is placed that tells the IDE what to do in each event.


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Java Class Reference
Java Class Reference
JavaDoc for the Che & GWT classes available to developers

You can generate the JavaDoc for your installation from source.

Shell
# You need the che-core library
git clone http://github.com/eclipse/che
git checkout {version-that-matches-your-install}
cd core/
mvn javadoc:aggregate

# JavaDoc available at:
/core/target/site/apidocs/index.html

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Properties
Properties
Referencing Properties in Extensions
You can reference properties in Che extensions that you author. Configuration parameters may be injected with a constructor or directly in the fields. The parameter of the field must be annotated with @javax.inject.Named. The value of the annotation is the name of the property. For example, if the configuration property is: data_file:/home/user/storage then in your extension code:

Java
public class MyClass {
  ...
  @Inject
  public MyClass(@Named("data_file") File storage) {
      ...
  }
}
or

Java
public class MyClass {
  @Inject
  @Named("data_file")
  private File storage;
  ...
}
All system properties and environment variables may be injected into your extensions with prefixes sys. and env., respectively. So, for example, environment variable HOME name must be env.HOME. Here is an example of how to inject the value of system property java.io.tmpdir and value of environment variable HOME.

Java
public class MyClass {
  @Inject
  public MyClass(@Named("sys.java.io.tmpdir") File tmp, @Named("env.HOME") File home) {
      ...
  }
}
Any value can be converted into a java.lang.String Java type. You can also directly convert properties to the following Java types:

boolean
byte
short
int
long
float
double
java.net.URI
java.net.URL
java.io.File
String[] (value is a comma separated string)
Workspace Extension Properties
Each workspace is a separate runtime, and has at least one development agent that runs as a miniaturized Che server within the workspace. That agent has its own properties that can be configured as well. If you are authoring custom workspace extensions that are deployed within Che's agent in the workspace, you can customize.

Properties saved in CHE_CONF_FOLDER\plugin-conf\ folder will be mounted into the runtime for each workspace created by Che. The Che development agent that runs within the workspace will load these properties when it boots.


\\\\\\\\\\\\\\\\\\\\\\\\\\\\Workspace Access
Workspace Access
One of the core strengths of Che is the workspace concept. Additionally to project files, such as source code, Che also allows to share workspaces, which provide the necessary runtime to compile and run the system under development. Workspaces can also provide any other kind of tooling to work on a project, this tooling can then be triggered in the Che IDE.

The concept of workspaces makes it very convenient to reuse any existing tool in Che, as those tools can be executed on the workspace runtime. Che already provides several of those tool integrations, such as Maven or Git.

There are two ways to integrate tools running on the workspace: First, you can provide a custom workspace service, which triggers the native workspace call and provides an API to be used by the client IDE. Second, you can use the existing command support of Che, which already allows to execute native commands on the workspace without implementing a custom service. In this tutorial, we will demonstrate the second option, please refer to this tutorial this tutorial to learn how to implement custom services.

In the following, we implement a simple command, which creates a new file called "che-was-here" using the native "touch" command. The command is finally called by a sample action, however, we encapsulate the execution of the command into a dedicated class called CommandManager which can execute arbitrary commands on the workspace (see following listing).

To execute a command, Che provides the service MachineServiceClient. To execute a command, it requires the ID of the machine the command should be executed on, the command to be executed, an output channel and a callback.

The ID can be retrieved from the AppContext. The Command is created using the Che DtoFactory. The parameter CommandLine specifies the native command to be executed. Finally, we create a sample output channel and execute the command with an empty call back.

che/samples/sample-plugin-nativeaccess/che-sample-plugin-nativeaccess-ide/src/main/java/org/eclipse/che/plugin/nativeaccessexample/machine/client/command/CommandManager.java
@Singleton
public class CommandManager {

    private final DtoFactory dtoFactory;
    private final MachineServiceClient machineServiceClient;
    private final NotificationManager notificationManager;
    private final AppContext appContext;

    @Inject
    public CommandManager(DtoFactory dtoFactory, MachineServiceClient machineServiceClient, NotificationManager notificationManager, AppContext appContext) {
        this.dtoFactory = dtoFactory;
        this.machineServiceClient = machineServiceClient;
        this.notificationManager = notificationManager;
        this.appContext = appContext;
    }

    /** Execute the the given command configuration on the developer machine. */
    public void execute(String commandLine) {
        final Machine machine = appContext.getDevMachine().getDescriptor();
        if (machine == null) {
            return;
        }
        String machineID = machine.getId();
        final CommandDto command = dtoFactory.createDto(CommandDto.class)
                .withName("some-command")
                .withCommandLine(commandLine)
                .withType("arbitrary-type");
        final String outputChannel = "process:output:" + UUID.uuid();
        executeCommand(command, machineID, outputChannel);
    }

    public void executeCommand(final CommandDto command, @NotNull final String machineID, String outputChannel) {
        final Promise<MachineProcessDto> processPromise = machineServiceClient.executeCommand(machineID, command, outputChannel);
        processPromise.then(new Operation<MachineProcessDto>() {
            @Override
            public void apply(MachineProcessDto process) throws OperationException
            {
                //Do nothing in this example
            }

        });

    }
}
Now, the CommandManager can be used to trigger any kind of command line operation. The following example action uses the native "touch" command to create a new file.

che/samples/sample-plugin-nativeaccess/che-sample-plugin-nativeaccess-ide/src/main/java/org/eclipse/che/plugin/nativeaccessexample/ide/action/RunNativeCommandAction.java
@Singleton
public class RunNativeCommandAction extends Action {

    public final static String ACTION_ID = "runNativeCommandSAction";

    private CommandManager commandManager;

    @Inject
    public RunNativeCommandAction(CommandManager commandManager) {
        super("Run native command demo");
        this.commandManager = commandManager;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Log.warn(getClass(), "Executing native command...");
        commandManager.execute("cd && touch che-was-here");
    }

}


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Native HTML/JS
Native HTML/JS
The Che IDE is developed based on GWT. If you want to extend the Che UI with new UI components, the default is to develop those custom components using GWT, too. Please refer to this tutorial to learn how to extend Che with new parts (view or editors).

However, as Che is a browser application based on HTML and JavaScript, it is also possible to embed native web components. Those do not have to be based on GWT. This also enables you to reuse any kind of existing UI component in Che. As an existing example, Che embeds the Orion code editor.

Details
For instructions on how to build and run an extension, see Building Extensions.

JavaScript
Location:     github.com/eclipse/che/samples/sample-plugin-embedjs
Type:         IDE extension
groupId:      org.eclipse.che.sample
artifactId:   che-sample-plugin-embedjs-ide
Steps
In this tutorial, we demonstrate, how to embed a minimal HTML/JavaScript component into Che. We will create a custom part, which shows a "Hello World" produced by a simple JavaScript snippet (see screenshot below). You can extend this example, to embed any HTML/JavaScript component you like.


The following example is based on a simple part, which is opened by a sample action. Therefore, we recommend to get familiar with the implementation of Parts and Actions first.

The HelloWorldView is a default view, in this example, the HelloWorldView just creates an empty Panel. The panel will finally be represented by a HTML element in the running browser application.

In the HelloWorldPresenter we use the GWT ScriptInjector library to inject a custom script (helloWorld.js) into the main window of the browser application. Finally, we use HelloWorldOverlay to call the custom JavaScript from within our GWT application. In our example, it will modify the HTML element, which represents the Panel, and will add the "Hello World from JavaScript" text to it.


The HelloWorld.js contains a simple function, which replaces the text content of an arbitrary element in the DOM. It could also add new elements and therefore embed an arbitrary sub component to running the browser application.

che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/resources/org/eclipse/che/plugin/embedjsexample/public/helloworld.js
function HelloWorld(element, contents) {
    element.textContent = contents;
};
To add the custom JavaScript function to the running application, we use the GWT ScriptInjector library. We load the JavaScript file and add it to the top window of the application. If adding the script was successful, we directly call the method #sayHelloWorld of the HelloWordView, which we explain in the following.

Java
@Singleton
public class HelloWorldViewPresenter extends BasePresenter implements HelloWorldView.ActionDelegate, HasView {

    private final HelloWorldView helloWorldView;

    @Inject
    public HelloWorldViewPresenter(final HelloWorldView helloWorldView) {
        this.helloWorldView = helloWorldView;

        ScriptInjector.fromUrl(GWT.getModuleBaseURL() + Constants.JAVASCRIPT_FILE_ID)
                .setWindow(ScriptInjector.TOP_WINDOW)
                .setCallback(new Callback<Void, Exception>() {
                    @Override
                    public void onSuccess(final Void result) {
                        Log.info(HelloWorldViewPresenter.class, Constants.JAVASCRIPT_FILE_ID + " loaded.");
                        sayHello();
                    }

                    @Override
                    public void onFailure(final Exception e) {
                        Log.error(HelloWorldViewPresenter.class, "Unable to load "+Constants.JAVASCRIPT_FILE_ID, e);
                    }
                }).inject();

    }

    private void sayHello() {
        this.helloWorldView.sayHello("Hello from Java Script!");
    }
The HelloWorldViewImpl creates an empty panel (which is defined in che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/java/org/eclipse/che/plugin/embedjsexample/ide/view/HelloWorldViewImpl.ui.xml).

Furthermore, it implement the method #sayHello and forwards it to HelloWorldViewOverlay.

che/samples/sample-plugin-embedjs/che-sample-plugin-embedjs-ide/src/main/java/org/eclipse/che/plugin/embedjsexample/ide/view/HelloWorldViewImpl.java
public class HelloWorldViewImpl extends BaseView<HelloWorldView.ActionDelegate> implements HelloWorldView {

    interface HelloWorldViewImplUiBinder extends UiBinder<Widget, HelloWorldViewImpl> {
    }

    private final static HelloWorldViewImplUiBinder UI_BINDER = GWT.create(HelloWorldViewImplUiBinder.class);

    @UiField
    FlowPanel helloWorldPanel;

    @Inject
    public HelloWorldViewImpl(PartStackUIResources resources) {
        super(resources);
        setContentWidget(UI_BINDER.createAndBindUi(this));
    }

    @Override
    public void sayHello(String content) {
        HelloWorldViewOverlay.sayHello(helloWorldPanel.getElement(), content);
        helloWorldPanel.setVisible(true);
    }

}
Finally the HelloWorldOverlay provides access to the JavaScript function and therefore redirects the Java method to a call of the HelloWorld function that we added before. Such overlays are used for communicating between the Che IDE, written in Java/GWT and native JavaScript components, which are embedded into it.

Java
public class HelloWorldViewOverlay extends JavaScriptObject {

    protected HelloWorldViewOverlay() {
    }

    public final static native void sayHello(final Element element, String message) /*-{
        new $wnd.HelloWorld(element, contents);
    }-*/;

}
Use
This particular extension adds an action to the main context menu group. This is the group that appears when you right click on the project tree. To verify that your plugin is installed, you can also check the Profile > Preferences > Plugins > List to verify that the "Hello world from JavaScript example" plugin has been installed.


\\\\\\\\\\\\\\\\\\\\\\\\\\\HelloWorld Extension
HelloWorld Extension
Create your first extension

This documentation is a step-by-step guide to build your first HelloWorld extension for Eclipse Che.

In order to follow this guide, we consider you have successfully configured Eclipse Che sources inside of Eclipse IDE and have been able to execute your manually built assembly. If not, please refer to the following documentation.

1- CREATE A NEW MAVEN PROJECT
Create a new maven project.


Skip the archetype selection.


Provide basic information about the Maven project.


Provide asked information (we will update them in the next step)

2- ADD DEPENDENCIES AND PARENT DEFINITION TO THE POM.XML
In order to be properly defined, we will rely on che-parent for the hello world extension. We will inherit from the global che definition.

We add the dependencies for:

Guice
Che Core IDE API
GWT
We also add the Maven repository used to retrieve artifacts and the Build configuration (refer to https://eclipse-che.readme.io/v5.0/docs/create-and-build-extensions#section-pom-xml) .

pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright (c) 2012-2016 Codenvy, S.A.
    All rights reserved. This program and the accompanying materials
    are made available under the terms of the Eclipse Public License v1.0
    which accompanies this distribution, and is available at
    http://www.eclipse.org/legal/epl-v10.html

    Contributors:
      Codenvy, S.A. - initial API and implementation

-->
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <artifactId>che-parent</artifactId>
        <groupId>org.eclipse.che</groupId>
        <version>5.0.0-M6-SNAPSHOT</version>
    </parent>
    <artifactId>che-helloworld-sample</artifactId>
    <packaging>jar</packaging>
    <name>Che Sample :: Hello World</name>
    <dependencies>
        <dependency>
            <groupId>com.google.inject</groupId>
            <artifactId>guice</artifactId>
        </dependency>
        <dependency>
            <groupId>org.eclipse.che.core</groupId>
            <artifactId>che-core-ide-api</artifactId>
        </dependency>
        <dependency>
            <groupId>com.google.gwt</groupId>
            <artifactId>gwt-user</artifactId>
            <scope>provided</scope>
        </dependency>
    </dependencies>
    <repositories>
        <repository>
            <id>codenvy-public-repo</id>
            <name>codenvy public</name>
            <url>https://maven.codenvycorp.com/content/groups/public/</url>
        </repository>
    </repositories>
    <build>
        <sourceDirectory>src/main/java</sourceDirectory>
        <outputDirectory>target/classes</outputDirectory>
        <resources>
            <resource>
                <directory>src/main/java</directory>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>com.google.code.sortpom</groupId>
                <artifactId>maven-sortpom-plugin</artifactId>
                <configuration>
                    <verifyFail>Warn</verifyFail>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
Once your pom.xml file is edited, save it.
You will see that Eclipse is displaying an error on the che-helloworld-extension module. Fix this error by doing an "Update Project" with the Eclipse's Maven plugin:


3- CREATE HELLOWORLDEXTENSION CLASS
Create the package org.eclipse.che.ide.ext.helloworld in src/main/java:


Add HelloWorldExtension java class in the package org.eclipse.che.ide.ext.helloworld:


In this extension we'll need to talk to Parts and Action API. Gin and Singleton imports are obligatory as well for any extension. Add the following import:

imports
...
import org.eclipse.che.ide.api.extension.Extension;
import com.google.inject.Inject;
import com.google.inject.Singleton;
...
We add the following annotations:

annotations
/**
 * @Singleton is required in case the instance is triggered several times this extension will be initialized several times as well.
 * @Extension lets us know this is an extension and code injected in it will be executed when launched
 */
@Singleton
@Extension(title = "Hello world", version = "1.0.0")
public class HelloWorldExtension
{
}
In the constructor, we want our HelloWorld extension to display an "Hello World" message in the Events Panel. In order to do that, we will use the notification manager.

construtor
{
    @Inject
    public HelloWorldExtension(NotificationManager notificationManager) {
        notificationManager.notify("Hello World");
    }
}
Finally, your class should be like this:

HelloWorldExtension.java
/*******************************************************************************
 * Copyright (c) 2012-2016 Codenvy, S.A.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Codenvy, S.A. - initial API and implementation
 *******************************************************************************/
package org.eclipse.che.ide.ext.helloworld;

import org.eclipse.che.ide.api.extension.Extension;

/**
 * Che API imports. In this extension we'll need
 * to talk to Parts and Action API. Gin and Singleton
 * imports are obligatory as well for any extension
 */

import org.eclipse.che.ide.api.notification.NotificationManager;

import com.google.inject.Inject;
import com.google.inject.Singleton;

/**
 * @Singleton is required in case the instance is triggered several times this extension will be initialized several times as well.
 * @Extension lets us know this is an extension and code injected in it will be executed when launched
 */
@Singleton
@Extension(title = "Hello world", version = "1.0.0")
public class HelloWorldExtension
{
    @Inject
    public HelloWorldExtension(NotificationManager notificationManager) {
        notificationManager.notify("Hello World");
    }
}
4- CREATE HELLOWORLDEXTENSION GWT MODULE
Create the package org.eclipse.che.ide.ext.helloworld in src/main/resources:


Add HelloWorldExtension GWT module by creating the file HelloWorldExtension.gwt.xml:


Inherits from the GWT modules: User, Inject. We will also inherits from the IDE GWT API.

HelloWorldExtension.gwt.xml
<!--

    Copyright (c) 2012-2016 Codenvy, S.A.
    All rights reserved. This program and the accompanying materials
    are made available under the terms of the Eclipse Public License v1.0
    which accompanies this distribution, and is available at
    http://www.eclipse.org/legal/epl-v10.html
    Contributors:
      Codenvy, S.A. - initial API and implementation
      
-->
<module>
    <inherits name="com.google.gwt.user.User"/>
    <inherits name="org.eclipse.che.ide.Api"/>
    <inherits name="com.google.gwt.inject.Inject"/>
    <source path=""/>
</module>
5- BUILD THE EXTENSION
Create the following Run Configuration:


Or you can also open a terminal where you create your HelloWorld Extension and run a mvn clean install.

If everything goes well, you should have:

Shell
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 8.673 s
[INFO] Finished at: 2016-10-13T15:05:21+02:00
[INFO] Final Memory: 47M/648M
[INFO] ------------------------------------------------------------------------
6- ADD EXTENSION TO ROOT POM OF CHE
In order to allow your extension to be visible from the root level of Che, add your extension as a dependency in the list of <dependencies> from the <dependencyManagement> block. Edit the pom.xml from che-parent

pom.xml
...
<dependencyManagement>
  <dependencies>
    ...
    <dependency>
      <groupId>org.eclipse.che</groupId>
      <artifactId>che-helloworld-sample</artifactId>
      <version>${che.version}</version>
    </dependency>
    ...
  </dependencies>
</dependencyManagement>
...

You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.


7- LINK TO IDE ASSEMBLY
The HelloWorld extension is only a client-side (IDE) extension. You have to introduce your extension as a dependency in /che/assembly/assembly-ide-war/pom.xml and also have it added as a dependency to the GWT application.

First add the dependency:

/che/assembly/assembly-ide-war/pom.xml
...
<dependencies>
  ...
  <dependency>
     <groupId>org.eclipse.che</groupId>
     <artifactId>che-helloworld-sample</artifactId>
  </dependency>
  ...
</dependencies>
You can insert the dependency anywhere in the list. After you have inserted it, run mvn sortpom:sort and maven will order the pom.xml for you.


Second, link your GUI extension into the GWT app. You will add an <inherits> tag to the module definition. The name of the GWT extension is derived from the direction + package structure given to the GWT module defined in our HelloWorld extension.

In assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml add:

assembly-ide-war/src/main/resources/org/eclipse/che/ide/IDE.gwt.xml
...
<inherits name='org.eclipse.che.ide.ext.helloworld.HelloWorldExtension'/>
...
This means that in our embed sample, there is a file with a *.gwt.xml extension in a folder structure identical to the name above.



8- BUILD CHE WITH YOUR EXTENSION.
First, we need to rebuild the assembly-ide-war:


Or you can also do it in a terminal:

Shell
# Build a new IDE.war
# This IDE web app will be bundled into the assembly
cd che/assembly/assembly-ide-war
mvn clean install
Second, we need to rebuild the whole Eclipse Che assembly:

Or you can also do it in a terminal:

Shell
# Create a new Che assembly that includes all new client-side extensions
cd che/assembly/assembly-main
mvn clean install
9- START YOUR CUSTOM ASSEMBLY
To start Che from the custom assembly you just built, you can refer to this Usage: Docker Launcher. Remind your custom assembly is located in {workspace-path}\che\assembly\assembly-main\target\eclipse-che-<version>\eclipse-che-<version>

10- TEST YOUR EXTENSION
First create a new workspace and open it in the IDE.
Second open the "Events" panel.
You'll see the "Hello World" notification displayed in the list of events.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

=======================
endof AUTHORING EXTENSIONS



getfrom Google Guice   
========================
Google Guice Java 5JDKJava 5 (Generics)  (Annotations)  (type-safe)  Guice  (Business Objects) Guice 

 Guice    Guice  API (Annotations)  Guice APIAPI

(Dependency Injection)

Gucie  (Dependency Injection Framework)  (Dependency Injection)  J2EE 5.0, Spring, JBoss Seam



interface Storage{

    public void store(String uniqueId, Data data);
    public Data retrieve(String uniqueId);
 
}
 Storage  (store)  (retrieve)  Storage 

class FileStorage implements Storage{
 
    public void store(String uniqueId, Data data){
        // Store the object in a file using Java Serialization mechanism.
    }
 
    public Data retrieve(String uniqueId){
        // Code to retrieve the object.
    }
 
}
 FileStorage  Storage 

class DatabaseStorage implements Storage{
 
    public void store(String uniqueId, Data data){
        // Open a connection and store the data.
    }
 
    public Data retrieve(String uniqueId){
        // Get the data from the Database.
    }
 
}
 Storage  StorageClient  FileSorage DatabaseStorage 

public class StorageClient {
 
    public static void main(String[] args) {
 
        // Making use of file storage. 
        Storage storage = new FileStorage();
        storage.store("123", new Data());
 
        // Making use of the database.
        storage = new DatabaseStorage();
        storage.store("456", new Data());
    }
}
 StorageClient  (Storage)   FileStorage / DatabaseStorage    (StorageClient)  (instance)  (Relationship)  () Google Guice  Services   (Configuration Mechanism) 

 Guice Framework 

 Guice 

 Guice / Add  add() 

public interface Add {
 
    public int add(int a, int b);
 
}
 Add 

public class SimpleAdd implements Add{
 
    public int add(int a, int b) {
        return a + b;
    }
 
}
 Module  Guice API  BindingsModule  Bindings  Binder  Bindings  Module Guice Binding  interface 

import com.google.inject.Binder;
import com.google.inject.Module;
 
public class AddModule implements Module{
 
    public void configure(Binder binder) {
        binder.bind(Add.class).to(SimpleAdd.class);
    }
 
}
 Guice  SimpleAdd  Add Add.add()  SimpleAdd.add()  Add 

import com.google.inject.Guice;
import com.google.inject.Injector;
 
public class AddClient {
 
    public static void main(String[] args) {
 
        Injector injector = Guice.createInjector(new AddModule());
        Add add = injector.getInstance(Add.class);
        System.out.println(add.add(10, 54));
    }
}
 Injector, Guice injector.getInstance(Add.class)  SimpleAdd  AddModule.configure() 

Guice API 

  Guice  API /

Binder
Injector
Module
Guice
1. Binder

Binder  Bindings  Binding  Add   SimpleAdd 

 (interface)  (implementation classes) bind()  to()

binder.bind(Add.class).to(SimpleAdd.class)


binder.bind(Add.class).to(new SimpleAdd())
 Provider Guice Object Creation Process Providers  Factory Pattern Providers

binder.bind(Add.class).to(new AddProvider<Add>())
 Provider  AddProvider  Add 

2. Injector

Injectors  Clients  Creating (Maintaining) Injectors  Bindings (Default Bindings) Configuration information Add 

Add addObject = injector.getInstance(Add.class)
 Injector.getBindings()  Injector  BindingsgetBindings  Map

Map<Key, Binding> allBindings = injector.getBindings()
 Binding  Key  Guice Injector Providers 

Provider<SomeType> provider = injector.getProvider(SomeType.class)
3. Module

Module  Bindings Module   Injectors  Module  BindingsModule  override  Module.configure()  Bindings  AbstractModule Module  configure  

class MyModule extends AbstractModule{
 
    public void configure(Binder binder){
 
        // Code that binds information using the various
        // flavours of bind method.
    }
}
4. Guice

 Clients  Guice  Objects Injector  Modules  Guice 

MyModule module = new MyModule();
Injector injector = Guice.createInjector(module);
 Guice.createInjector()  Module  Module  configure()    Binder   Binder  Bindings (to Classes, Objects and Providers)  Injector  getInstance() Injector  Binder  Bindings 

Guice  Annotations

Guice  Annotations  Annotations   meta-data 

Implemented By
Inject
Provided By
Singleton
1. Implemented By

 Annotation  Add  SimpleAdd  Add 

@ImplementedBy(SimpleAdd.class)
interface Add{
 
    public int add(int a, int b);
 
}
2. Inject

 Inject Annotation 

class Client{
 
    @Inject
    public Client(MyService service){
    }
}
 Constrcctor-level  MyService  Module  Method-level   Field-level 

3. Provided By

 Object creation process Guice Provider   Add  AddProvider  SimpleAdd  ProvidedBy  Provider  

@ProvidedBy(AddProvider.class)
public interface Add{
 
}
4. Singleton

 Injector.getInstance() Singleton Pattern One Instance in the application Singleton 

@Singleton
public class MyConnection{
 
    public void connect(){
    }
 
    public void disconnect(){
    }
}

 Samples

 

 Guice API 

1. 

 Player  PlayerTest  Guice 

 Player 

public class Player {
 
public String name;
 
    public Player(){        
    }
 
    public String toString(){
        return name;
    }
}
 Player  Guice.createInjector()  Module 

import com.google.inject.Guice;
import com.google.inject.Injector;
 
public class PlayerTest {
 
public static void main(String[] args) {
 
    Injector injector = Guice.createInjector();
    Player player = injector.getInstance(Player.class);
    player.name = "David Boon";
    System.out.println(player);
    }
}
2.  Multiple Dependencies

  @Inject   Case 

 Mobile  Laptop 

public class Laptop {
 
    private String model;
    private String price;
 
    public Laptop(){
        this.model = "HP 323233232";
        this.price = "$545034";
    }
 
    public String toString(){
        return "[Laptop: " + model + "," + price + "]";
    }
}
public class Mobile {
 
private String number;
 
    public Mobile(){
        this.number = "988438434";
    }
 
    public String toString(){
        return "[Mobile: " + number + "]"; 
    }
}
 Person   @Inject  Laptop  Mobile 

import com.google.inject.Inject;
 
public class Person {
 
    private Mobile mobile;
    private Laptop laptop;
 
    @Inject
    public Person(Mobile mobile, Laptop laptop){
        this.mobile = mobile;
        this.laptop = laptop;
    }
 
    public void diplayInfo(){
        System.out.println("Mobile:" + mobile);
        System.out.println("Laptop:" + laptop);
    }
}
 Bindings  Guice.createInject()  Module 

import com.google.inject.Guice;
import com.google.inject.Injector;
 
public class MultipleDependencyTest {
 
    public static void main(String[] args) {
 
        Injector injector = Guice.createInjector();
        Person person = injector.getInstance(Person.class);
        person.diplayInfo();
    }
}


 Mobile:[Mobile: 988438434]
Laptop:[Laptop: HP 323233232,$545034]
3.  Binding 

 Guice  Runtime Error.

binderObject.bind(SomeType.class).to(ImplemenationOne.class);
binderObject.bind(SomeType.class).to(ImplemenationTwo.class);
 Guice  Java Guice  Binding  Player 

public interface Player {
 
    public void bat();
    public void bowl();
 
}
 Player  GoodPlayer  BadPlayer

public class GoodPlayer implements Player{
 
    public void bat() {
        System.out.println("I can hit any ball");
    }
 
    public void bowl() {
        System.out.println("I can also bowl");
    }
}
public class BadPlayer implements Player{
 
    public void bat() {
        System.out.println("I think i can face the ball");
    }
 
    public void bowl() {
        System.out.println("I dont know bowling");
    }
 
}
 Guice  Player  GoodPlayer  BadPlayerGoodPlayer  BadPlayer  Annotaion mechanisms  Guice 

 1 import com.google.inject.*;
 2  
 3 public class PlayerModule implements Module{
 4  
 5     public void configure(Binder binder) {
 6  
 7         binder.bind(Player.class).annotatedWith(Good.class).to(
 8             GoodPlayer.class);
 9         binder.bind(Player.class).annotatedWith(Bad.class).to(
10             BadPlayer.class);        
11     }
12 }
79.annotatedWith(Good.class)  .annotatedWith(Bad.class) GoodGoodPlayerBadBadPlayer

 AnnotationGood  Bad Good annotation  Bad annotation 

import java.lang.annotation.*;
import com.google.inject.BindingAnnotation;
 
@Retention(RetentionPolicy.RUNTIME)
@BindingAnnotation
@Target(ElementType. LOCAL_VARIABLE)
public @interface Good {}
import java.lang.annotation.*;
import com.google.inject.BindingAnnotation;
 
@Retention(RetentionPolicy.RUNTIME)
@BindingAnnotation
@Target(ElementType. LOCAL_VARIABLE)
public @interface Bad {}
 Annotation 

 1 import com.google.inject.Guice;
 2 import com.google.inject.Injector;
 3 import com.google.inject.Module;
 4  
 5 public class PlayerClient {
 6  
 7     public static void main(String[] args) {
 8  
 9         PlayerModule module = new PlayerModule();
10         Injector injector = Guice.createInjector(new Module[]{module});
11  
12         @Good Player player = (Player)injector.getInstance(Player.class);
13         player.bat();
14         player.bowl();
15     }
16 }
1012 12 @Good  Guice  Playe Moduler  GoodPlayer

4. Named 

 Annotation  @Named  entities  Names.named()  Annotation Player Module  Names.named() 

import com.google.inject.Binder;
import com.google.inject.Module;
 
public class PlayerModule implements Module{
 
    public void configure(Binder binder) {
 
        binder.bind(Player.class).annotatedWith(Names.named("Good")).to(
            GoodPlayer.class);
        binder.bind(Player.class).annotatedWith(Names.named("Bad")).to(
        BadPlayer.class);        
    }
 
}
 @Named() annotation

@Named("Good") Player goodPlayer = (Player)injector.getInstance(Player.class);
 
@Named("Bad") Player badPlayer = (Player)injector.getInstance(Player.class);
5.  Provider

 Guice  Providers  Factories  Guice ServicesObject creation processCache Guice  Provider 

 MockConnection 

public class MockConnection {
 
    public void connect(){
        System.out.println("Connecting to the mock database");
    }
 
    public void disConnect(){
        System.out.println("Dis-connecting from the mock database");
    }
 
}
 Provider  Guice  Provider  MockConnection

public class ConnectionProvider implements Provider<MockConnection>{
 
    @Override
    public MockConnection get() {
 
        // Do some customization mechanism here.
        MockConnection connection = new MockConnection();
        // Do some customization mechanism here too.
        return connection;
    }    
}
 Provider  Provider  get()  Module  Provider  ConnectionProvider 

 1 import com.google.inject.*;
 2  
 3 public class ConnectionTest {
 4  
 5     public static void main(String args[]){        
 6         Injector injector = Guice.createInjector(
 7             new Module(){
 8                 @Override
 9                 public void configure(Binder binder) {
10                     binder.bind(MockConnection.class).toProvider(
11                         ConnectionProvider.class);                
12                 }                        
13             }                
14         );
15  
16         MockConnection connection = 
17         injector.getInstance(MockConnection.class);
18         connection.connect();
19         connection.disConnect();
20     }
21 }
10 toProvider()  MockConnection.class  Provider 
=========================
endof Google Guice   




getfrom GWT(Google Web Toolkit)
=======================
http://blog.csdn.net/struts2/article/details/1758122

GWT Google Web Toolkit
GWTJSON 

GWTJavaSwingUIGWT Compiler

JavaScritpHTML

 

GWT

Hosted Model

     Hosted ModelJavaJavaScriptGWT

     GWTDebugJava

     Hosted Model

Web Model

     GWTJavaJavaScriptWeb

     Java

     Java

 

GWT

GWT

http://code.google.com/webtoolkit/download.html

Release1.4.60 1.3.3


>>>>>>>>>>>>>
GWT SDK	gwt2.8.0.zip
Plugin for Eclipse (incl. SDKs)	Eclipse 4.5 (Mars)	Plugin for Eclipse 4.5 (Mars) https://dl.google.com/eclipse/plugin/4.5


JDK 1.4 

GWT1.4.59 RC2gwt-windows-1.4.59.zip


GWTC://Java/gwt-windows-1.4.59



 



C://Java/gwt-windows-1.4.59

>>>>>>>>>>>>>D:\DevWork\1114to1119_wk47\gwt-2.8.0

    docJava API
    samplesKitchenSink

    about.html
    about.txt
    applicationCreator.cmd
    benchmarkViewer.cmd
    COPYING
    COPYING.html
    gwt-benchmark-viewer.jar
    gwt-dev-windows.jar
    gwt-ll.dll
    gwt-module.dtd
    gwt-servlet.jar
    gwt-user.jar
    i18nCreator.cmd
    index.html
    junitCreator.cmd
    projectCreator.cmd
    release_notes.html
    swt-win32-3235.dll

 

GWT

GWTSamplesKitchenSinkGWTWeb

 Prerequisites

You will need the Java SDK version 1.6 or later. If necessary, download and install the Java SE Development Kit (JDK) for your platform. Mac users, see Apples Java developer site to download and install the latest version of the Java Developer Kit available for Mac OS X.
Apache Ant is also necessary to run command line arguments. If you dont already have it, install Apache Ant.
If you have problems running Ant on the Mac, try setting the $JDK_HOME environment variable with export JDK_HOME=/Library/Java/Home


in getfrom ant
-------------
http://www.cnblogs.com/yuzhongwusan/archive/2013/03/26/2982411.html
ant
ant
http://ant.apache.orgAnt1.8.1antapache-ant-1.8.1-bin.zipC:\apache-ant-1.8.1
.zip archive: apache-ant-1.9.7-bin.zip [PGP] [SHA1] [SHA512] [MD5] -for windows
.tar.gz archive: apache-ant-1.9.7-bin.tar.gz [PGP] [SHA1] [SHA512] [MD5] -for linux
.tar.bz2 archive: apache-ant-1.9.7-bin.tar.bz2 [PGP] [SHA1] [SHA512] [MD5]	-for linux



windowant

ANT_HOME    C:/ apache-ant-1.8.1
D:\DevWork\1114to1119_wk47\apache-ant-1.9.7

path             C:/ apache-ant-1.8.1/bin
%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;C:\Program Files\nodejs\;C:\Program Files\Git\cmd;%MAVEN_HOME%\bin;%ANT_HOME%\bin;

classpath      C:/apache-ant-1.8.1/lib
E:\01WangSongLesson\00eclipse\jre\lib;D:\DevWork\1114to1119_wk47\apache-ant-1.9.7;


-------------
      ANT_HOMEC:\apache-ant-1.8.1
      PATH%ANT_HOME%\bin dos
      C:/ apache-ant-1.8.1/bin

ant

ant

->->cmdant



Buildfile: build.xml does not exist!

Build failed
antantbuild.xml

ant  -version




'ant' 

 




(1)Dbuild.xml

1<?xml version="1.0" encoding="GBK"?>
2<project name="" default="copyfile" basedir="." >
3   <target name="copyfile">
4      <copy file="d:/a.txt" todir="e:/Temp" overwrite="true" />
5   </target>
6</project>

2Da.txt
3dos
         d:
         ant
         
         E:/Tempaa.txta.txt
=outlog
C:\Documents and Settings\Administrator>d:

D:\>ant
Buildfile: D:\build.xml

copyfile:
     [copy] Copying 1 file to e:\Temp

BUILD SUCCESSFUL
Total time: 1 second
=outlog		
 
dos_
type:typeE:\\test.txt():,typetest.txt:dos...		 
-------------
in endof ant

applicationCreatorHosted ModeGWT



...........
http://www.gwtproject.org/gettingstarted.html
Windows
cd gwt-2.7.0
webAppCreator -out MyWebApp com.mycompany.mywebapp.MyWebApp


=outlog
D:\DevWork\1114to1119_wk47\gwt-2.8.0>webAppCreator -out MyWebApp com.mycompany.m
ywebapp.MyWebApp
Generating from templates: [sample, eclipse, readme, ant]
Not creating tests because -junit argument was not specified.

Created directory MyWebApp
Created directory MyWebApp\src
Created directory MyWebApp\src\com\mycompany\mywebapp
Created directory MyWebApp\src\com\mycompany\mywebapp\client
Created directory MyWebApp\src\com\mycompany\mywebapp\server
Created directory MyWebApp\src\com\mycompany\mywebapp\shared
Created directory MyWebApp\test
Created directory MyWebApp\test\com\mycompany\mywebapp
Created directory MyWebApp\war
Created directory MyWebApp\war\WEB-INF
Created file MyWebApp\src\com\mycompany\mywebapp\MyWebApp.gwt.xml
Created file MyWebApp\src\com\mycompany\mywebapp\client\GreetingService.java
Created file MyWebApp\src\com\mycompany\mywebapp\client\GreetingServiceAsync.jav
a
Created file MyWebApp\src\com\mycompany\mywebapp\client\MyWebApp.java
Created file MyWebApp\src\com\mycompany\mywebapp\server\GreetingServiceImpl.java

Created file MyWebApp\src\com\mycompany\mywebapp\shared\FieldVerifier.java
Created file MyWebApp\war\WEB-INF\web.xml
Created file MyWebApp\war\MyWebApp.css
Created file MyWebApp\war\MyWebApp.html
Created file MyWebApp\war\favicon.ico
Created file MyWebApp\.classpath
Created file MyWebApp\.project
Created file MyWebApp\MyWebApp.launch
Created file MyWebApp\README.txt
Created file MyWebApp\build.xml

=outlog
Run locally in development mode

To run your newly created application in development mode:
cd MyWebApp/
ant devmode
=outlog ant devmode
D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp>ant devmode
Buildfile: D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\build.xml

libs:
    [mkdir] Created dir: D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\WEB-I
NF\lib
     [copy] Copying 1 file to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\
WEB-INF\lib
     [copy] Copying 1 file to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\
WEB-INF\lib

javac:
    [mkdir] Created dir: D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\WEB-I
NF\classes
    [javac] D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\build.xml:31: warning:
 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to
false for repeatable builds
    [javac] Compiling 5 source files to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyW
ebApp\war\WEB-INF\classes
     [copy] Copying 1 file to D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\
WEB-INF\classes

devmode:
     [java] Super Dev Mode starting up
     [java]    workDir: C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\gwt-codeserver-651723
3477508306588.tmp
     [java] 2016-11-13 12:45:05.750:INFO::main: Logging initialized @17953ms
     [java]    Loading Java files in com.mycompany.mywebapp.MyWebApp.

	 
	 
	 in outlog
	      [java]    Module setup completed in 29688 ms
     [java] 2016-11-13 12:49:06.390:INFO:oejs.Server:main: jetty-9.2.z-SNAPSHOT
     [java] 2016-11-13 12:49:07.171:INFO:oejsh.ContextHandler:main: Started o.e.
j.s.ServletContextHandler@1d53f2e{/,null,AVAILABLE}
     [java] 2016-11-13 12:49:09.031:INFO:oejs.ServerConnector:main: Started Serv
erConnector@1e242e6{HTTP/1.1}{127.0.0.1:9876}
     [java] 2016-11-13 12:49:09.031:INFO:oejs.Server:main: Started @261250ms
     [java]
     [java] The code server is ready at http://127.0.0.1:9876/
     [java] 2016-11-13 12:49:12.453:INFO:oejs.Server:main: jetty-9.2.z-SNAPSHOT
     [java] 2016-11-13 12:49:22.015:INFO:oejsh.ContextHandler:main: Started c.g.
g.d.s.j.WebAppContextWithReload@1c2de91{/,file:/D:/DevWork/1114to1119_wk47/gwt-2
.8.0/MyWebApp/war/,AVAILABLE}{D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war}

     [java] 2016-11-13 12:49:22.140:INFO:oejs.ServerConnector:main: Started Serv
erConnector@102fec3{HTTP/1.1}{127.0.0.1:8888}
     [java] 2016-11-13 12:49:22.140:INFO:oejs.Server:main: Started @274359ms

>>>>>>>>>>>>
http://127.0.0.1:8888/
Compiling mywebapp
	
	
	Web Application Starter Project
	
	in outlog=
	Sending name to the server:
GWT User

Server replies:
Hello, GWT User!

I am running jetty/9.2.z-SNAPSHOT.

It looks like you are using:
Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36
	end in outlog=
	
	http://127.0.0.1:9876/mywebapp/
	
	in web outlog=
		mywebapp (GWT Code Server)

Messages from the last time this module was compiled.

Source from the last time this module was compiled.

Output Files

(From the last successful compile.)

AF57087D859AB46CB3FD95369AC7099E.cache.js
clear.cache.gif
compilation-mappings.txt
EDE2AF6509597DC70F62D0E11AA4E732.gwt.rpc
mywebapp.devmode.js
mywebapp.nocache.js
mywebapp.recompile.nocache.js
	end in web outlog=
	
=outlog

This command starts GWTs development mode server, a local server used for development and debugging, as follows:

Screenshot
Launch the local server in a browser by either 1) clicking Launch Default Browser or 2) clicking Copy to Clipboard (to copy its URL), then pasting into Firefox, Internet Explorer, Chrome, or Safari.

The starter application will load in Super Dev Mode as follows:


Make a few changes

The source code for the starter application is in the MyWebApp/src/ subdirectory, where MyWebApp is the name you gave to the project above. Youll see two packages, com.mycompany.mywebapp.client and com.mycompany.mywebapp.server. Inside the client package is code that will eventually be compiled to JavaScript and run as client code in the browser. The java files in the server package will be run as Java bytecode on a server, in the case of this Quick Start on the App Engine servers.

Look inside com/mycompany/mywebapp/client/MyWebApp.java. Line 41 constructs the Send button.
D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\src\com\mycompany\mywebapp\client

final Button sendButton = new Button("Send");
Change the text from Send to Send to Server.

final Button sendButton = new Button("Send to Server");
Now, save the file and simply click Refresh in your browser to see your change. The button should now say Send to Server instead of Send:

Compile and run in production mode

To run the application as JavaScript in what GWT calls production mode, compile the application by executing:

ant build

in outlog=
     [java]    Resolving java.util.function.ToLongBiFunction
     [java]       Found type 'java.util.function.ToLongBiFunction'
     [java]          [WARN] Ignoring unresolvable annotation type java.lang.Func
tionalInterface
     [java]    Compiling 5 permutations
     [java]       Compiling permutation 0...
     [java]       Compiling permutation 1...
     [java]       Compiling permutation 2...
     [java]       Compiling permutation 3...
     [java]       Compiling permutation 4...
     [java]    Compile of permutations succeeded
     [java]    Compilation succeeded -- 83.563s
     [java] Linking into D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war\myweb
app
     [java]    Link succeeded
     [java]    Linking succeeded -- 0.922s

build:

BUILD SUCCESSFUL
Total time: 1 minute 43 seconds

D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp>

and inoutlog=
The build Ant target invokes the GWT compiler which generates a number of JavaScript and HTML files from the MyWebApp Java source code in the MyWebApp/war/ subdirectory. To see the application, open the file MyWebApp/war/MyWebApp.html in your web browser. The application should look identical to the development mode above.

Congratulations! Youve created your first web application using GWT. Since youve compiled the project, youre now running pure JavaScript and HTML that works in IE, Chrome, Firefox, Safari, and Opera. You could now deploy your application to production by serving the HTML and JavaScript files in your MyWebApp/war/ directory from your web servers.
D:\DevWork\1114to1119_wk47\gwt-2.8.0\MyWebApp\war

Set up an IDE

Now that youve created your first app, you probably want to do something a bit more interesting. But first, if you normally work with an IDE youll want to set up Eclipse to use the GWT SDK:

Set up Eclipse

If you are going to stick with the command line, check out Speed Tracer and then head over to Build a Sample GWT App.
.........

in getfrom google plungin for eclipse Quick Start
.........................
Quick Start

This guide walks you through creating and deploying your first web application. For more details, please see the User's Guide.

Installing the plugin
Creating your first Web Application
Running your Web Application locally
Deploying your Web Application
App Engine does not yet support Java 8. You can build with version 8 of the JDK locally if and only if you set the Compiler compliance level for your project to Java 1.7. You cannot deploy an application that requires Java 8 to App Engine.

You can install the Google Plugin for Eclipse using the software update feature of Eclipse. Be sure to use the plugin that corresponds to your version of Eclipse. Follow the installation instructions provided at the links below or, if you are familiar with installing Eclipse plugins, you can simply paste the appropriate plugin link directly into Eclipse.

Eclipse version	Installation instructions	Direct plugin link
Eclipse 4.6 (Neon)	Plugin for Eclipse 4.6 (Neon)	https://dl.google.com/eclipse/plugin/4.6
Eclipse 4.5 (Mars)	Plugin for Eclipse 4.5 (Mars)	https://dl.google.com/eclipse/plugin/4.5
Eclipse 4.4 (Luna)	Plugin for Eclipse 4.4 (Luna)	https://dl.google.com/eclipse/plugin/4.4
If you are looking for older versions of the plugin, click here.

If you are having trouble installing from the update sites (due to firewall issues, for instance), you can install the Google Plugin for Eclipse by downloading and installing an archive of the update site.

Creating your first Web Application

To create your first Web Application, select File > New > Web Application Project from the Eclipse menu.

In the New Web Application Project wizard, enter a name for your project and a java package name, e.g., com.example.mywebapp. You can specify a project ID or choose not to (see Setting Project ID in New Web Application Project wizard for more details). Click Finish.

Note: Using Java keywords as a project name (e.g. "New" and "Class") will result in various build errors. Avoid these where possible.

Congratulations, you now have an App Engine and GWT-enabled web application!

Running your Web Application locally

Right-click on your web application project and select Debug As > Web Application from the popup menu. You are testing your application using the Java Development Server.

This action creates an Eclipse Web Application launch configuration for you and launches it. The web application launch configuration will start a server, whose URL will appear in the Development Mode view at the bottom of the Eclipse window. Select the URL and click Copy in the context menu, and then open it in your web browser to load the application.

At this point, you can set breakpoints, inspect variables and modify code as you would normally expect from a Java Eclipse debugging session.

Deploying your Web Application

To deploy your web application, you need to create an App Engine project (not to be confused with the Eclipse project) in the Google Developers Console. If you already have an App Engine project, then you can skip this step.

Once you have an App Engine project ID, right-click on your Eclipse project, and select Google > App Engine Settings... from the context menu. Enter your project ID into the Project ID text box. Click OK.

Right-click on your project and select Google > Deploy to App Engine. If you haven't already signed in using your Google account, you will be prompted to do so. See Sign In for more details.

Click Deploy.

Go to http://project-id.appspot.com/ to see your application.
........................
in endof google plungin for eclipse Quick Start





in getfrom Google Plugin for Eclipse 4.5 (Mars) Installation Instructions
........................
https://developers.google.com/eclipse/docs/install-eclipse-4.5

Google Plugin for Eclipse 4.5 (Mars) Installation Instructions

This procedure installs the Google Plugin for Eclipse and optionally the Android Developer Tools, the GWT SDK, and the Google App Engine SDK. If you are not running Eclipse version 4.5 (Mars), please consult Downloading and Installing the Plugin for the correct plugin version to use.

Start Eclipse, running JVM version 1.7.0 or later.
Select Help > Install New Software... In the dialog that appears, enter the update site URL into the Work with text box:

https://dl.google.com/eclipse/plugin/4.5

And press the enter key.

The required component is Google Plugin for Eclipse. Select the checkbox next to Google Plugin for Eclipse 4.4/4.5/4.6.
If you want to install the Android Developer Tools, select the checkbox next to Developer Tools.
If you want to install the Google App Engine Java SDK, select the checkbox next to Google App Engine Engine Java SDK.
If you want to install the developer tooling for Cloud Endpoints and Android, select the checkboxes next to Developer Tools and Google App Engine Tools for Android.
If you want to install the Maven Integration for Google App Engine, select the checkbox next to Google App Engine Maven Integration.
See Importing an existing Maven Project for more information.

Note: If you are installing the plugin on a multi-user install of Eclipse, please see this FAQ entry. 

Installing the SDKs is optional; you can always install them later on. 

If you are having trouble installing from the update site, please see this FAQ entry.

Click Next.
Review the features that you are about to install. Click Next.
Read the license agreements and then select I accept the terms of the license agreements. Click Finish.

Click OK on the Security Warning.

You will then be asked if you would like to restart Eclipse. Click Restart Now.
xxxxxxxxxxxxx
An internal error occurred during: "Initializing Java Tooling".
java.lang.NullPointerException
xxxxxxxxxxxxx

Now you are ready to build App Engine web applications and mobile backends for your Android applications. If you encountered issues during the installation, please see the FAQ.

..........................
in endof Google Plugin for Eclipse 4.5 (Mars) Installation Instructions

in getfrom Google Plugin for Eclipse Creating a New Web Application
..........................
Creating a New Web Application

Launching the New Web Application Wizard

To create a new project, click on the  New Web Application Project toolbar button. You can also access this wizard by selecting the Web Application Project item from the drop-down menu associated with the  New toolbar button, or by selecting File > New > Web Application Project.

Creating a Project with the New Web Application Wizard

The New Web Application Project wizard allows you to create a new web application that uses GWT and/or Google App Engine:

>>>>>>>>>>MyTestProject
com.huangyong.gwt


The wizard allows you to choose a name and root package for the project. The project's name will be used when generating the names of the classes in the sample application. All of the classes will live in a subpackage of the root package.

Note: Using Java keywords as a project name (e.g. "New" and "Class") will result in various build errors. Avoid these where possible.

In the Google SDKs group box, you can choose which SDKs that you'd like to use in your Web Application. See Using SDKs for more details.

----------Help->Install New Software->"already installed"

In the Identifiers for Google App Engine group box, you can choose to specify a project ID or choose to leave the project ID field blank. See Setting Project ID in New Web Application Project wizards for more details.

Click on the Finish button to create the project.

Generated Project Structure

The sample application generated by the New Web Application Wizard will have a src/ directory for Java source files and a war/ directory for compiled classes, server runtime libraries, static content, and configuration files.

The generated files will differ depending on whether your application is using GWT, App Engine, or both. The sections below highlight the differences between the generated sample for a project named MyTestProject with a root package of com.mytestproject.

If you make a mistake and delete some of the essential resources in the war directory, don't worry! You can easily fix these problems.

GWT

These are the files that are generated for the GWT sample:

MyTestProject
  src/
    com/
      mytestproject/
        MyTestProject.gwt.xml        
        client/
          GreetingService.java
          GreetingServiceAsync.java
          MyTestProject.java      
        server/
          GreetingServiceImpl.java
  war/  
    MyTestProject.css
    MyTestProject.html
    WEB-INF/
      web.xml
      classes/
      lib/
       ...GWT JARs...         
The GWT sample application consists of a simple user interface with a single button. When you press the button, a Remote Procedure Call is performed to get the current time on the server. The results of the call are then displayed in the interface. See GWT's documentation for more information about the project's contents.

App Engine

These are the files that are generated for the App Engine sample:

MyTestProject
  src/
    log4j.properties
    META-INF/
      jdoconfig.xml
    com/
      mytestproject/
        MyTestProjectServlet.java
  war/  
    index.html
    WEB-INF/
      appengine-web.xml
      web.xml
      logging.properties
      classes/
      lib/
       ...App Engine JARs...            
The App Engine sample application consists of a servlet which prints "Hello, World!". The application also has some configuration files for deployment and logging.

GWT + App Engine

When using both the GWT and App Engine SDKs, the following sample application is generated:

MyTestProject
  src/
    log4j.properties
    META-INF/
      jdoconfig.xml
    com/
      mytestproject/
        MyTestProject.gwt.xml        
        client/
          GreetingService.java
          GreetingServiceAsync.java
          MyTestProject.java      
        server/
          GreetingServiceImpl.java
  war/  
    MyTestProject.css
    MyTestProject.html
    WEB-INF/
      appengine-web.xml
      web.xml
      logging.properties
      classes/
      lib/
        ...App Engine JARs...    
        ...GWT JARs... 
The GWT + App Engine sample application is similar in functionality to the GWT sample application. The main difference is that the server component is meant to run on App Engine, so the App Engine configuration files are generated as well.
..............................
in endof Google Plugin for Eclipse Creating a New Web Application


in getfrom Google Plugin for Eclipse Running and Debugging
....................
Running and Debugging

Creating a Launch Configuration

If you created a project using the New Web Application Wizard, a launch configuration will have already been created for you. It can be found by navigating to the Launch Configuration dialog. Select the Run Configurations... item from the drop-down menu associated with the  Run toolbar button:

xxxxxxxxxxxx
Runing CodeServer with parameters: [-noprecompile, -port, 9876, -sourceLevel, 1.7, -bindAddress, 127.0.0.1, -launcherDir, D:\eclipse_jee\MyTestProject2\war, -logLevel, INFO, com.huangyong.gwt.MyTestProject2]
Super Dev Mode starting up
   workDir: C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\gwt-codeserver-2982398748530107542.tmp
Initializing App Engine server
   Loading Java files in com.huangyong.gwt.MyTestProject2.
 13, 2016 5:59:48  com.google.appengine.tools.info.RemoteVersionFactory getVersion
: Unable to access http://appengine.google.com/api/updatecheck?runtime=java&release=1.9.34&timestamp=1455219375&api_versions=['1.0']
java.net.ConnectException: Connection timed out: connect
	at java.net.TwoStacksPlainSocketImpl.socketConnect(Native Method)
	at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)
	at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)
	at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)
	at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)
	at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
	at java.net.Socket.connect(Socket.java:579)
	at java.net.Socket.connect(Socket.java:528)
	at sun.net.NetworkClient.doConnect(NetworkClient.java:180)
	at sun.net.www.http.HttpClient.openServer(HttpClient.java:432)
	at sun.net.www.http.HttpClient.openServer(HttpClient.java:527)
	at sun.net.www.http.HttpClient.<init>(HttpClient.java:211)
	at sun.net.www.http.HttpClient.New(HttpClient.java:308)
	at sun.net.www.http.HttpClient.New(HttpClient.java:326)
	at sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:997)
	at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:933)
	at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:851)
	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1301)
	at java.net.URL.openStream(URL.java:1037)
	at com.google.appengine.tools.info.RemoteVersionFactory.getVersion(RemoteVersionFactory.java:76)
	at com.google.appengine.tools.info.UpdateCheck.getApplicationVersionInfo(UpdateCheck.java:153)
	at com.google.appengine.tools.info.UpdateCheck.maybePrintNagScreen(UpdateCheck.java:361)
	at com.google.appengine.tools.development.gwt.AppEngineLauncher.maybePerformUpdateCheck(AppEngineLauncher.java:115)
	at com.google.appengine.tools.development.gwt.AppEngineLauncher.start(AppEngineLauncher.java:81)
	at com.google.gwt.dev.DevMode.doStartUpServer(DevMode.java:632)
	at com.google.gwt.dev.DevModeBase.startUp(DevModeBase.java:1054)
	at com.google.gwt.dev.DevModeBase.run(DevModeBase.java:836)
	at com.google.gwt.dev.DevMode.main(DevMode.java:413)

 13, 2016 6:00:10  com.google.appengine.tools.development.SystemPropertiesManager setSystemProperties
: Overwriting system property key 'java.util.logging.config.file', value 'E:\01WangSongLesson\00eclipse\plugins\com.google.appengine.eclipse.sdkbundle_1.9.34\appengine-java-sdk-1.9.34\config\sdk\logging.properties' with value 'WEB-INF/logging.properties' from 'D:\eclipse_jee\MyTestProject2\war\WEB-INF\appengine-web.xml'
 13, 2016 6:00:23  com.google.apphosting.utils.jetty.JettyLogger info
: Logging to JettyLogger(null) via com.google.apphosting.utils.jetty.JettyLogger

xxxxxxxxxxxx
http://127.0.0.1:8888/MyTestProject2.html

If you're interested in debugging your application, select the Debug Configurations... item from the drop-down menu associated with the  Debug toolbar button.

Tip: You can also launch your application by right-clicking the project (or an HTML or JSP page within the project) and selecting Run As/Debug As > Web Application from the context menu.

Now, expand the items underneath the Web Application category. You should see a launch configuration with a name matching your project name. Click on the launch configuration.



Notice that the Web Application launch configuration has the Main, Server, GWT, App Engine, and Arguments tabs. The Main tab allows you to choose the project that is associated with the launch configuration and change the main class for the launch. The Server tab allows you to choose a different port for the built-in server. In general, you'll want to run the built-in server, unless you have a specific server instance that you want to test against.

GWT Settings

The GWT settings tab contains the GWT settings for the launch configuration.



In addition to customizing the log level, you can also tweak the set of Available Modules for the launch. All modules you want to access during the Development Mode launch must be included in this list (excluding any inherited modules). The actual set of modules that will be loaded at startup will be determined by the HTML page you launch with (more on this later).

Additional Arguments

If you need to change settings that are not represented on the Main, Server, GWT, or App Engine tabs, you can switch to the Arguments tab and enter them alongside the computed arguments.

Running the Launch Configuration

To launch the web application, click on the Run button in the lower-right corner of the Run Configurations dialog. You can also run your application via context menu shortcuts. To do this, select either a project, a GWT Module file, or an HTML/JSP page in the project's WAR directory. Then, run the application by navigating to Run As > Web Application. Notice that after you run the launch configuration, it will appear in the Run shortcut list:



GWT and GWT + App Engine Applications

If your project uses GWT, the development mode view will appear shortly after launching the application:



Notice that your launch configuration is listed in the view, along with some suggested URLs to start up your GWT application. Copy the URL for your application into the browser's address bar by selecting the entry and choosing Copy from the context menu. Once you have navigated to the startup URL in your browser, you'll notice that a browser entry will be added to the launch configuration:



After a few seconds, you'll notice that loading messages for the GWT modules in your application will appear in the view, indicating that your GWT Application is starting up. Finally, you'll see your application appear in the browser window.

The development mode view is useful for troubleshooting problems with your GWT application. By turning up the log level for the launch configuration, you can see more detailed information about your application's execution. You can search for text within a log by using the filter text field.

When using the view, don't forget about the view's toolbar, which can be used to switch the layout of the view, terminate a launch, clear terminated launch configurations, and restart the embedded web server. The alternate layout presents the launch configurations and browsers in a tree, with browsers as children of their associated launch configuration.

If your project uses Google App Engine and GWT, the only difference is that the embedded server is actually the Google App Engine development server.

Note: If your application uses GWT and you make change to your code during a debugging session, you may need to click Refresh in your browser or Restart Server in the development mode view. See the GWT documentation on development mode debugging for more details.

App Engine-only Applications

If your application uses App Engine but not GWT, the only indication that the App Engine development server is running will be output in the Console view. App Engine-only launches will not appear in the development mode view. The console output includes the URL of the server, which by default is http://localhost:8888/. You can change the port number via Eclipse's launch configuration dialog by selecting your Web Application launch and editing the Port value on the Main tab.

If you open a web browser and navigate to the server's address you should see a welcome page with links to any servlets defined by the application.


..................
in endof Google Plugin for Eclipse Running and Debugging

 >>>>>>>>>>>>>
 @java -cp "%~dp0\gwt-user.jar;%~dp0\gwt-dev.jar" com.google.gwt.user.tools.WebAppCreator %*
 
	webAppCreator.cmd -eclipse GWTLogon -out GWTLogon com.jpleausre.gwt.logon.client.GWTLogon
	
	xxxxxxxxxxxx
	D:\DevWork\1114to1119_wk47\gwt-2.8.0>webAppCreator.cmd -eclipse GWTLogon -out GW
TLogon com.jpleausre.gwt.logon.client.GWTLogon
Unknown argument: -eclipse
Google Web Toolkit 2.8.0
WebAppCreator [-[no]overwriteFiles] [-[no]ignoreExistingFiles] [-templates templ
ate1,template2,...] [-out dir] [-junit pathToJUnitJar] [-[no]maven] [-[no]ant] m
oduleName

where
  -[no]overwriteFiles       Overwrite any existing files. (defaults to OFF)
  -[no]ignoreExistingFiles  Ignore any existing files; do not overwrite. (defaul
ts to OFF)
  -templates                Specifies the template(s) to use (comma separeted).
Defaults to 'sample,ant,eclipse,readme'
  -out                      The directory to write output files into (defaults t
o current)
  -junit                    Specifies the path to your junit.jar (optional)
  -[no]maven                DEPRECATED: Create a maven2 project structure and po
m file (default disabled). Equivalent to specifying 'maven' in the list of templ
ates. (defaults to OFF)
  -[no]ant                  DEPRECATED: Create an ant configuration file. Equiva
lent to specifying 'ant' in the list of templates. (defaults to OFF)
and
  moduleName                The name of the module to create (e.g. com.example.m
yapp.MyApp)

	xxxxxxxxxxxx
	
	webAppCreator.cmd  -out GWTLogon com.jpleausre.gwt.logon.client.GWTLogon
	

C://Java/gwt-windows-1.4.59>applicationCreator.cmd -eclipse GWTLogon -out GWTLogon com.jpleausre.gwt.logon.client.GWTLogon
Created directory GWTLogon/src
Created directory GWTLogon/src/com/jpleausre/gwt/logon
Created directory GWTLogon/src/com/jpleausre/gwt/logon/client
Created directory GWTLogon/src/com/jpleausre/gwt/logon/public
Created file GWTLogon/src/com/jpleausre/gwt/logon/GWTLogon.gwt.xml
Created file GWTLogon/src/com/jpleausre/gwt/logon/public/GWTLogon.html
Created file GWTLogon/src/com/jpleausre/gwt/logon/client/GWTLogon.java
Created file GWTLogon/GWTLogon.launch
Created file GWTLogon/GWTLogon-shell.cmd
Created file GWTLogon/GWTLogon-compile.cmd

 

GWTLogon-shell.cmdGWTGoogle Web Toolkit Development Shell


Host Mode



 Click Me Hello World 
projectCreatoranteclipseGWT



C://Java/gwt-windows-1.4.59>projectCreator.cmd -ant GWTLogon -eclipse GWTLogon -out GWTLogon
Created directory GWTLogon/src
Created directory GWTLogon/test
Created file GWTLogon/GWTLogon.ant.xml
Created file GWTLogon/.project
Created file GWTLogon/.classpath

 

GWTLogon.ant.xml

 <?xml version="1.0" encoding="utf-8" ?>
<project name="GWTLogon" default="compile" basedir=".">
  <description>
    GWTLogon build file.  This is used to package up your project as a jar,
    if you want to distribute it.  This isn't needed for normal operation.
  </description>

  <!-- set classpath -->
  <path id="project.class.path">
    <pathelement path="${java.class.path}/"/>
    <pathelement path="C://Java/gwt-windows-1.4.59/gwt-user.jar"/>
    <!-- Additional dependencies (such as junit) Go here -->
  </path>

  <target name="compile" description="Compile src to bin">
    <mkdir dir="bin"/>
    <javac srcdir="src:test" destdir="bin" includes="**" debug="on" debuglevel="lines,vars,source" source="1.4">
      <classpath refid="project.class.path"/>
    </javac>
  </target>

  <target name="package" depends="compile" description="Package up the project as a jar">
    <jar destfile="GWTLogon.jar">
      <fileset dir="bin">
        <include name="**/*.class"/>
      </fileset>
      <!-- Get everything; source, modules, html files -->
      <fileset dir="src">
        <include name="**"/>
      </fileset>
      <fileset dir="test">
        <include name="**"/>
      </fileset>
    </jar>
  </target>

  <target name="clean">
    <!-- Delete the bin directory tree -->
    <delete file="GWTLogon.jar"/>
    <delete>
      <fileset dir="bin" includes="**/*.class"/>
    </delete>
  </target>

  <target name="all" depends="package"/>

</project>


 

applicationCreatorprojectCreator

applicationCreatorsrcDemoprojectCreatorDemosrctest

applicationCreatorGWTLogon-shell.cmdGWTGWTLogon-compile.cmdprojectCreator

applicationCreatoreclipse launchprojectCreator.classpath.project

 

projectCreatorprojectprojectCreatorimporteclipse

applicationCreatorJavaeclipse launch

 

EclipseGWT

 


 



projectCreator 
eclipseant

 

applicationCreator 


 

junitCreator 
JUnitCase

 

i18nCreator

i18nJavascript


benchmarkViewer 
benchmark

 



GWT

 


GWT Java-to-JavaScript Compiler
JavaJavaScriptGWT CompilerGWTWeb 
GWT Hosted Web Browser
GWT Hosted Web BrowerHostedHostedJavaJavaScriptHostedDebug

JRE emulation library
JREJavaScriptJavajavagwtjava.langjava.util
GWT Web UI class library
GWT Web UIweb GWTUI

 

 


Web

WebGWTGWTWeb

GWTwebLayout

 




ButtonRadionButtonPushButtonToggleButtonCheckBoxTextBoxPasswordBox

TextArea, HyperLink,ListBox,MenuBar,Tree,Table, TabBar,DialogBox, PopupPanel

RichTextArea, DisclosurePanel, SuggestBox


Layout 

Stackpanel,HorizontalPanel,VerticalPanel, FlowPanel, VerticalSplitPanel, HorizontalSplitPanel,

DockPanel, TabPanel,

 

Event & Listener
Textbox

Click MeClickClickonClick(Widget sender)

senderonClickHello Worldjavascriptalert

 Button b = new Button("Click Me");
 b.addClickListener(new ClickListener() {
  public void onClick(Widget sender) {
    Window.alert("Hello World");
  }
});

Listener

ChangeListener 
ClickListener 
FocusListener
KeyboardListener
MouseListener
MouseWheelListener
PopupListener
ScrollListener
TableListener
TreeListener

RPC

    

GWTHTML

GWTServiceServiceServiceServiceAsyncServiceImpl

Login

 

// 

public interface LoginService extends RemoteService {
    public boolean login(LoginSO login) throws ApplicationException;
}


// 

public interface LoginServiceAsync {
    void login(LoginSO login, AsyncCallback async);
}


// 

 public class LoginServiceImpl extends RemoteServiceServlet implements LoginService {
    public boolean login(LoginSO login) throws ApplicationException {
        ...

        return true; 

    }
}

 

clientserver

 



 

LoginServiceAsync ourInstance = (LoginServiceAsync) GWT.create(LoginService.class); // 
((ServiceDefTarget) ourInstance).setServiceEntryPoint(GWT.getModuleBaseURL() + "/LoginService"); // 


ourInstance.login(loginSO, new AsyncCallback() {   //

    public void onFailure(Throwable caught) {         //
        if(caught instanceof InvocationException) {
            // system exception
        } else {
            Window.alert(" " + GWTShowConstants.Messages.constants.maxQueryCount());
            // aplication exception
        }

    }

    public void onSuccess(Object result) {            //
        Window.alert("success");
    }

});

 

// 

 

 

 skeleton

 

 

 

 

 

 

    

Service

GWTJavaScriptJavaJavaScriptJava



 

 

1 char, byte, short, int, long, boolean, float, double;

2 Stringjava.util.Date  Character, Byte, Short, Integer, Long, Boolean, Float, or Double;

3 45

4 

5 

 

4

IsSerializable

transientfinalGWTtransient

 



GWTType 

GWT JDK 5.0 

 

//

public class MyClass implements IsSerializable {


  /**
   * SetString
   * 
   * @gwt.typeArgs <java.lang.String>
   */
  public Set setOfStrings;

  /**
   * MapKeyValueString
   * 
   * @gwt.typeArgs <java.lang.String,java.lang.String>
   */
  public Map mapOfStringToString;
}


// 
public interface MyService extends RemoteService {
  /**

   * cListInteger
   * ListString
   * 
   * @gwt.typeArgs c <java.lang.Integer>
   * @gwt.typeArgs <java.lang.String>
   */
  List reverseListAndConvertToStrings(List c);
}


 

 

    







 

 onFailureThrowable caughtcaught

caughtInvocationExceptioncaught

 

JavaScriptJavaException

GWTExceptionSerializableException

public class ApplicationException extends SerializableException {
    public ApplicationException() {
        super();
    }

    public ApplicationException(String msg) {
        super(msg);
    }

    public Throwable getCause() {
        return super.getCause();
    }

    public String getMessage() {
        return super.getMessage(); 
    }

    public Throwable initCause(Throwable cause) {
        return super.initCause(cause);
    }
}

 



GWT



JavaScript

 

JUnit

@TODO

 




     Java

PropertiesString



     GWTGWTcom.google.gwt.i18n.client.Constants



    GWT

Constants

public interface NumberFormatConstants extends Constants {
  /**
   * @return the localized decimal separator
   */
  String decimalSeparator();

  /**
   * @return the localized thousands separator
   */
  String thousandsSeparator();
}




#NumberFormatConstants.properties

decimalSeparator = ,
thousandsSeparator = .

 



public void useNumberFormatConstants() {
  NumberFormatConstants constants = (NumberFormatConstants) GWT.create(NumberFormatConstants.class);
  String decimalSep = constants.decimalSeparator();
  String thousandsSep = constants.thousandsSeparator();
  String msg = "Decimals are separated using '" + decimalSep + "'";
  msg += ", and thousands are separated using '" + thousandsSep + "'";
  showMessage(msg);
}


GWT



GWT.create()

 



String decimalSeparator();  thousandsSeparator = .



 

 public interface NumberFormatConstantsWithAltKey extends Constants {
  /**
   * @gwt.key fmt.sep.decimal
   * @return the localized decimal separator
   */
  String decimalSeparator();

  /**
   * @gwt.key fmt.sep.decimal
   * @return the localized thousands separator
   */
  String thousandsSeparator();
}


@gwt.key fmt.sep.decimal key

#NumberFormatConstants.properties

fmt.sep.decimal = .
fmt.sep.thousands = ,


Constants

 

T methodName()

 

TT

T                        
String                        
String[]                     //'//,'  
int                            int 
float                         float 
double                      double 
boolean                     boolean"true"  "false"),  
Map                          Key-Value

 

Map

a = X
b = Y
c = Z
someMap = a, b, c

 

Map someMap{a:X, b:Y, c:Z}

ConstantsWithLookup

ConstantsWithLookupConstantsConstantsWithLookup

getBoolean(String)        boolean
getDouble(String)         double
getFloat(String)            float
getInt(String)              int
getMap(String)            Map
getString(String)          String
getStringArray(String)   String[]

ConstantsConstantsWithLookupConstantsJavaScript

GWT CompilerJavaScriptConstants

JavaScript

ConstantsWithLookupGWT Compiler

JavaScript

ConstantsWithLookup

Message

ConstantsConstantsWithLookup



    

MessageJavaPropertiesResourceBundleMessageFormat

 




public interface GameStatusMessages extends Messages {
  /**
   * @param username the name of a player
   * @param numTurns the number of turns remaining
   * @return a message specifying the remaining turns for a player
   */
  String turnsLeft(String username, int numTurns);

  /**
   * @param numPoints the number of points
   * @return a message describing the current score for the current player
   */
  String currentScore(int numPoints);
}

 


turnsLeft = Turns left for player ''{0}'': {1}
currentScore = Current score: {0}


public void beginNewGameRound(String username) {
  GameStatusMessages messages = (GameStatusMessages) GWT.create(GameStatusMessages.class);

  // Tell the new player how many turns he or she has left.
  int turnsLeft = computeTurnsLeftForPlayer(username);
  showMessage(messages.turnsLeft(username, turnsLeft));

  // Tell the current player his or her score.
  int currentScore = computeScore(username);
  setCurrentPlayer(username);
  showMessage(messages.currentScore(currentScore));
}



Message

    String methodName(optional-params)

MessageString

Constants(ConstantsWithLookup)Message
Constants
MessageString

ConstantsMessageUTF-8
Native2asciiutf-8
Javanative2ascii

JavaScript Native Interface
JavaScript Native Interface = JSNI
JSNIGWTJavaJavaScript


GWTJavaScriptJNIGWT




JavaJavaScript

JSNInativeJSNI/*-{

}-*/

public static native void alert(String msg) /*-{
  $wnd.alert(msg);
}-*/;

JavaWindowalert

Hosted Mode

 

JavaScriptJava




    [instance-expr.]@class-name::method-name(param-signature)(arguments)




    [instance-expr.]@class-name::field-name

[instance-expr.]

    

class-name

    

method-name

    


param-signature


    JavaClass
arguments
    



public class JSNIExample {

  String myInstanceField;
  static int myStaticField;

  void instanceFoo(String s) {
    // use s
  }

  static void staticFoo(String s) {
    // use s
  }

 


  // JavaScript

  // JavaScript


  public native void bar(JSNIExample x, String s) /*-{
    // instanceFoo
    this.@com.google.gwt.examples.JSNIExample::instanceFoo(Ljava/lang/String;)(s);

    // xinstanceFoo
    x.@com.google.gwt.examples.JSNIExample::instanceFoo(Ljava/lang/String;)(s);

    //  staticFoo()
    @com.google.gwt.examples.JSNIExample::staticFoo(Ljava/lang/String;)(s);

    // 
    var val = this.@com.google.gwt.examples.JSNIExample::myInstanceField;

    // x
    x.@com.google.gwt.examples.JSNIExample::myInstanceField = val + " and stuff";

    // Read static field (no qualifier)
    @com.google.gwt.examples.JSNIExample::myStaticField = val + " and stuff";
  }-*/;

}

 


JavaJavaScript

Java -> JavaScript

Java type                              JavaScript Type
numeric primitive                     a JavaScript numeric value, as in var x = 42;
String                                   a JavaScript string, as in var s = "my string";
boolean                                 a JavaScript boolean value, as in var b = true;
JavaScriptObject (see notes)    a JavaScriptObject that must have originated from JavaScript code, typically as the return value of some other JSNI method
Java array            an opaque value that can only be passed back into Java code
any other Java Object        an opaque value accessible through special syntax


 


JSNIJavaScriptExceptionJavaScript
JavaJavaScriptJavaJavaJavaScriptJavaScript

JSNIJava

1. Java method foo() calls JSNI method bar()
2. JavaScript method bar() calls Java method baz()
3. Java method baz() throws an exception
baz()barfoo

 

 

 

Host Model Web Model

Host ModelGWTJavaJavaScriptGWTJava bytecode

Web ModelHost ModelWeb Model

 

JavaJavaScript

JavaJavaScript

java -cp "%~dp0/src;%~dp0/bin;%~dp0/../../gwt-user.jar;%~dp0/../../gwt-dev-windows.jar" com.google.gwt.dev.GWTCompiler -out "%~dp0/www" %* com.google.gwt.sample.hello.Hello

 

-cp  ClassGWTjar

-out JavaScript

com.google.gwt.sample.hello.Hello Modulegwt.xmlentry-pointclient

 

Java

java -Xmx512m -Xms128m -cp "%~dp0/src;%~dp0/bin;%~dp0/../../gwt-user.jar;%~dp0/../../gwt-dev-windows.jar" com.google.gwt.dev.GWTCompiler -out "%~dp0/www" %* com.google.gwt.sample.hello.Hello

 

JavaScriptWebWEB-INF

 

gwt.xmlserviceServlet

<servlet path='/calendar' class='com.google.gwt.sample.dynatable.server.SchoolCalendarServiceImpl'/>

 

=>

 

<servlet>

     <servlet-name>Calendar</servlet-name>

     <servlet-class>com.google.gwt.sample.dynatable.server.SchoolCalendarServiceImpl</servlet-class>

</servlet>

 

<servlet-mapping>

     <servlet-name>Calendar</servlet-name>

     <url-pattern>/calendar</url-pattern>

</servlet-mapping>

 


 
Hosted Mode 

GWT Hosted Mode

ConnectionDriverManager



(Log4J)

GWTclientJavaScript
Log4j
Server

Login



 

src
    com
        jpleasure
            gwt
                logon
                      LogonDemo.gwt.xml                      GWT
                      
                    client                                         
                        LogonDemo.java                       GWT
                        LogonDemoController.java          
                        
                      exception                                
                            ApplicationException.java       
                            
                      panel                                      Panel
                            BasePanel.java                     Panel
                            LogonPanel.java                   Logon Panel
                            WelcomePanel.java               Welcome Panel
                            
                      service                                   
                            LogonService.java                
                            LogonServiceAsync.java        
                            
                      so                                          Serializable Object 
                              LogonSO.java                      Logon SO
                              
                    public                                        GWT HTML
                          LogonDemo.css                        CSS
                          LogonDemo.html                      HTML
                          
                    server                                         Service
                        service
                                LogonServiceImpl.java          Logon Service

 

// ApplicationException

package com.jpleasure.gwt.logon.client.exception;

import com.google.gwt.user.client.rpc.SerializableException;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:16:17
 * To change this template use File | Settings | File Templates.
 */
public class ApplicationException extends SerializableException {
    public ApplicationException() {
        super();
    }

    public ApplicationException(String msg) {
        super(msg); 
    }
}


//BasePanel

package com.jpleasure.gwt.logon.client.panel;

import com.google.gwt.user.client.ui.VerticalPanel;
import com.jpleasure.gwt.logon.client.LogonDemoController;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:01:14
 * To change this template use File | Settings | File Templates.
 */
public class BasePanel extends VerticalPanel {
    protected LogonDemoController ldc;

    public LogonDemoController getLdc() {
        return ldc;
    }

    public void setLdc(LogonDemoController ldc) {
        this.ldc = ldc;
    }
}


// LogonPanel

package com.jpleasure.gwt.logon.client.panel;

import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.rpc.AsyncCallback;
import com.google.gwt.user.client.ui.*;
import com.jpleasure.gwt.logon.client.service.LogonService;
import com.jpleasure.gwt.logon.client.service.LogonServiceAsync;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:35:13
 * To change this template use File | Settings | File Templates.
 */
public class LogonPanel extends BasePanel {
    private TextBox name;
    private PasswordTextBox password;
    private Button logonButton;

    public LogonPanel() {
        HorizontalPanel msgPanel = new HorizontalPanel();
        msgPanel.add(new Label("Please input logon information here!"));

        HorizontalPanel namePanel = new HorizontalPanel();
        Label nameLabel = new Label("Name:");
        nameLabel.setPixelSize(100, 20);
        namePanel.add(nameLabel);
        name = new TextBox();
        namePanel.add(name);

        HorizontalPanel pwdPanel = new HorizontalPanel();
        Label passwordLabel = new Label("Password:");
        passwordLabel.setPixelSize(100, 20);
        pwdPanel.add(passwordLabel);
        password = new PasswordTextBox();
        pwdPanel.add(password);

        HorizontalPanel btnPanel = new HorizontalPanel();
        logonButton = new Button("Logon");
        logonButton.addClickListener(new ClickListener() {

            public void onClick(Widget sender) {
                LogonServiceAsync logonService = LogonService.App.getInstance();
                LogonSO logonSO = new LogonSO();
                logonSO.setName(getName());
                logonSO.setPassword(getPassword());
                logonService.logon(logonSO, new AsyncCallback() {

                    public void onFailure(Throwable caught) {
                        Window.alert(caught.getMessage());
                    }

                    public void onSuccess(Object result) {
                        boolean isLogon = ((Boolean)result).booleanValue();
                        if(isLogon) {
                            ldc.gotoWelcome();
                        }                     else {
                            Window.alert("logon failed!");
                        }
                    }
                })  ;

            }
        });
        btnPanel.add(logonButton);

        this.add(msgPanel);
        this.add(namePanel);
        this.add(pwdPanel);
        this.add(btnPanel);
    }

    public String getName() {
        return this.name.getText();
    }

    public String getPassword() {
        return this.password.getText();
    }

}


// WelcomePanel

package com.jpleasure.gwt.logon.client.panel;

import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.ClickListener;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.Widget;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:49:53
 * To change this template use File | Settings | File Templates.
 */
public class WelcomePanel extends BasePanel {
    public WelcomePanel() {

        Label welcomeLabel = new Label("Welcome to LogonDemo!");
        this.add(welcomeLabel);

        Button logoutButton = new Button("Logout");
        logoutButton.addClickListener(new ClickListener() {

            public void onClick(Widget sender) {
                ldc.gotoLogon();
            }
        });

        this.add(logoutButton);
    }
}


//LogonService

package com.jpleasure.gwt.logon.client.service;

import com.google.gwt.core.client.GWT;
import com.google.gwt.user.client.rpc.RemoteService;
import com.google.gwt.user.client.rpc.ServiceDefTarget;
import com.jpleasure.gwt.logon.client.exception.ApplicationException;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:09
 * To change this template use File | Settings | File Templates.
 */
public interface LogonService extends RemoteService {
    /**
     * Utility/Convenience class.
     * Use LogonService.App.getInstance() to access static instance of LogonServiceAsync
     */
    public static class App {
        private static LogonServiceAsync ourInstance = null;

        public static synchronized LogonServiceAsync getInstance() {
            if (ourInstance == null) {
                ourInstance = (LogonServiceAsync) GWT.create(LogonService.class);
                ((ServiceDefTarget) ourInstance).setServiceEntryPoint(GWT.getModuleBaseURL() + "com.jpleasure.gwt.logon.LogonDemo/LogonService");
            }
            return ourInstance;
        }
    }

    public boolean logon(LogonSO logonSO) throws ApplicationException;
}


//LogonServiceAsync

package com.jpleasure.gwt.logon.client.service;

import com.google.gwt.user.client.rpc.AsyncCallback;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:09
 * To change this template use File | Settings | File Templates.
 */
public interface LogonServiceAsync {
    void logon(LogonSO logonSO, AsyncCallback async);
}

//   LogonSO  

package com.jpleasure.gwt.logon.client.so;

import com.google.gwt.user.client.rpc.IsSerializable;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:52
 * To change this template use File | Settings | File Templates.
 */
public class LogonSO implements IsSerializable {
    private String name;

    private String password;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
    
}
  

//  LogonDemo                       
package com.jpleasure.gwt.logon.client;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.user.client.ui.DeckPanel;
import com.google.gwt.user.client.ui.RootPanel;
import com.jpleasure.gwt.logon.client.panel.LogonPanel;
import com.jpleasure.gwt.logon.client.panel.WelcomePanel;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:34:12
 * To change this template use File | Settings | File Templates.
 */
public class LogonDemo implements EntryPoint {
    public void onModuleLoad() {
        DeckPanel mainPanel = new DeckPanel();
        LogonDemoController ldc = new LogonDemoController(mainPanel);

        LogonPanel logonPanel = new LogonPanel();
        logonPanel.setLdc(ldc);
        mainPanel.add(logonPanel);

        WelcomePanel welcomePanel = new WelcomePanel();
        welcomePanel.setLdc(ldc);
        mainPanel.add( welcomePanel );

        mainPanel.showWidget(0);

        RootPanel.get().add(mainPanel);
    }
}


// LogonDemoController

package com.jpleasure.gwt.logon.client;

import com.google.gwt.user.client.ui.DeckPanel;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 21:58:02
 * To change this template use File | Settings | File Templates.
 */
public class LogonDemoController {
    private DeckPanel mainPanel;

    public LogonDemoController(DeckPanel panel) {
        this.mainPanel = panel;
    }

    public void gotoWelcome() {
        if (mainPanel != null) {

            mainPanel.showWidget(1);
        }
    }

    public void gotoLogon() {
        if (mainPanel != null) {
            mainPanel.showWidget(0);
        }
    }
}

 

// LogonServiceImpl

package com.jpleasure.gwt.logon.server.service;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;
import com.jpleasure.gwt.logon.client.exception.ApplicationException;
import com.jpleasure.gwt.logon.client.service.LogonService;
import com.jpleasure.gwt.logon.client.so.LogonSO;

/**
 * Created by IntelliJ IDEA.
 * User: ma.zhao@dl.cn
 * Date: 2007-8-27
 * Time: 22:13:10
 * To change this template use File | Settings | File Templates.
 */
public class LogonServiceImpl extends RemoteServiceServlet implements LogonService {
    public boolean logon(LogonSO logonSO) throws ApplicationException {

        if (logonSO.getName() != null && logonSO.getName().length() > 0  &&
                logonSO.getPassword() != null && logonSO.getPassword().length() > 0 &&
                logonSO.getName().equals(logonSO.getPassword())) {
            return true;
        } else if ("ex".equals(logonSO.getName())) {
            throw new ApplicationException("Logon Exception!");

        } else {
            return false;
        }

    }
}
 

//LogonDemo.gwt.xml

<module>

    <inherits name='com.google.gwt.user.User'/>

    <entry-point class='com.jpleasure.gwt.logon.client.LogonDemo'/>

    <servlet path="/com.jpleasure.gwt.logon.LogonDemo/LogonService"
             class="com.jpleasure.gwt.logon.server.service.LogonServiceImpl"/>
</module>

 



http://groups.google.com/group/Google-Web-Toolkit/web/security-for-gwt-applications

GWTPanelPanelJavaScriptHtml

JavaScriptGWT

 JavaScriptimage

 

PanelActionJavaScriptPanelActionserver

Service

 

 

GWT



    Netbeans + gwt4nb

    http://www.javapassion.com/handsonlabs/ajaxgwtintro/

    GWT ShellHosted ModeJava Web GWT

    NB 5.5 JSPHTMLJavaScript

 

 

    Eclipse + Cypal Studio for GWT

    http://www.ibm.com/developerworks/library/os-eclipse-ajaxcypal/index.html

    Java Web GWTGWT ShellWeb

 



    Ingellij IDEA 6

    http://www.jetbrains.com/idea/training/demos/GWT.html

 

    Eclipse + GWT Builder

    http://www.instantiations.com/gwtdesigner/

 

 
=====================
endof GWT(Google Web Toolkit)


getfrom Git
============
http://blog.jobbole.com/78960/

Git

       Git

SVNGit

      SVN

      GitAA

windowsGit

      msysgit windowsGit,

     

  Git > Git Bash,

  

Git

 



 

  Git

   git config  global Git



     

     repository,GitGit

    D > www testgit

   

pwd 

      1.  git init git



     testgit.gitGitgit

    

      2. 

          txtGit1kb2kb

    demo

     testgit readme.txt 11111111

      git add readme.txt

    

   

    git commitGit

   

  readme.txtgit status

  

 readme.txt2222222222git status

 

 readme.txt

readme.txt

git diff readme.txt 

 

readme.txt11111111  22222222

readme.txt2(git add  git commit)



 



     readme.txt

33333333333333.

   

readme.txt git log 

  

    git log,333333.222222 111111. git log pretty=oneline 

  

    2git reset  hard HEAD^ HEAD^  HEAD^^ 100git reset  hard HEAD~100 readme.txt

  





 readme.txtcat readme.txt



git log 



 333333 333333

git reset  hard  3333333git reflog  



3333 6fcfc89.

git reset  hard 6fcfc89



 



     testgit(.git)

      (Repository).git,stage()Gitmaster,masterHEAD

Git

   git add 

  git commit

demo

readme.txt4444444test.txt test git status



git add 2git status



git commit



Git



    readme.txt 555555555555



5555555555555

addcommit

 git reset  hard HEAD^

2 git status 



Gitgit checkout   file 

git checkout    readme.txt,



 git checkout readme.txt readme.txt2

readme.txt 
readme.txt
demoreadme.txt 6666666666666git add 7777777

  

git checkout  readme.txt     



     testgitb.txt,

  

rmrm b.txt commit 

 

commit

 git checkout   b.txt



testgit3





     githubGitgithubSSH

     SSH Key.sshid_rsaid_rsa.pub

ssh-keygen  -t rsa C youremail@example.com, 

 

id_rsaid_rsa.pub

github, settingsSSH KeysAdd SSH Key,titleKeyid_rsa.pub



 Add Keykey




         GitgithubGitgithub

   githubcreate a new repo



Repository nametestgitCreate repositoryGit



    GitHubtestgitGitHubGitHub

GitHubtestgit

git remote add origin https://github.com/tugenhua0707/testgit.git



  

 git pushmaster

master uGitmastermastermastermastergithubgithub





git push origin master

mastergithub

2. 



 

githubtestgit2.







git clone



 testgit2





  GitGitmasterHEADmastermasterHEAD

devdev



git checkout  b2

git branch dev

git checkout dev

git branchdevdemoreadme.txt 7777777777777

readme.txt77777777



devmasterreadme.txt



devmastermaster git merge dev 



git mergereadme.txtdev

Fast-forwardGitmasterdev

dev





   git branch

   git branch name

   git checkout name

+git checkout b name

git merge name

git branch d name


fenzhi1readme.txt8888888



master99999999



masterfenzhi1



Git<<<<<<<=======>>>>>>><<<HEAD>>>>>fenzhi1 fenzhi1



 git log.



    3.

      gitFast forward no-ffFast forwarddemo

dev
readme.txt

(master)
dev git merge no-ff  -m  dev



 

masterdevdevmaster

bug

     bugbugGitbug

404 bug404dev

 

   bug2issue-404 bug5Gitstash 

  

   issue-404bug

bugmastermaster

 

masterissue-404



dev



 git stash list



Gitstash2

git stash applystashgit stash drop
git stash pop,stash
         





Gitmastermasterorigin

  git remote
  git remote v


 



      Git

       git push origin master

githubreadme.txt



readme.txt

 

readme.txt



githubreadme.txt 



 dev git push origin dev



master
bugmaster


masterSSH keygithubtestgit2

dev



testgit2

 





devorigindevdevgit checkout  b dev origin/dev

devdev





origin/dev



git pullorigin/dev



git pulldevorigin/devdevorigin/dev



git pull push

readme.txt



push




git push origin branch-name.
git pull
git push origin branch-name
Git

   mkdir         XX ( XX)

   pwd          

   git init          git.git

   git add XX       xx

   git commit m XX   m 

   git status        

   git diff  XX      XX

   git log          

   git reset  hard HEAD^  git reset  hard HEAD~ 

                        (100git reset hard HEAD~100 )

   cat XX         XX

   git reflog       id

   git checkout  XX  XX

   git rm XX          XX

   git remote add origin https://github.com/tugenhua0707/testgit 

   git push u(-u ) origin master master

   git clone https://github.com/tugenhua0707/testgit  

   git checkout b dev  dev dev

   git branch  

   git checkout master master

   git merge dev    dev

   git branch d dev dev

   git branch name  

   git stash  

   git stash list 

   git stash apply 

   git stash drop 

   git stash pop  

   git remote 

   git remote v 

   git push origin master  Gitmaster
===============
endof Git
